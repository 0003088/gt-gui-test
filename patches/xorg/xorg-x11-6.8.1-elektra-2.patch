diff -Naur xc.orig/programs/Xserver/hw/xfree86/common/Imakefile xc/programs/Xserver/hw/xfree86/common/Imakefile
--- xc.orig/programs/Xserver/hw/xfree86/common/Imakefile	2006-03-11 18:15:39.000000000 +0100
+++ xc/programs/Xserver/hw/xfree86/common/Imakefile	2006-03-11 16:09:00.000000000 +0100
@@ -77,6 +77,11 @@
 BACKTRACE_DEFS = -DHAVE_EXECINFO_H
 #endif
 
+#if defined(UseElektra)
+ELEKTRA_DEFINES = -DELEKTRA
+#endif
+
+
 SRCS =	\
 	xf86Configure.c \
 	xf86Bus.c \
@@ -207,6 +212,11 @@
 	      $(CONFIG_DEFINES) $(XKBDEFRULESDEFS) $(VENDORSUPPORTDEFS) \
 	      $(VENDOR_DEFINES) -DXF86PM
 
+#if defined(UseElektra)
+XCONFIGDEFINES += $(ELEKTRA_DEFINES)
+#endif
+
+
 AllTarget($(OFILES))
 
 SpecialCObjectRule(xf86Bus,NullParameter,$(BUGMSG) $(VGAINCLUDES))
diff -Naur xc.orig/programs/Xserver/hw/xfree86/common/xf86Config.c xc/programs/Xserver/hw/xfree86/common/xf86Config.c
--- xc.orig/programs/Xserver/hw/xfree86/common/xf86Config.c	2006-03-11 18:15:39.000000000 +0100
+++ xc/programs/Xserver/hw/xfree86/common/xf86Config.c	2006-03-12 01:46:13.000000000 +0100
@@ -44,6 +44,15 @@
  *      Marc La France <tsi@XFree86.Org>
  *      Egbert Eich <eich@XFree86.Org>
  *      ... and others
+ *
+ * Adapted to the Elektra key/value pair database:
+ *    Avi Alkalay <avi@unix.sh> november 2004
+ *    Elektra Project :: http://elektra.sourceforge.net
+ *  
+ * Yannick Lecaillez yl at itioweb.com
+ *    - Adapted to the new elektra API
+ *    - Check ELEKTRA env (ELEKTRA=disabled will ignore
+ *      elektra stuff)
  */
 
 #ifdef HAVE_XORG_CONFIG_H
@@ -66,6 +75,10 @@
 #include "xf86Priv.h"
 #include "xf86_OSlib.h"
 
+#ifdef ELEKTRA
+#include "elektra.h"
+#endif
+
 #include "globals.h"
 
 #ifdef XINPUT
@@ -2590,6 +2603,8 @@
     MessageType from = X_DEFAULT;
     char *scanptr;
     Bool singlecard = 0;
+    char *elektraEnv;
+    Bool ignoreElektra = 0;
 
     if (!autoconfig) {
 	if (getuid() == 0)
@@ -2600,6 +2615,45 @@
 	if (xf86ConfigFile)
 	    from = X_CMDLINE;
 
+#ifdef ELEKTRA
+	elektraEnv = getenv("ELEKTRA");
+	ignoreElektra = (elektraEnv == NULL) ? (0) : (strcmp("disabled", elektraEnv) == 0);
+	
+	
+	        /*
+		 * This is what we'll do:
+		 * 
+		 *	1. First look for configurations at the key database
+		 *	2. If found
+		 *		2.1. Put it on xf86configptr struct
+		 *	3. If not found
+		 *	3.1. Read some xorg.conf file and put parsed stuff on
+		 *	     xf86configptr structure
+		 *	3.2  Convert xf86configptr struct into a KeySet
+		 *	3.3  Write the KeySet to the key database
+		 *	3.4  Free KeySet and xf86configptr struct
+		 *	3.5  Get configuration keys again from the
+		 *	     just-commited key database into xf86configptr struct
+		 *	4. xf86configptr struct is ready to go
+		 **/
+
+	xf86configptr = NULL;
+	if ( !ignoreElektra ) {
+		xf86configptr=xf86getConfigKeys("system/sw/xorg/current");
+		if (xf86configptr)
+ 			xf86MsgVerb(from, 0, "Using configuration keys from: \"%s\"\n",
+					"system/sw/xorg/current");
+	 	else xf86configptr=xf86getConfigKeys("system/sw/xorg");
+			if (xf86configptr)
+				xf86MsgVerb(from, 0, "Using configuration keys from: \"%s\"\n",
+					"system/sw/xorg");
+	}
+
+	if ( xf86configptr == NULL ) {
+		/* fallback to old configuration file */
+#endif
+		
+	
 	filename = xf86openConfigFile(searchpath, xf86ConfigFile, PROJECTROOT);
 	if (filename) {
 	    xf86MsgVerb(from, 0, "Using config file: \"%s\"\n", filename);
@@ -2611,7 +2665,54 @@
 	    xf86ErrorFVerb(0, "\n");
 	    return CONFIG_NOFILE;
 	}
-    }
+#ifdef ELEKTRA
+
+	{
+		if ( !ignoreElektra ) {
+			KDBHandle	handle;
+	 		KeySet *ks;
+ 			char *rootkey="system/sw/xorg/current";
+			int ret;
+		
+	 		if ((xf86configptr = xf86readConfigFile ()) == NULL) {
+				xf86Msg(X_ERROR, "Problem parsing the config file\n");
+				return CONFIG_PARSE_ERROR;
+			}
+			xf86closeConfigFile ();
+		
+			/* Convert the parsed configuration into keys..... */
+		
+ 			/* Put the in-memory X configurations in a KeySet, also in memory */
+			ks=xf86collectConfigKeys(rootkey,xf86configptr);
+		
+			xf86MsgVerb(from, 0,
+					"Old \"%s\" configurations converted to key/value pairs.\n",
+					filename);
+			xf86MsgVerb(from, 0,
+					"Setting key/value pairs under: \"%s\"\n", rootkey);
+		
+			/* Really commit to the Key database */
+			kdbOpen(&handle);
+			ksRewind(ks);
+			ret=kdbSetKeys(handle, ks);
+			if (ret != 0) {
+				Key *problem;
+	 			char keyname[300]="";
+			
+ 				problem=ksCurrent(ks);
+				if (problem) keyGetFullName(problem,keyname,sizeof(keyname));
+				xf86ErrorFVerb(0, "Error while setting key \"%s\"\n", keyname);
+			}
+			ksClose(ks);
+			kdbClose(&handle);
+		}
+	}
+   	} /* if (xf86configptr) */
+    } /* if (! autoconfig) */
+#else /* ELEKTRA */
+    } /* if (! autoconfig) */
+
+	
      
     if ((xf86configptr = xf86readConfigFile ()) == NULL) {
 	xf86Msg(X_ERROR, "Problem parsing the config file\n");
@@ -2619,6 +2718,9 @@
     }
     xf86closeConfigFile ();
 
+#endif /* ! ELEKTRA */
+	/* xf86configptr is ready to go... */
+
     /* Initialise a few things. */
 
     /*
diff -Naur xc.orig/programs/Xserver/hw/xfree86/parser/elektra.c xc/programs/Xserver/hw/xfree86/parser/elektra.c
--- xc.orig/programs/Xserver/hw/xfree86/parser/elektra.c	1970-01-01 01:00:00.000000000 +0100
+++ xc/programs/Xserver/hw/xfree86/parser/elektra.c	2006-03-19 09:40:51.000000000 +0100
@@ -0,0 +1,3632 @@
+/* $Id$ */
+
+
+/*
+ * Copyright (c) 2004 by Avi Alkalay <avi at unix.sh>
+ *
+ * The Elektra Project :: http://elektra.sourceforge.net
+ *
+ *
+ * Change by Yannick Lecaillez <yl at itioweb.com >
+ * - Adapted to the new elektra API
+ * - Replaced static array with dynamicly allocated ones
+ * - Changed most of sprintf, strcpy, ... to snprintf, strncpy, ...
+ * - Fix "Modules/Load" when modulename contain path
+ * - Fix Buffers in DRI Section
+ * 
+ */
+
+/*
+ * Copyright (c) 1997-2003 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+#include <kdb.h> /* Elektra */
+
+#include "xf86Parser.h"
+#include "xf86tokens.h"
+#include "Configint.h"
+
+#if defined(__UNIXOS2__) || defined(WIN32)
+#define PATHSEPARATOR '\\'
+#else
+#define PATHSEPARATOR '/'
+#endif
+
+static char *
+prependRoot (char *pathname)
+{
+#ifndef __EMX__
+	return pathname;
+#else
+	/* XXXX caveat: multiple path components in line */
+	return (char *) __XOS2RedirRoot (pathname);
+#endif
+}
+
+
+
+
+
+
+
+
+/*
+ * Elektra version for the Files.c::xf86parseFilesSection() function
+ *
+ * Fetches keys under [rootKey]/Files and put in
+ * a XF86ConfFilesPtr struct.
+ *
+ */
+XF86ConfFilesPtr
+xf86getFiles (KDBHandle handle, const char *rootKey)
+{
+	KeySet	*settings;
+	Key *key;
+	size_t dataSize;
+	char *buffer;
+	size_t size;
+
+	size = 300;
+	buffer = xf86confmalloc(size);
+
+	/* funky declaration of internals.... */
+	parsePrologue (XF86ConfFilesPtr, XF86ConfFilesRec)
+
+	snprintf(buffer, size, "%s/Files", rootKey);
+	settings = ksNew();
+	kdbGetChildKeys(handle, buffer, settings, 0); 
+		
+	/* Get the FontPath */
+	snprintf(buffer, size, "%s/Files/FontPath", rootKey);
+	if ( (key = ksLookupByName(settings, buffer, KDB_O_LOOP)) ) {
+		dataSize = 100 + keyGetDataSize(key);
+		ptr->file_fontpath = xf86confmalloc (dataSize);
+		ptr->file_fontpath = prependRoot (ptr->file_fontpath);
+		keyGetString (key, ptr->file_fontpath, dataSize);
+	}
+
+	/* Get the RGBPath */
+	snprintf(buffer, size, "%s/Files/RgbPath", rootKey);
+	if ( (key = ksLookupByName(settings, buffer, KDB_O_LOOP)) ) {
+		dataSize = 100 + keyGetDataSize(key);
+		ptr->file_rgbpath = xf86confmalloc (dataSize);
+		ptr->file_rgbpath = prependRoot (ptr->file_rgbpath);
+		keyGetString (key, ptr->file_rgbpath, dataSize);
+	}
+
+	/* Get the ModulePath */
+	snprintf(buffer, size, "%s/Files/ModulePath", rootKey);
+	if ( (key = ksLookupByName(settings, buffer, KDB_O_LOOP)) ) {
+		dataSize = 100 + keyGetDataSize(key);
+		ptr->file_modulepath = xf86confmalloc (dataSize);
+		ptr->file_modulepath = prependRoot (ptr->file_modulepath);
+		keyGetString (key, ptr->file_modulepath, dataSize);
+	}
+
+	/* Get the InputDevices */
+	snprintf(buffer, size, "%s/Files/InputDevices", rootKey);
+	if ( (key = ksLookupByName(settings, buffer, KDB_O_LOOP)) ) {
+		dataSize = 100 + keyGetDataSize(key);
+		ptr->file_inputdevs = xf86confmalloc (dataSize);
+		ptr->file_inputdevs = prependRoot (ptr->file_inputdevs);
+		keyGetString (key, ptr->file_inputdevs, dataSize);
+	}
+
+	/* Get the LogFile */
+	snprintf(buffer, size, "%s/Files/LogFile", rootKey);
+	if ( (key = ksLookupByName(settings, buffer, KDB_O_LOOP)) ) {
+		dataSize = 100 + keyGetDataSize(key);
+		ptr->file_logfile = xf86confmalloc (dataSize);
+		ptr->file_logfile = prependRoot (ptr->file_logfile);
+		keyGetString (key, ptr->file_logfile, dataSize);
+	}
+
+	ksDel(settings);
+
+	xf86conffree(buffer);
+	
+#ifdef DEBUG
+	printf ("File keys grabed\n");
+#endif
+
+	return ptr;
+}
+
+
+/*
+ * Elektra version of Files.c::xf86printFileSection function
+ *
+ * Generates a KeySet from a passed XF86ConfFilesPtr struct plus
+ * a root key name.
+ *
+ */
+void
+xf86addFiles(KeySet *ks, const char *root, XF86ConfFilesPtr ptr) {
+	char *buffer;
+	size_t bsize;
+	Key *key=NULL;
+
+	buffer = xf86confmalloc((bsize = strlen(root) + 50));
+	
+	if (ptr->file_logfile) {
+		snprintf(buffer, bsize, "%s/Files/LogFile", root);
+		key = keyNew(buffer, 
+				KEY_SWITCH_VALUE, ptr->file_logfile,
+				KEY_SWITCH_END);
+
+		ksAppend(ks,key);
+	}
+
+	if (ptr->file_rgbpath) {
+		snprintf(buffer, bsize, "%s/Files/RgbPath", root);
+		key = keyNew(buffer,
+				KEY_SWITCH_VALUE, ptr->file_rgbpath,
+				KEY_SWITCH_END);
+
+		ksAppend(ks,key);
+	}
+
+	if (ptr->file_modulepath) {
+		snprintf(buffer, bsize, "%s/Files/ModulePath", root);
+		key = keyNew(buffer,
+				KEY_SWITCH_VALUE, ptr->file_modulepath,
+				KEY_SWITCH_END);
+
+		ksAppend(ks,key);
+	} else {
+		/* No module path provided, set to the default one */
+		snprintf(buffer, bsize, "%s/Files/ModulePath", root);
+		key = keyNew(buffer,
+				KEY_SWITCH_VALUE, MODULE_DIR,
+				KEY_SWITCH_END);
+		
+		ksAppend(ks,key);
+	}
+
+	if (ptr->file_inputdevs) {
+		snprintf(buffer, bsize, "%s/Files/InputDevices", root);
+		key = keyNew(buffer,
+				KEY_SWITCH_VALUE, ptr->file_inputdevs,
+				KEY_SWITCH_END);
+
+		ksAppend(ks,key);
+	}
+
+	if (ptr->file_fontpath) {
+		snprintf(buffer, bsize, "%s/Files/FontPath", root);
+		key = keyNew(buffer,
+				KEY_SWITCH_VALUE, ptr->file_fontpath,
+				KEY_SWITCH_END);
+
+		ksAppend(ks,key);
+	}
+
+	xf86conffree(buffer);
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+/* Begin options handling helpers */
+
+/*
+ * Elektra equivalent for Flags.c::xf86newOption()
+ *
+ * Helper function to create an XF86OptionPtr from a Key.
+ *
+ */
+XF86OptionPtr
+keyToOption(Key *key)
+{
+	XF86OptionPtr option;
+
+	char *optionName = NULL;
+	char *data = NULL;
+	size_t optionSize=0;
+	size_t dataSize=0;
+	size_t commentSize=0;
+
+	optionName = xf86confmalloc (optionSize=keyGetBaseNameSize(key));
+	commentSize=keyGetCommentSize(key);
+	dataSize=keyGetDataSize(key);
+	if (dataSize>1) {
+		/* if we have here more than a simple NULL string */
+		data = xf86confmalloc (dataSize);
+	}
+
+	if (optionName)
+		keyGetBaseName(key,optionName,optionSize);
+	if (data)
+		keyGetString(key,data,dataSize);
+
+	option = xf86newOption (optionName,data);
+	if (commentSize) {
+		option->opt_comment = xf86confmalloc (commentSize);
+		if (option->opt_comment)
+			keyGetComment(key,option->opt_comment,commentSize);
+	}
+
+	return option;
+}
+
+
+
+/*
+ * Helper function to create an linked list of XF86OptionPtr from a KeySet.
+ *
+ */
+XF86OptionPtr
+ksToOptions(KeySet *ks)
+{
+	Key *key;
+	XF86OptionPtr option=NULL;
+	XF86OptionPtr options=NULL;
+
+	/* reset internal cursor */
+	ksRewind(ks);
+	while ((key=ksNext(ks))) {
+		option=keyToOption(key);
+		options=((XF86OptionPtr)xf86addListItem((glp)options,
+			(glp)option));
+	}
+
+	return options;
+}
+
+
+
+/*
+ * Elektra version of Flags.c::xf86printOptionList()
+ *
+ * Generates a KeySet from a passed linked list of XF86OptionPtr struct
+ * plus a root key name.
+ *
+ */
+void
+xf86addOptions(KeySet *ks,const char *root,XF86OptionPtr list) {
+	char *buffer;
+	size_t bsize;
+	Key *key=NULL;
+
+	if (!list)
+		return;
+	
+	bsize = strlen(root) + 50;
+	buffer = xf86confmalloc(bsize);
+	while (list) {
+		printf("xf86addOptions(%s/%s, %s)\n", root, list->opt_name, list->opt_val);
+		
+		snprintf(buffer, bsize, "%s/%s", root, list->opt_name);
+
+		key = keyNew(buffer,
+				KEY_SWITCH_COMMENT, list->opt_comment,
+				KEY_SWITCH_END);
+		
+		if (list->opt_val) keySetString(key,list->opt_val);
+		/* else keySetString(key,"1"); */
+
+		list = list->list.next;
+
+		ksAppend(ks,key);
+	}
+	xf86conffree(buffer);
+}
+
+
+/* End options handling helpers */
+
+
+
+
+
+
+
+
+
+
+/*
+ * Elektra version for the Flags.c::xf86parseFlagsSection() function
+ *
+ * Fetch keys under [rootKey]/ServerFlags and put in
+ * a XF86ConfFlagsPtr struct.
+ *
+ */
+XF86ConfFlagsPtr
+xf86getFlags (KDBHandle handle, const char *rootKey)
+{
+	KeySet *optionKeys;
+	char *serverFlagsRoot;
+	size_t bsize;
+	XF86OptionPtr options = NULL;
+	XF86ConfFlagsPtr ptr=NULL; /* we'll return this */
+
+	serverFlagsRoot = xf86confmalloc((bsize = strlen(rootKey) + 50));
+	
+	snprintf(serverFlagsRoot, bsize, "%s/ServerFlags", rootKey);	
+
+	optionKeys = ksNew();
+	kdbGetChildKeys(handle, serverFlagsRoot,optionKeys,KDB_O_SORT);
+	if (ksGetSize(optionKeys))
+		options=ksToOptions(optionKeys);
+	ksDel(optionKeys);
+
+	if (options) {
+		ptr=xf86confmalloc(sizeof(XF86ConfFlagsRec));
+		memset(ptr,0,sizeof(XF86ConfFlagsRec));
+		ptr->flg_option_lst=options;
+	}
+
+#ifdef DEBUG
+	printf ("Flags keys grabed\n");
+#endif
+
+	xf86conffree(serverFlagsRoot);
+
+	return ptr;
+}
+
+
+
+/*
+ * Elektra version of Flags.c::xf86printServerFlagsSection()
+ *
+ * Generates a KeySet from a passed linked list of XF86ConfFlagsPtr struct
+ * plus a root key name.
+ *
+ */
+void
+xf86addFlags(KeySet *ks, const char *root, XF86ConfFlagsPtr flags) {
+	char *buffer;
+	size_t bsize;
+	XF86OptionPtr p;
+
+	if ((!flags) || (!flags->flg_option_lst))
+		return;
+	p = flags->flg_option_lst;
+
+	buffer = xf86confmalloc((bsize = strlen(root) + 50));
+	
+	snprintf(buffer, bsize, "%s/ServerFlags", root);	
+	xf86addOptions(ks,buffer,p);
+
+	xf86conffree(buffer);
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+/*
+ * Elektra version for the Input.c::xf86parseInputSection() function.
+ *
+ * Fetch keys under [rootKey]/InputDevices and put in a XF86ConfInputPtr.
+ * All input devices, including keyboard and mice are there.
+ *
+ */
+XF86ConfInputPtr
+xf86getInput (KDBHandle handle, const char *rootKey)
+{
+	KeySet *inputDevs;
+	Key *current;
+	int ret;
+	char *localRootKey;
+	size_t bsize;
+
+	localRootKey = xf86confmalloc((bsize = strlen(rootKey) + 50));
+	
+	XF86ConfInputPtr ptr = NULL; /* this is what we'll return */
+
+	snprintf(localRootKey, bsize, "%s/InputDevices", rootKey);
+
+	inputDevs = ksNew();
+	/*
+	 * There should be only folders right under InputDevices/.
+	 * So we are interested only in the skeleton.
+	 */
+	kdbGetChildKeys(handle, localRootKey, inputDevs,
+		KDB_O_DIR | KDB_O_NOVALUE | KDB_O_SORT);
+
+	xf86conffree(localRootKey);
+
+	ksRewind(inputDevs);
+	while ((current=ksNext(inputDevs))) {
+		/* each entry we'll process is an InputDevice */
+		XF86ConfInputPtr inputdev;
+		size_t identSize,dataSize;
+		Key *driver;
+		KeySet *optionKeys;
+		char *options=NULL;
+
+		inputdev=xf86confcalloc(1,sizeof(XF86ConfInputRec));
+		memset(inputdev,0,sizeof(XF86ConfInputRec));
+
+		identSize=keyGetBaseNameSize(current);
+
+		inputdev->inp_identifier=xf86confmalloc(identSize);
+		if (inputdev->inp_identifier)
+			keyGetBaseName(current,inputdev->inp_identifier,identSize);
+
+		/* Get the driver */
+		driver = keyNew(KEY_SWITCH_END);
+		ret=kdbGetKeyByParentKey(handle, current,"Driver",driver);
+		if (ret == 0) {
+			dataSize=keyGetDataSize(driver);
+			inputdev->inp_driver=xf86confmalloc(dataSize);
+			keyGetString(driver,inputdev->inp_driver,dataSize);
+			dataSize=keyGetCommentSize(driver);
+			if (dataSize) {
+				inputdev->inp_comment=xf86confmalloc(dataSize);
+				keyGetComment(driver,inputdev->inp_comment,dataSize);
+			}
+		}
+		keyDel(driver);
+
+		/* Now get this device's options */
+		dataSize=keyGetFullNameSize(current)+30;
+		options=xf86confmalloc(dataSize);
+		keyGetFullName(current,options,dataSize);
+		strncat(options,"/Options", dataSize-1);
+
+		optionKeys = ksNew();
+		kdbGetChildKeys(handle, options,optionKeys,KDB_O_SORT);
+		if (ksGetSize(optionKeys))
+			inputdev->inp_option_lst=ksToOptions(optionKeys);
+		xf86conffree (options);
+		ksDel(optionKeys);
+
+		/* Finished with this device. Now add to our devices list */
+		if (ptr) ptr=(XF86ConfInputPtr)
+			xf86addListItem ((glp) ptr, (glp) inputdev);
+		else  ptr=inputdev;
+	}
+
+	ksDel(inputDevs);
+
+#ifdef DEBUG
+	printf ("InputDevice keys grabed\n");
+#endif
+
+	return ptr;
+}
+
+
+/*
+ * Elektra version of Input.c::xf86printInputSection()
+ *
+ * Generates a KeySet from a passed linked list of XF86ConfInputPtr struct
+ * plus a root key name.
+ *
+ */
+void
+xf86addInput(KeySet *ks, const char *root, XF86ConfInputPtr ptr) {
+	char *buffer;
+	size_t bsize;
+	Key *key;
+
+	buffer = xf86confmalloc((bsize=strlen(root) + strlen(ptr->inp_identifier) + 50));
+	
+	while (ptr) {
+		snprintf(buffer, bsize, "%s/InputDevices/%s/Driver",root,ptr->inp_identifier);
+		key = keyNew(buffer,
+			KEY_SWITCH_VALUE, ptr->inp_driver,
+			KEY_SWITCH_COMMENT, ptr->inp_comment,
+			KEY_SWITCH_END);
+		ksAppend(ks,key);
+
+		snprintf(buffer, bsize, "%s/InputDevices/%s/Options",root,ptr->inp_identifier);
+		xf86addOptions(ks,buffer,ptr->inp_option_lst);
+
+		ptr=ptr->list.next;
+	}
+
+	xf86conffree(buffer);
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+/*
+ * Elektra version for the Device.c::xf86parseDeviceSection() function
+ *
+ * Fetch keys under [rootKey]/Devices.
+ * All video cards are there.
+ *
+ * TODO: check int and float conversions
+ *
+ */
+
+XF86ConfDevicePtr
+xf86getDevice (KDBHandle handle, const char *rootKey)
+{
+	KeySet *devices;
+	Key *current;
+	char *localRootKey;
+	size_t bsize;
+	
+	localRootKey = xf86confmalloc((bsize=strlen(rootKey)+50));
+
+	XF86ConfDevicePtr ptr = NULL;
+
+	snprintf(localRootKey, bsize, "%s/Devices", rootKey);
+
+	devices = ksNew();
+	/*
+	 * There should be only folders right under Devices/.
+	 * So we are interested only in the skeleton.
+	 */
+	kdbGetChildKeys(handle, localRootKey, devices,
+		KDB_O_DIR | KDB_O_NOVALUE | KDB_O_SORT);
+	xf86conffree(localRootKey);
+
+	ksRewind(devices);
+	while ((current=ksNext(devices))) {
+		/* each entry we'll process is a Device */
+		XF86ConfDevicePtr device;
+		KeySet *deviceSettings;
+		KeySet *optionKeys;
+		Key *currentSetting;
+		size_t identSize, dataSize, bufSize;
+		char *buffer;
+
+		buffer = xf86confmalloc((bufSize=strlen(keyStealName(current)) + 100));
+
+		device=xf86confcalloc(1,sizeof(XF86ConfDeviceRec));
+		memset(device,0,sizeof(XF86ConfDeviceRec));
+			
+		/* Zero is a valid value for these */
+		device->dev_chipid = -1;
+		device->dev_chiprev = -1;
+		device->dev_irq = -1;
+			
+		identSize=keyGetBaseNameSize(current);
+		device->dev_identifier=xf86confmalloc(identSize);
+		if (device->dev_identifier)
+			keyGetBaseName(current,device->dev_identifier,identSize);
+
+		/* 
+		 * Fetch settings for this Device
+		 */
+		deviceSettings=ksNew();
+		kdbGetKeyChildKeys(handle, current, deviceSettings, 0);
+
+		/* Get Vendor */
+		snprintf(buffer, bufSize, "%s/VendorName", keyStealName(current));
+		if ( (currentSetting = ksLookupByName(deviceSettings, buffer, KDB_O_LOOP)) ) {
+			dataSize = keyGetDataSize(currentSetting);
+			device->dev_vendor=xf86confmalloc(dataSize);
+			keyGetString(currentSetting, device->dev_vendor, dataSize);
+		}
+
+		/* Get Board */
+		snprintf(buffer, bufSize, "%s/BoardName", keyStealName(current));
+		if ( (currentSetting = ksLookupByName(deviceSettings, buffer, KDB_O_LOOP)) ) {
+			dataSize = keyGetDataSize(currentSetting);
+			device->dev_board=xf86confmalloc(dataSize);
+			keyGetString(currentSetting, device->dev_board, dataSize);
+		}
+
+		/* Get Chipset */
+		snprintf(buffer, bufSize, "%s/Chipset", keyStealName(current));
+		if ( (currentSetting = ksLookupByName(deviceSettings, buffer, KDB_O_LOOP)) ) {
+			dataSize = keyGetDataSize(currentSetting);				
+			device->dev_chipset=xf86confmalloc(dataSize);
+			keyGetString(currentSetting, device->dev_chipset, dataSize);
+		}
+
+		/* Get Card */
+		snprintf(buffer, bufSize, "%s/Card", keyStealName(current));
+		if ( (currentSetting = ksLookupByName(deviceSettings, buffer, KDB_O_LOOP)) ) {
+			dataSize = keyGetDataSize(currentSetting);
+			device->dev_card=xf86confmalloc(dataSize);
+			keyGetString(currentSetting, device->dev_card, dataSize);
+		}
+
+		/* Get Driver */
+		snprintf(buffer, bufSize, "%s/Driver", keyStealName(current));
+		if ( (currentSetting = ksLookupByName(deviceSettings, buffer, KDB_O_LOOP)) ) {
+			dataSize = keyGetDataSize(currentSetting);
+			device->dev_driver=xf86confmalloc(dataSize);
+			keyGetString(currentSetting, device->dev_driver, dataSize);
+		}
+
+		/* Get Ramdac */
+		snprintf(buffer, bufSize, "%s/Ramdac", keyStealName(current));
+		if ( (currentSetting = ksLookupByName(deviceSettings, buffer, KDB_O_LOOP)) ) {
+			dataSize = keyGetDataSize(currentSetting);	
+			device->dev_ramdac=xf86confmalloc(dataSize);
+			keyGetString(currentSetting, device->dev_ramdac, dataSize);
+		}
+
+		/* Get DacSpeed */
+		snprintf(buffer, bufSize, "%s/DacSpeed", keyStealName(current));
+		if ( (currentSetting = ksLookupByName(deviceSettings, buffer, KDB_O_LOOP)) ) {
+			int i;
+			char *speed=buffer;
+			char *speedEnd=speed;
+			
+			for (i = 0; i < CONF_MAXDACSPEEDS; i++)
+				device->dev_dacSpeeds[i] = 0;
+			
+			keyGetString(currentSetting, buffer, bufSize);
+			i=0;
+			do {
+				speed=speedEnd;
+				device->dev_dacSpeeds[i] = (int) (strtod(speed,&speedEnd) * 1000.0 + 0.5);
+			} while (i<CONF_MAXDACSPEEDS && speed!=speedEnd);
+		}
+
+		/* Get VideoRam */
+		snprintf(buffer, bufSize, "%s/VideoRam", keyStealName(current));
+		if ( (currentSetting = ksLookupByName(deviceSettings, buffer, KDB_O_LOOP)) ) {
+			device->dev_videoram=strtol(keyStealValue(currentSetting), NULL, 10);
+		}
+		
+		/* Get BIOSBase */
+		snprintf(buffer, bufSize, "%s/BIOSBase", keyStealName(current));
+		if ( (currentSetting = ksLookupByName(deviceSettings, buffer, KDB_O_LOOP)) ) {
+			device->dev_bios_base=strtol(keyStealValue(currentSetting), NULL, 10);
+		}
+		
+		/* Get MemBase */
+		snprintf(buffer, bufSize, "%s/MemBase", keyStealName(current));
+		if ( (currentSetting = ksLookupByName(deviceSettings, buffer, KDB_O_LOOP)) ) {
+			device->dev_mem_base=strtol(keyStealValue(currentSetting), NULL, 10);
+		}
+			
+		/* Get IOBase */
+		snprintf(buffer, bufSize, "%s/IOBase", keyStealName(current));
+		if ( (currentSetting = ksLookupByName(deviceSettings, buffer, KDB_O_LOOP)) ) {
+			device->dev_io_base=strtol(keyStealValue(currentSetting), NULL, 10);
+		}
+
+		/* Get ClockChip */
+		snprintf(buffer, bufSize, "%s/ClockChip", keyStealName(current));
+		if ( (currentSetting = ksLookupByName(deviceSettings, buffer, KDB_O_LOOP)) ) {
+			dataSize = keyGetDataSize(currentSetting);
+			device->dev_clockchip=xf86confmalloc(dataSize);
+			keyGetString(currentSetting,device->dev_clockchip,dataSize);
+		}
+
+		/* Get ChipID */
+		snprintf(buffer, bufSize, "%s/ChipID", keyStealName(current));
+		if ( (currentSetting = ksLookupByName(deviceSettings, buffer, KDB_O_LOOP)) ) {
+			device->dev_chipid=strtol(keyStealValue(currentSetting), NULL, 10);
+		}
+		
+		/* Get ChipRev */
+		snprintf(buffer, bufSize, "%s/ChipRev", keyStealName(current));
+		if ( (currentSetting = ksLookupByName(deviceSettings, buffer, KDB_O_LOOP)) ) {
+			device->dev_chiprev=strtol(keyStealValue(currentSetting), NULL, 10);
+		}
+
+		/* Get Clocks */
+		snprintf(buffer, bufSize, "%s/Clocks", keyStealName(current));
+		if ( (currentSetting = ksLookupByName(deviceSettings, buffer, KDB_O_LOOP)) ) {
+			int i;
+			char *clock=NULL;
+			char *clockEnd=buffer;
+			
+			for (i = 0; i < CONF_MAXCLOCKS; i++)
+				device->dev_clock[i] = 0;
+			
+			keyGetString(currentSetting, buffer, bufSize);
+			
+			i=0;
+			do {
+				clock=clockEnd;
+				device->dev_clock[i] =
+					(int) (strtod(clock,&clockEnd) * 1000.0 + 0.5);
+			} while (i<CONF_MAXCLOCKS && clock!=clockEnd);
+		}
+
+		/* Get TextClockFreq */
+		snprintf(buffer, bufSize, "%s/TextClockFreq", keyStealName(current));
+		if ( (currentSetting = ksLookupByName(deviceSettings, buffer, KDB_O_LOOP)) ) {
+			device->dev_textclockfreq =
+			       	(int) (strtod(keyStealValue(currentSetting), NULL) * 1000.0 + 0.5);
+		}
+
+		/* Get BusID */
+		snprintf(buffer, bufSize, "%s/BusID", keyStealName(current));
+		if ( (currentSetting = ksLookupByName(deviceSettings, buffer, KDB_O_LOOP)) ) {
+			dataSize = keyGetDataSize(currentSetting);
+			device->dev_busid=xf86confmalloc(dataSize);
+			keyGetString(currentSetting,device->dev_busid,dataSize);
+		}
+
+		/* Get IRQ */
+		snprintf(buffer, bufSize, "%s/IRQ", keyStealName(current));
+		if ( (currentSetting = ksLookupByName(deviceSettings, buffer, KDB_O_LOOP)) ) {
+			device->dev_irq=strtol(keyStealValue(currentSetting), NULL, 10);
+		}
+
+		/* Get Screen */
+		snprintf(buffer, bufSize, "%s/Screen", keyStealName(current));
+		if ( (currentSetting = ksLookupByName(deviceSettings, buffer, KDB_O_LOOP)) ) {
+			device->dev_screen=strtol(keyStealValue(currentSetting), NULL, 10);
+		}
+		ksDel(deviceSettings);
+						
+		/*
+		 * Now get this device's options
+		 */
+		snprintf(buffer, bufSize, "%s/Options", keyStealName(current));
+
+		optionKeys = ksNew();
+		kdbGetChildKeys(handle, buffer,optionKeys,KDB_O_SORT);
+		if (ksGetSize(optionKeys))
+			device->dev_option_lst=ksToOptions(optionKeys);
+		ksDel(optionKeys);
+
+		/* Finished with this device. Now add to our devices list */
+		if (ptr) ptr=(XF86ConfDevicePtr)
+			xf86addListItem ((glp) ptr, (glp) device);
+		else  ptr=device;
+
+		xf86conffree(buffer);
+	}
+	ksDel(devices);
+
+
+#ifdef DEBUG
+	printf ("Device keys grabed\n");
+#endif
+
+	return ptr;
+}
+
+
+/*
+ * Elektra version of Device.c::xf86printDeviceSection()
+ *
+ * Generates a KeySet from a passed linked list of XF86ConfDevicePtr struct
+ * plus a root key name.
+ *
+ */
+void
+xf86addDevice (KeySet *ks, const char *root, XF86ConfDevicePtr ptr) {
+	char *buffer;
+	char *devroot;
+	char *value;
+	size_t bufSize;
+	Key *key;
+
+	bufSize = strlen(root) + 50 + strlen(ptr->dev_identifier) + 50;
+	devroot = xf86confmalloc(bufSize);
+	buffer  = xf86confmalloc(bufSize);
+	value   = xf86confmalloc(bufSize);
+	
+	while (ptr) {
+		snprintf(devroot, bufSize, "%s/Devices/%s",root,ptr->dev_identifier);
+
+		if (ptr->dev_driver) {
+			snprintf(buffer, bufSize, "%s/Driver",devroot);
+			key = keyNew(buffer,
+					KEY_SWITCH_VALUE, ptr->dev_driver,
+					KEY_SWITCH_END);
+			ksAppend(ks,key);
+		}
+
+		if (ptr->dev_vendor) {
+			snprintf(buffer, bufSize, "%s/VendorName",devroot);
+			key = keyNew(buffer,
+					KEY_SWITCH_VALUE, ptr->dev_vendor,
+					KEY_SWITCH_END);
+			ksAppend(ks,key);
+		}
+
+
+		if (ptr->dev_board) {
+			snprintf(buffer, bufSize, "%s/BoardName",devroot);
+			key = keyNew(buffer,
+					KEY_SWITCH_VALUE, ptr->dev_board,
+					KEY_SWITCH_END);
+			ksAppend(ks,key);
+		}
+
+		if (ptr->dev_chipset) {
+			snprintf(buffer, bufSize, "%s/Chipset",devroot);
+			key = keyNew(buffer,
+					KEY_SWITCH_VALUE, ptr->dev_chipset,
+					KEY_SWITCH_END);
+			ksAppend(ks,key);
+		}
+
+		if (ptr->dev_card) {
+			snprintf(buffer, bufSize, "%s/Card",devroot);
+			key = keyNew(buffer,
+					KEY_SWITCH_VALUE, ptr->dev_card,
+					KEY_SWITCH_END);
+			ksAppend(ks,key);
+		}
+
+		if (ptr->dev_ramdac) {
+			snprintf(buffer, bufSize, "%s/RamDac",devroot);
+			key = keyNew(buffer,
+					KEY_SWITCH_VALUE, ptr->dev_ramdac,
+					KEY_SWITCH_END);
+			ksAppend(ks,key);
+		}
+
+		if (ptr->dev_dacSpeeds[0] > 0 ) {
+			int i;
+
+			snprintf(buffer, bufSize, "%s/DacSpeed",devroot);
+
+			value[0]=0;
+			for (i = 0; i < CONF_MAXDACSPEEDS
+					&& ptr->dev_dacSpeeds[i] > 0; i++ ) {
+				char num[30];
+				snprintf(num, sizeof(num), "%g ", (double) (ptr->dev_dacSpeeds[i])/ 1000.0);
+				strncat(value,num, bufSize-1);
+			}
+
+			key = keyNew(buffer, 
+					KEY_SWITCH_VALUE, value,
+					KEY_SWITCH_END);
+			ksAppend(ks,key);
+		}
+
+		if (ptr->dev_videoram) {
+			snprintf(buffer, bufSize, "%s/VideoRam",devroot);
+			snprintf(value, bufSize, "%d",ptr->dev_videoram);
+			key = keyNew(buffer,
+					KEY_SWITCH_VALUE, value,
+					KEY_SWITCH_END);
+			ksAppend(ks,key);
+		}
+
+		if (ptr->dev_bios_base) {
+			snprintf(buffer, bufSize, "%s/BiosBase",devroot);
+			snprintf(value, bufSize, "0x%lx",ptr->dev_bios_base);
+			key = keyNew(buffer,
+					KEY_SWITCH_VALUE, value,
+					KEY_SWITCH_END);
+			ksAppend(ks,key);
+		}
+
+		if (ptr->dev_mem_base) {
+			snprintf(buffer, bufSize, "%s/MemBase",devroot);
+			snprintf(value, bufSize, "0x%lx",ptr->dev_mem_base);
+			key = keyNew(buffer,
+					KEY_SWITCH_VALUE, value,
+					KEY_SWITCH_END);
+			ksAppend(ks,key);
+		}
+
+		if (ptr->dev_io_base) {
+			snprintf(buffer, bufSize, "%s/IOBase",devroot);
+			snprintf(value, bufSize, "0x%lx",ptr->dev_io_base);
+			key = keyNew(buffer,
+					KEY_SWITCH_VALUE, value,										                                        KEY_SWITCH_END);
+			ksAppend(ks,key);
+		}
+
+		if (ptr->dev_clockchip) {
+			snprintf(buffer, bufSize, "%s/ClockChip",devroot);
+			key = keyNew(buffer, 
+					KEY_SWITCH_VALUE, ptr->dev_clockchip,
+					KEY_SWITCH_END);
+			ksAppend(ks,key);
+		}
+
+		if (ptr->dev_chipid != -1) {
+			snprintf(buffer, bufSize, "%s/ChipID",devroot);
+			snprintf(value, bufSize, "0x%x",ptr->dev_chipid);
+			key = keyNew(buffer,
+					KEY_SWITCH_VALUE, value,
+					KEY_SWITCH_END);
+			ksAppend(ks,key);
+		}
+
+		if (ptr->dev_chiprev != -1) {
+			snprintf(buffer, bufSize, "%s/ChipRev",devroot);
+			snprintf(value, bufSize, "0x%x",ptr->dev_chiprev);
+			key = keyNew(buffer,
+					KEY_SWITCH_VALUE, value,
+					KEY_SWITCH_END);
+			ksAppend(ks,key);
+		}
+
+		if (ptr->dev_clocks > 0 ) {
+			int i;
+
+			snprintf(buffer, bufSize, "%s/Clocks",devroot);
+
+			value[0]=0;
+			for (i = 0; i < ptr->dev_clocks; i++ ) {
+				char num[30];
+				snprintf (num, sizeof(num), "%.1f ", (double)ptr->dev_clock[i] / 1000.0);
+				strncat(value,num, bufSize-1);
+			}
+			key = keyNew(buffer,
+					KEY_SWITCH_VALUE, value,
+					KEY_SWITCH_END);
+			ksAppend(ks, key);
+		}
+
+		if (ptr->dev_textclockfreq) {
+			snprintf(buffer, bufSize, "%s/TextClockFreq",devroot);
+			snprintf(value, bufSize, "%.1f",(double)ptr->dev_textclockfreq / 1000.0);
+			key = keyNew(buffer,
+					KEY_SWITCH_VALUE, value,
+					KEY_SWITCH_END);
+			ksAppend(ks,key);
+		}
+
+
+		if (ptr->dev_busid) {
+			snprintf(buffer, bufSize, "%s/BusID",devroot);
+			key = keyNew(buffer,
+					KEY_SWITCH_VALUE, ptr->dev_busid,
+					KEY_SWITCH_END);
+			ksAppend(ks,key);
+		}
+
+		if (ptr->dev_screen > 0) {
+			snprintf(buffer, bufSize, "%s/Screen",devroot);
+			snprintf(value, bufSize, "%d",ptr->dev_screen);
+			key = keyNew(buffer,
+					KEY_SWITCH_VALUE, value,
+					KEY_SWITCH_END);
+			ksAppend(ks,key);
+		}
+
+		if (ptr->dev_irq >= 0) {
+			snprintf(buffer, bufSize, "%s/IRQ",devroot);
+			snprintf(value, bufSize, "%d",ptr->dev_irq);
+			key = keyNew(buffer,
+					KEY_SWITCH_VALUE, value,
+					KEY_SWITCH_END);
+			ksAppend(ks,key);
+		}
+
+		snprintf(buffer, bufSize, "%s/Options",devroot);
+		xf86addOptions(ks, buffer, ptr->dev_option_lst);
+
+		ptr=ptr->list.next;
+	}
+
+	xf86conffree(value);
+	xf86conffree(buffer);
+	xf86conffree(devroot);
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+/*
+ * Together with xf86getModes(), is the Elektra version of
+ * the Monitor.c::xf86parseVerboseMode() function.
+ *
+ * Converts a KeySet into a XF86ConfModeLinePtr struct.
+ *
+ */
+XF86ConfModeLinePtr
+ksToModes(KDBHandle handle, KeySet *ks)
+{
+	Key *key;
+	char *buffer;
+	size_t size;
+	XF86ConfModeLinePtr mode=NULL;
+	XF86ConfModeLinePtr modes=NULL; /* we'll return this */
+
+	size = 300;
+	buffer = xf86confmalloc(size);
+	
+	ksRewind(ks);
+	while ((key=ksNext(ks))) {
+		KeySet *settings;
+		Key *subKey;
+		size_t dataSize;
+
+		/* initialize an object */
+		mode=xf86confcalloc(1,sizeof(XF86ConfModeLineRec));
+		memset(mode,0,sizeof(XF86ConfModeLineRec));
+
+		/* calculate identifier from key basename */
+		dataSize=keyGetBaseNameSize(key);
+		mode->ml_identifier=xf86confmalloc(dataSize);
+		keyGetBaseName(key,mode->ml_identifier,dataSize);
+
+		/*
+		 * Fetch ModeLine settings
+		 */
+		settings = ksNew();
+		kdbGetKeyChildKeys(handle, key, settings, 0);
+			
+		/* Get DotClock */
+		snprintf(buffer, size, "%s/DotClock", keyStealName(key));
+		if ( (subKey = ksLookupByName(settings, buffer, KDB_O_LOOP)) ) {
+			mode->ml_clock=(int)(strtod(keyStealValue(subKey),NULL) * 1000.0 + 0.5);
+		}
+			
+		/* Get HTimings' hdisplay */
+		snprintf(buffer, size, "%s/HTimings.hdisp", keyStealName(key));
+		if ( (subKey = ksLookupByName(settings, buffer, KDB_O_LOOP)) ) {
+			mode->ml_hdisplay=strtol(keyStealValue(subKey),NULL,10);
+		}
+			
+		/* Get HTimings' hsyncstart */
+		snprintf(buffer, size, "%s/HTimings.hsyncstart", keyStealName(key));
+		if ( (subKey = ksLookupByName(settings, buffer, KDB_O_LOOP)) ) {
+			mode->ml_hsyncstart=strtol(keyStealValue(subKey),NULL,10);
+		}
+			
+		/* Get HTimings' hsyncend */
+		snprintf(buffer, size, "%s/HTimings.hsyncend", keyStealName(key));
+		if ( (subKey = ksLookupByName(settings, buffer, KDB_O_LOOP)) ) {
+			mode->ml_hsyncend=strtol(keyStealValue(subKey),NULL,10);
+		}
+			
+		/* Get HTimings' htotal */
+		snprintf(buffer, size, "%s/HTimings.htotal", keyStealName(key));
+		if ( (subKey = ksLookupByName(settings, buffer, KDB_O_LOOP)) ) {
+			mode->ml_htotal=strtol(keyStealValue(subKey),NULL,10);
+		}
+			
+		/* Get VTimings' vdisplay */
+		snprintf(buffer, size, "%s/VTimings.vdisp", keyStealName(key));
+		if ( (subKey = ksLookupByName(settings, buffer, KDB_O_LOOP)) ) {
+			mode->ml_vdisplay=strtol(keyStealValue(subKey),NULL,10);
+		}
+			
+		/* Get VTimings' vsyncstart */
+		snprintf(buffer, size, "%s/VTimings.vsyncstart", keyStealName(key));
+		if ( (subKey = ksLookupByName(settings, buffer, KDB_O_LOOP)) ) {
+			mode->ml_vsyncstart=strtol(keyStealValue(subKey),NULL,10);
+		}
+			
+		/* Get VTimings' vsyncend */
+		snprintf(buffer, size, "%s/VTimings.vsyncend", keyStealName(key));
+		if ( (subKey = ksLookupByName(settings, buffer, KDB_O_LOOP)) ) {
+			mode->ml_vsyncend=strtol(keyStealValue(subKey),NULL,10);
+		}
+			
+		/* Get VTimings' vtotal */
+		snprintf(buffer, size, "%s/VTimings.vtotal", keyStealName(key));
+		if ( (subKey = ksLookupByName(settings, buffer, KDB_O_LOOP)) ) {
+			mode->ml_vtotal=strtol(keyStealValue(subKey),NULL,10);
+		}
+			
+		/* Get Flag Interlace */
+		snprintf(buffer, size, "%s/Flag.interlace", keyStealName(key));
+		if ( (subKey = ksLookupByName(settings, buffer, KDB_O_LOOP)) ) {
+			if (strtol(keyStealValue(subKey),NULL,10) != 0)
+				mode->ml_flags |= XF86CONF_INTERLACE;
+		}
+			
+		/* Get Flag hsync */
+		snprintf(buffer, size, "%s/Flag.hsync", keyStealName(key));
+		if ( (subKey = ksLookupByName(settings, buffer, KDB_O_LOOP)) ) {
+			switch (strtol(keyStealValue(subKey),NULL,10)) {
+				case -1:
+					mode->ml_flags |= XF86CONF_NHSYNC;
+					break;
+				case 1:
+					mode->ml_flags |= XF86CONF_PHSYNC;
+					break;
+			}
+		}
+			
+		/* Get Flag vsync */
+		snprintf(buffer, size, "%s/Flag.vsync", keyStealName(key));
+		if ( (subKey = ksLookupByName(settings, buffer, KDB_O_LOOP)) ) {
+			switch (strtol(keyStealValue(subKey),NULL,10)) {
+				case -1:
+					mode->ml_flags |= XF86CONF_NVSYNC;
+					break;
+				case 1:
+					mode->ml_flags |= XF86CONF_PVSYNC;
+					break;
+			}
+		}
+			
+		/* Get Flag Composite */
+		snprintf(buffer, size, "%s/Flag.composite", keyStealName(key));
+		if ( (subKey = ksLookupByName(settings, buffer, KDB_O_LOOP)) ) {
+			if (strtol(keyStealValue(subKey),NULL,10) != 0)
+				mode->ml_flags |= XF86CONF_CSYNC;
+		}
+			
+		/* Get Flag csync */
+		snprintf(buffer, size, "%s/Flag.csync", keyStealName(key));
+		if ( (subKey = ksLookupByName(settings, buffer, KDB_O_LOOP)) ) {
+			switch (strtol(keyStealValue(subKey),NULL,10)) {
+				case -1:
+					mode->ml_flags |= XF86CONF_NCSYNC;
+					break;
+				case 1:
+					mode->ml_flags |= XF86CONF_PCSYNC;
+					break;
+			}
+		}
+			
+		/* Get Flag DoubleScan */
+		snprintf(buffer, size, "%s/Flag.doublescan", keyStealName(key));
+		if ( (subKey = ksLookupByName(settings, buffer, KDB_O_LOOP)) ) {
+			if (strtol(keyStealValue(subKey),NULL,10) != 0)
+				mode->ml_flags |= XF86CONF_DBLSCAN;
+		}
+			
+		/* Get Flag BCast */
+		snprintf(buffer, size, "%s/Flag.bcast", keyStealName(key));
+		if ( (subKey = ksLookupByName(settings, buffer, KDB_O_LOOP)) ) {
+			if (strtol(keyStealValue(subKey),NULL,10) != 0)
+				mode->ml_flags |= XF86CONF_BCAST;
+		}
+		
+		/* Get HSkew */
+		snprintf(buffer, size, "%s/Flag.HSkew", keyStealName(key));
+		if ( (subKey = ksLookupByName(settings, buffer, KDB_O_LOOP)) ) {
+			mode->ml_hskew=strtol(keyStealValue(subKey),NULL,10);
+			mode->ml_flags |= XF86CONF_HSKEW;
+		}
+			
+		/* Get VScan */
+		snprintf(buffer, size, "%s/VScan", keyStealName(key));
+		if ( (subKey = ksLookupByName(settings, buffer, KDB_O_LOOP)) ) {
+			mode->ml_vscan=strtol(keyStealValue(subKey),NULL,10);
+			mode->ml_flags |= XF86CONF_VSCAN;
+		}
+			
+		/* Get Custom ???? */
+		snprintf(buffer, size, "%s/Custom", keyStealName(key));
+		if ( (subKey = ksLookupByName(settings, buffer, KDB_O_LOOP)) ) {
+			if (strtol(keyStealValue(subKey),NULL,10) != 0)
+				mode->ml_flags |= XF86CONF_CUSTOM;
+		}
+			
+		modes=((XF86ConfModeLinePtr)xf86addListItem((glp)modes,
+						(glp)mode));
+		
+		ksDel(settings);
+		
+	}
+
+	xf86conffree(buffer);
+	
+#ifdef DEBUG
+	printf ("Mode keys grabed\n");
+#endif
+	return modes;
+}
+
+
+/*
+ * Together with ksToModes(), is the Elektra version for
+ * the Monitor.c::xf86parseVerboseMode() function.
+ *
+ * Fetches keys under [rootKey]/Modes.
+ *
+ */
+XF86ConfModesPtr
+xf86getModes (KDBHandle handle, const char *rootKey)
+{
+	XF86ConfModesPtr modes=NULL; /* we'll return this */
+	KeySet *ksModes;
+	Key *kMode;
+	char *modesRoot;
+	size_t bufSize;
+	
+	modesRoot = xf86confmalloc((bufSize = strlen(rootKey)+50));
+
+	ksModes = ksNew();
+	snprintf(modesRoot, bufSize, "%s/Modes", rootKey);
+
+	kdbGetChildKeys(handle, modesRoot,ksModes,
+		KDB_O_DIR | KDB_O_NOVALUE | KDB_O_SORT);
+
+	while ((kMode=ksNext(ksModes))) {
+		size_t size;
+		KeySet *realModes;
+
+		/* ptr is declared here */
+		parsePrologue(XF86ConfModesPtr, XF86ConfModesRec)
+
+		/* Put a name in this new Mode */
+		size=keyGetBaseNameSize(kMode);
+		ptr->modes_identifier=xf86confmalloc(size);
+		keyGetBaseName(kMode,ptr->modes_identifier,size);
+
+		realModes = ksNew();
+
+		/* Get the real modelines below it */
+		keyGetName(kMode,modesRoot, bufSize);
+		kdbGetChildKeys(handle, modesRoot,realModes,
+			KDB_O_DIR | KDB_O_NOVALUE | KDB_O_SORT);
+
+		if (ksGetSize(realModes)) {
+			ptr->mon_modeline_lst=(XF86ConfModeLinePtr)
+				xf86addListItem ((glp) ptr->mon_modeline_lst,
+					(glp) ksToModes(handle, realModes));
+		}
+
+		ksDel(realModes);
+
+		if (modes)
+			modes=(XF86ConfModesPtr)xf86addListItem((glp)modes,(glp)ptr);
+		else modes=ptr;
+	}
+
+	ksDel(ksModes);
+
+	xf86conffree(modesRoot);
+
+	return modes;
+}
+
+
+/*
+ * Helper to generate a KeySet from a passed linked list of
+ * XF86ConfModeLinePtr struct plus a root key name. This function is called
+ * by xf86addModes() bellow.
+ * 
+ */
+void
+xf86addModelines(KeySet *ks, const char *root, XF86ConfModeLinePtr ptr)
+{
+	XF86ConfModeLinePtr mlptr;
+	Key *key;
+	size_t size;
+	char *buffer;
+	char *value;
+
+	size = 300;
+	buffer = xf86confmalloc(size);
+	value = xf86confmalloc(size);
+	
+	for (mlptr = ptr; mlptr; mlptr = mlptr->list.next) {
+		char moderoot[300];
+		snprintf(moderoot, sizeof(moderoot), "%s/%s",root,mlptr->ml_identifier);
+
+		snprintf(buffer, size, "%s/DotClock",moderoot);
+		snprintf(value, size, "%2.1f",mlptr->ml_clock / 1000.0);
+		key = keyNew(buffer, 
+				KEY_SWITCH_VALUE, value,
+				KEY_SWITCH_END);
+		ksAppend(ks,key);
+
+		snprintf(buffer, size, "%s/HTimings.hdisp",moderoot);
+		snprintf(value, size, "%d", mlptr->ml_hdisplay);
+		key = keyNew(buffer, 
+				KEY_SWITCH_VALUE, value,
+				KEY_SWITCH_END);
+		ksAppend(ks,key);
+		
+		snprintf(buffer, size, "%s/HTimings.hsyncstart",moderoot);
+		snprintf(value, size, "%d", mlptr->ml_hsyncstart);
+		key = keyNew(buffer, 
+				KEY_SWITCH_VALUE, value,
+				KEY_SWITCH_END);
+		ksAppend(ks,key);
+		
+		snprintf(buffer, size, "%s/HTimings.hsyncend",moderoot);
+		snprintf(value, size, "%d", mlptr->ml_hsyncend);
+		key = keyNew(buffer, 
+				KEY_SWITCH_VALUE, value,
+				KEY_SWITCH_END);
+		ksAppend(ks,key);
+		
+		snprintf(buffer, size, "%s/HTimings.htotal",moderoot);
+		snprintf(value, size, "%d", mlptr->ml_htotal);
+		key = keyNew(buffer, 
+				KEY_SWITCH_VALUE, value,
+				KEY_SWITCH_END);
+		ksAppend(ks,key);
+		
+		snprintf(buffer, size, "%s/VTimings.vdisp",moderoot);
+		snprintf(value, size, "%d", mlptr->ml_vdisplay);
+		key = keyNew(buffer, 
+				KEY_SWITCH_VALUE, value,
+				KEY_SWITCH_END);
+		ksAppend(ks,key);
+
+		snprintf(buffer, size, "%s/VTimings.vsyncstart",moderoot);
+		snprintf(value, size, "%d", mlptr->ml_vsyncstart);
+		key = keyNew(buffer, 
+				KEY_SWITCH_VALUE, value,
+				KEY_SWITCH_END);
+		ksAppend(ks,key);
+		
+		snprintf(buffer, size, "%s/VTimings.vsyncend",moderoot);
+		snprintf(value, size, "%d", mlptr->ml_vsyncend);
+		key = keyNew(buffer, 
+				KEY_SWITCH_VALUE, value,
+				KEY_SWITCH_END);
+		ksAppend(ks,key);
+			
+		snprintf(buffer, size, "%s/VTimings.vtotal",moderoot);
+		snprintf(value, size, "%d", mlptr->ml_vtotal);
+		key = keyNew(buffer, 
+				KEY_SWITCH_VALUE, value,
+				KEY_SWITCH_END);
+		ksAppend(ks,key);
+			
+			
+		if (mlptr->ml_flags & XF86CONF_PHSYNC) {
+			snprintf(buffer, size, "%s/Flag.hsync",moderoot);
+			key = keyNew(buffer, 
+					KEY_SWITCH_VALUE,	"1",
+					KEY_SWITCH_END);
+			ksAppend(ks,key);
+		}
+
+		if (mlptr->ml_flags & XF86CONF_NHSYNC) {
+			snprintf(buffer, size, "%s/Flag.hsync",moderoot);
+			key = keyNew(buffer,
+					KEY_SWITCH_VALUE,       "-1",
+					KEY_SWITCH_END);
+			ksAppend(ks,key);
+		}
+
+		if (mlptr->ml_flags & XF86CONF_PVSYNC) {
+			snprintf(buffer, size, "%s/Flag.vsync",moderoot);
+			key = keyNew(buffer,
+					KEY_SWITCH_VALUE,       "1",
+					KEY_SWITCH_END);
+			ksAppend(ks,key);
+		}
+
+		if (mlptr->ml_flags & XF86CONF_NVSYNC) {
+			snprintf(buffer, size, "%s/Flag.vsync",moderoot);
+			key = keyNew(buffer,
+					KEY_SWITCH_VALUE,       "-1",
+					KEY_SWITCH_END);
+			ksAppend(ks,key);
+		}
+
+		if (mlptr->ml_flags & XF86CONF_INTERLACE) {
+			snprintf(buffer, size, "%s/Flag.interlace",moderoot);
+			key = keyNew(buffer,
+					KEY_SWITCH_VALUE,       "1",
+					KEY_SWITCH_END);
+			ksAppend(ks,key);
+		}
+
+		if (mlptr->ml_flags & XF86CONF_CSYNC) {
+			snprintf(buffer, size, "%s/Flag.composite",moderoot);
+			key = keyNew(buffer,
+					KEY_SWITCH_VALUE,       "1",
+					KEY_SWITCH_END);
+			ksAppend(ks,key);
+		}
+
+		if (mlptr->ml_flags & XF86CONF_PCSYNC) {
+			snprintf(buffer, size, "%s/Flag.csync",moderoot);
+			key = keyNew(buffer,
+					KEY_SWITCH_VALUE,       "1",
+					KEY_SWITCH_END);
+			ksAppend(ks,key);
+		}
+
+		if (mlptr->ml_flags & XF86CONF_NCSYNC) {
+			snprintf(buffer, size, "%s/Flag.csync",moderoot);
+			key = keyNew(buffer,
+					KEY_SWITCH_VALUE,       "-1",
+					KEY_SWITCH_END);
+			ksAppend(ks,key);
+		}
+
+		if (mlptr->ml_flags & XF86CONF_DBLSCAN) {
+			snprintf(buffer, size, "%s/Flag.doublescan",moderoot);
+			key = keyNew(buffer,
+					KEY_SWITCH_VALUE,       "1",
+					KEY_SWITCH_END);
+			ksAppend(ks,key);
+		}
+
+		if (mlptr->ml_flags & XF86CONF_HSKEW) {
+			snprintf(buffer, size, "%s/HSkew",moderoot);
+			snprintf(value, size, "%d", mlptr->ml_hskew);
+			key = keyNew(buffer, 
+				KEY_SWITCH_VALUE, value,
+				KEY_SWITCH_END);
+			ksAppend(ks,key);
+		}
+
+		if (mlptr->ml_flags & XF86CONF_BCAST) {
+			snprintf(buffer, size, "%s/Flag.bcast",moderoot);
+			key = keyNew(buffer,
+					KEY_SWITCH_VALUE,       "1",
+					KEY_SWITCH_END);
+			ksAppend(ks,key);
+		}
+
+		if (mlptr->ml_flags & XF86CONF_VSCAN) {
+			snprintf(buffer, size, "%s/Flag.vscan",moderoot);
+			key = keyNew(buffer,
+					KEY_SWITCH_VALUE,       "1",
+					KEY_SWITCH_END);
+			ksAppend(ks,key);
+		}
+	} /* end "for" loop: mode processing */
+
+	xf86conffree(value);
+	xf86conffree(buffer);
+}
+
+
+/*
+ * Elektra version of Monitor.c::xf86printModesSection()
+ *
+ * Generates a KeySet from a passed linked list of XF86ConfModesPtr struct
+ * plus a root key name. It wraps a call to xf86addModelines() to generate
+ * the Modelines.
+ * 
+ */
+void
+xf86addModes(KeySet *ks, const char *root, XF86ConfModesPtr ptr)
+{
+	char modeRoot[300];
+	int modeIndex=0;
+	
+	
+	while (ptr) {
+		if (! ptr->modes_identifier) {
+			++modeIndex;
+			snprintf(modeRoot, sizeof(modeRoot), "%s/Modes/mode%02d",root,modeIndex);
+		} else snprintf(modeRoot, sizeof(modeRoot), "%s/Modes/%s",root,ptr->modes_identifier);
+		
+		xf86addModelines(ks, modeRoot, ptr->mon_modeline_lst);
+		ptr=ptr->list.next;
+	}
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+#undef CLEANUP
+#define CLEANUP xf86freeMonitorList
+
+
+/*
+ * Elektra version for the Monitor.c::xf86parseMonitorSection() function
+ *
+ * Fetch keys under [rootKey]/Monitors
+ * All monitors are there.
+ *
+ * TODO: check int and float conversions
+ *
+ */
+XF86ConfMonitorPtr
+xf86getMonitor (KDBHandle handle, const char *rootKey)
+{
+	KeySet *monitors;
+	Key *current;
+	char *localRootKey, *buffer;
+	size_t size;
+
+	localRootKey = xf86confmalloc((size=strlen(rootKey)+50));
+
+	XF86ConfMonitorPtr ptr = NULL;
+
+	snprintf(localRootKey, size, "%s/Monitors", rootKey);
+
+	size=100;
+	buffer=xf86confmalloc(size);
+	
+	monitors = ksNew();
+	/*
+	 * There should be only folders right under Monitors/.
+	 * So we are interested only in the skeleton.
+	 */
+	kdbGetChildKeys(handle, localRootKey, monitors,
+		KDB_O_DIR | KDB_O_NOVALUE | KDB_O_SORT);
+	xf86conffree(localRootKey);
+
+	if (ksGetSize(monitors) == 0) {
+		ksDel(monitors);
+		return NULL;
+	}
+
+	ksRewind(monitors);
+	while ((current=ksNext(monitors))) {
+		/* each entry we'll process is a Monitor */
+		XF86ConfMonitorPtr monitor;
+		KeySet *settings;
+		Key *genericKey;
+		size_t identSize,dataSize;
+
+		monitor=xf86confcalloc(1,sizeof(XF86ConfMonitorRec));
+		memset(monitor,0,sizeof(XF86ConfMonitorRec));
+
+		identSize=keyGetBaseNameSize(current);
+		monitor->mon_identifier=xf86confmalloc(identSize);
+		if (monitor->mon_identifier)
+			keyGetBaseName(current,monitor->mon_identifier,identSize);
+		settings = ksNew();
+		kdbGetChildKeys(handle, keyStealName(current), settings, 0);
+		
+		/* Get Vendor */
+		snprintf(buffer, size, "%s/VendorName", keyStealName(current));
+		if ((genericKey = ksLookupByName(settings, buffer, KDB_O_LOOP))) {
+			dataSize=keyGetDataSize(genericKey);
+			monitor->mon_vendor=xf86confmalloc(dataSize);
+			keyGetString(genericKey,monitor->mon_vendor,dataSize);
+		}
+
+		/* Get ModelName */
+		snprintf(buffer, size, "%s/ModelName", keyStealName(current));
+		if ((genericKey = ksLookupByName(settings, buffer, KDB_O_LOOP))) {
+			dataSize=keyGetDataSize(genericKey);
+			monitor->mon_modelname=xf86confmalloc(dataSize);
+			keyGetString(genericKey,monitor->mon_modelname,dataSize);
+		}
+		
+		/* Get DisplaySizeWidth */
+		snprintf(buffer, size, "%s/DisplaySize.width", keyStealName(current));
+		if ((genericKey = ksLookupByName(settings, buffer, KDB_O_LOOP))) {
+			monitor->mon_width=strtod(keyStealValue(genericKey), NULL);
+		}
+
+		/* Get DisplaySizeHeight */
+		snprintf(buffer, size, "%s/DisplaySize.height", keyStealName(current));
+		if ((genericKey = ksLookupByName(settings, buffer, KDB_O_LOOP))) {
+			monitor->mon_height=strtod(keyStealValue(genericKey), NULL);
+		}
+
+		/* Get UseModes, a CSV of mode names */
+		snprintf(buffer, size, "%s/UseModes", keyStealName(current));
+		if ((genericKey = ksLookupByName(settings, buffer, KDB_O_LOOP))) {
+			char *modes, *cursor, *cursorEnd;
+
+			dataSize=keyGetDataSize(genericKey);
+			modes=xf86confmalloc(dataSize);
+			keyGetString(genericKey,modes,dataSize);
+
+			cursor=modes;
+			do {
+				XF86ConfModesLinkPtr mptr;
+
+				cursorEnd=index(cursor,',');
+				if (cursorEnd) {
+					*cursorEnd=0;
+					cursorEnd++;
+				}
+
+				mptr = xf86confcalloc (1, sizeof (XF86ConfModesLinkRec));
+				mptr->list.next = NULL;
+				mptr->ml_modes_str = xf86confmalloc(strlen(cursor)+1);
+				strcpy(mptr->ml_modes_str,cursor);
+				mptr->ml_modes = NULL;
+
+				monitor->mon_modes_sect_lst = (XF86ConfModesLinkPtr)
+				xf86addListItem((GenericListPtr)monitor->mon_modes_sect_lst,
+					    (GenericListPtr)mptr);
+
+				cursor=cursorEnd;
+			} while (cursor);
+
+			xf86conffree(modes);
+		}
+
+		/* Get Gamma */
+		snprintf(buffer, size, "%s/Gamma", keyStealName(current));
+		if ((genericKey = ksLookupByName(settings, buffer, KDB_O_LOOP))) {
+			monitor->mon_gamma_green=monitor->mon_gamma_blue=
+			monitor->mon_gamma_red=strtod(keyStealValue(genericKey), NULL);
+		}
+
+		/* Get GammaRed */
+		snprintf(buffer, size, "%s/Gamma.red", keyStealName(current));
+		if ((genericKey = ksLookupByName(settings, buffer, KDB_O_LOOP))) {
+			monitor->mon_gamma_red=strtod(keyStealValue(genericKey), NULL);
+		}
+
+		/* Get GammaGreen */
+		snprintf(buffer, size, "%s/Gamma.green", keyStealName(current));
+		if ((genericKey = ksLookupByName(settings, buffer, KDB_O_LOOP))) {
+			monitor->mon_gamma_green=strtod(keyStealValue(genericKey), NULL);
+		}
+
+		/* Get GammaBlue */
+		snprintf(buffer, size, "%s/Gamma.blue", keyStealName(current));
+		if ((genericKey = ksLookupByName(settings, buffer, KDB_O_LOOP))) {
+			monitor->mon_gamma_blue=strtod(keyStealValue(genericKey), NULL);
+		}
+
+		/* Get HorizSync, a CSV of ranges */
+		snprintf(buffer, size, "%s/HorizSync", keyStealName(current));
+		if ((genericKey = ksLookupByName(settings, buffer, KDB_O_LOOP))) {
+			/* parse a string like "num1-num2,num3-num4,num5-num6" */
+
+			char *csv, *cursor, *cursorEnd;
+
+			dataSize=keyGetDataSize(genericKey);
+			csv=xf86confmalloc(dataSize);
+			keyGetString(genericKey,csv,dataSize);
+
+			cursor=csv;
+			do {
+				char *dash=cursor;
+
+				cursorEnd=index(cursor,',');
+				if (cursorEnd) {
+					*cursorEnd=0;
+					cursorEnd++;
+				}
+
+				dash=index(cursor,'-');
+				if (dash) {
+					*dash=0;
+					dash++;
+				}
+
+				monitor->mon_hsync[monitor->mon_n_hsync].hi=
+					monitor->mon_hsync[monitor->mon_n_hsync].lo=
+					strtod(cursor, NULL);
+
+				if (dash) {
+					monitor->mon_hsync[monitor->mon_n_hsync].hi=
+					strtod(dash, NULL);
+
+					if (monitor->mon_hsync[monitor->mon_n_hsync].hi<
+						monitor->mon_hsync[monitor->mon_n_hsync].lo) {
+						Error (HORIZSYNC_MSG, NULL);
+
+						monitor->mon_hsync[monitor->mon_n_hsync].hi=
+						monitor->mon_hsync[monitor->mon_n_hsync].lo;
+					}
+				}
+
+				cursor=cursorEnd;
+				if (monitor->mon_n_hsync >= CONF_MAX_HSYNC) {
+					Error ("Sorry. Too many horizontal sync intervals.",
+						NULL);
+					cursor=NULL;
+				} else monitor->mon_n_hsync++;
+			} while (cursor);
+			
+			xf86conffree(csv);
+		}
+				
+		/* Get VertRefresh, a CSV of ranges */
+		snprintf(buffer, size, "%s/VertRefresh", keyStealName(current));
+		if ((genericKey = ksLookupByName(settings, buffer, KDB_O_LOOP))) {
+			/* parse a string like "num1-num2,num3-num4,num5-num6" */
+		
+			char *csv, *cursor, *cursorEnd;
+
+			dataSize=keyGetDataSize(genericKey);
+			csv=xf86confmalloc(dataSize);
+			keyGetString(genericKey,csv,dataSize);
+			
+			cursor=csv;
+			do {
+				char *dash=cursor;
+
+				cursorEnd=index(cursor,',');
+				if (cursorEnd) {
+					*cursorEnd=0;
+					cursorEnd++;
+				}
+
+				dash=index(cursor,'-');
+				if (dash) {
+					*dash=0;
+					dash++;
+				}
+
+				monitor->mon_vrefresh[monitor->mon_n_vrefresh].hi=
+					monitor->mon_vrefresh[monitor->mon_n_vrefresh].lo=
+					strtod(cursor, NULL);
+
+				if (dash) {
+					monitor->mon_vrefresh[monitor->mon_n_vrefresh].hi=
+					strtod(dash, NULL);
+				
+					if (monitor->mon_vrefresh[monitor->mon_n_vrefresh].hi<
+						monitor->mon_vrefresh[monitor->mon_n_vrefresh].lo) {
+						Error (VERTREFRESH_MSG, NULL);
+						
+						monitor->mon_vrefresh[monitor->mon_n_vrefresh].hi=
+						monitor->mon_vrefresh[monitor->mon_n_vrefresh].lo;
+					}
+				}
+			
+				cursor=cursorEnd;
+				if (monitor->mon_n_vrefresh >= CONF_MAX_VREFRESH) {
+					Error ("Sorry. Too many vertical refresh intervals.",
+						NULL);
+					cursor=NULL;
+				} else monitor->mon_n_vrefresh++;
+			} while (cursor);
+			
+			xf86conffree(csv);
+		}
+		ksClose(settings);
+		
+		/* Get monitor Modes */
+		snprintf(buffer, size, "%s/Modes", keyStealName(current));
+		
+		ksInit(settings);
+		kdbGetChildKeys(handle, buffer,settings,
+			KDB_O_DIR | KDB_O_NOVALUE | KDB_O_SORT);
+		if (ksGetSize(settings))
+			monitor->mon_modeline_lst=ksToModes(handle, settings);
+		ksClose(settings);
+
+		/* Now get this monitor's options */
+		snprintf(buffer, size, "%s/Options", keyStealName(current));
+
+		ksInit(settings);
+		kdbGetChildKeys(handle, buffer,settings,KDB_O_SORT);
+		if (ksGetSize(settings))
+			monitor->mon_option_lst=ksToOptions(settings);
+
+		/* Finished with this device. Now add to our devices list */
+		if (ptr) ptr=(XF86ConfMonitorPtr)
+			xf86addListItem ((glp) ptr, (glp) monitor);
+		else  ptr=monitor;
+
+		ksDel(settings);
+	}
+
+	ksDel(monitors);
+	xf86conffree(buffer);
+
+#ifdef DEBUG
+	printf ("Monitor keys grabed\n");
+#endif
+
+	return ptr;
+}
+
+
+/*
+ * Elektra version of Monitor.c::xf86printMonitorSection()
+ *
+ * Generates a KeySet from a passed linked list of XF86ConfMonitorPtr struct
+ * plus a root key name.
+ * 
+ */
+void
+xf86addMonitor (KeySet *ks, const char *root, XF86ConfMonitorPtr ptr) {
+	char *buffer;
+	char *value;
+	char *devroot;
+	size_t size;
+	Key *key;
+	int i;
+	XF86ConfModesLinkPtr mptr;
+
+	size = 300;
+	devroot = xf86confmalloc(size);
+	buffer = xf86confmalloc(size);
+	value = xf86confmalloc(size);
+
+	while (ptr) {
+		snprintf(devroot, size, "%s/Monitors/%s",root,ptr->mon_identifier);
+
+		if (ptr->mon_vendor) {
+			snprintf(buffer, size, "%s/VendorName",devroot);
+			key = keyNew(buffer,
+					KEY_SWITCH_VALUE, ptr->mon_vendor,
+					KEY_SWITCH_END);
+			ksAppend(ks,key);
+		}
+
+		if (ptr->mon_modelname) {
+			snprintf(buffer, size, "%s/ModelName",devroot);
+			key = keyNew(buffer,
+					KEY_SWITCH_VALUE, ptr->mon_modelname,
+					KEY_SWITCH_END);
+			ksAppend(ks,key);
+		}
+
+		if ((mptr = ptr->mon_modes_sect_lst)) {
+			snprintf(buffer, size, "%s/UseModes",devroot);
+			key = keyNew(buffer, KEY_SWITCH_END);
+
+			buffer[0]=0;
+			while (mptr) {
+				if (buffer[0] != 0) strcat(buffer,",");
+				strcat (buffer,mptr->ml_modes_str);
+				mptr = mptr->list.next;
+			}
+			
+			keySetString(key,buffer);
+			keySetComment(key,
+				"A comma separated list of modes, without spaces");
+			ksAppend(ks,key);
+		}
+			
+		if (ptr->mon_width) {
+			snprintf(buffer, size, "%s/DisplaySize.width",devroot);
+			snprintf(value, size, "%d", ptr->mon_width);
+			key = keyNew(buffer, 
+					KEY_SWITCH_VALUE, value,
+					KEY_SWITCH_END);
+			ksAppend(ks,key);
+			
+			snprintf(buffer, size, "%s/DisplaySize.height",devroot);
+			snprintf(value, size, "%d",ptr->mon_height);
+			key = keyNew(buffer, 
+					KEY_SWITCH_VALUE, value,
+					KEY_SWITCH_END);
+			ksAppend(ks,key);
+		}
+
+		if (ptr->mon_n_hsync > 0) {
+			snprintf(buffer, size, "%s/HorizSync",devroot);
+						
+			value[0]=0;
+			for (i = 0; i < ptr->mon_n_hsync; i++) {
+				char range[50];
+
+				if (value[0])
+					strncat(value,", ", size-1);
+
+				snprintf(range, sizeof(range), "%2.1f - %2.1f",
+					 ptr->mon_hsync[i].lo,
+					 ptr->mon_hsync[i].hi);
+
+				strncat(value,range, size-1);
+			}
+
+			key = keyNew(buffer, 
+					KEY_SWITCH_VALUE, value,
+					KEY_SWITCH_COMMENT, "Ex: 30.0-61.0, 70-83.2",
+					KEY_SWITCH_END);
+			ksAppend(ks,key);
+		}
+
+		if (ptr->mon_n_vrefresh > 0) {
+			snprintf(buffer, size, "%s/VertRefresh",devroot);
+
+			value[0]=0;
+			for (i = 0; i < ptr->mon_n_vrefresh; i++) {
+				char range[50];
+				
+				if (value[0])
+					strncat(value,", ", size-1);
+				snprintf(range, sizeof(range), "%2.1f - %2.1f",
+					 ptr->mon_vrefresh[i].lo,
+					 ptr->mon_vrefresh[i].hi);
+
+				strncat(value,range, size-1);
+			}
+			
+			key = keyNew(buffer, 
+					KEY_SWITCH_VALUE, value,
+					KEY_SWITCH_COMMENT, "Ex: 30.0-61.0, 70-83.2",
+					KEY_SWITCH_END);
+			ksAppend(ks,key);
+		}
+
+		if (ptr->mon_gamma_red) {
+			if (ptr->mon_gamma_red == ptr->mon_gamma_green
+				&& ptr->mon_gamma_red == ptr->mon_gamma_blue) {
+				snprintf(buffer, size, "%s/Gamme",devroot);
+				snprintf(value, size, "%.4g",ptr->mon_gamma_red);
+				key = keyNew(buffer, 
+					KEY_SWITCH_VALUE, value,
+					KEY_SWITCH_END);
+				ksAppend(ks,key);
+			} else {
+				snprintf(buffer, size, "%s/Gamma.red",devroot);
+				snprintf(value, size, "%.4g",ptr->mon_gamma_red);
+				key = keyNew(buffer, 
+					KEY_SWITCH_VALUE, value,
+					KEY_SWITCH_END);
+				ksAppend(ks,key);
+				
+				snprintf(buffer, size, "%s/Gamma.green",devroot);
+				snprintf(value, size, "%.4g",ptr->mon_gamma_green);
+				key = keyNew(buffer, 
+					KEY_SWITCH_VALUE, value,
+					KEY_SWITCH_END);
+				ksAppend(ks,key);
+				
+				snprintf(buffer, size, "%s/%s",devroot,"Gamma.blue");
+				snprintf(value, size, "%.4g",ptr->mon_gamma_blue);
+				key = keyNew(buffer, 
+					KEY_SWITCH_VALUE, value,
+					KEY_SWITCH_END);
+				ksAppend(ks,key);
+			}
+		}
+		
+		
+		snprintf(buffer, size, "%s/Modes",devroot);
+		xf86addModelines(ks,buffer,ptr->mon_modeline_lst);
+		
+		snprintf(buffer, size, "%s/Options",devroot);
+		xf86addOptions(ks, buffer, ptr->mon_option_lst);
+		ptr = ptr->list.next;
+	} /* end "while" loop: single monitor processing */
+
+	xf86conffree(value);
+	xf86conffree(buffer);
+	xf86conffree(devroot);
+}
+
+
+
+
+
+
+
+
+
+#undef CLEANUP
+#define CLEANUP xf86freeDRI
+
+
+/*
+ * Elektra version for the DRI.c::xf86parseDRISection() function
+ *
+ * Fetch keys under [rootKey]/DRI .
+ *
+ */
+XF86ConfDRIPtr
+xf86getDRI (KDBHandle handle, const char *rootKey)
+{
+	KeySet *settings;
+	Key *key;
+	char *buffer;
+	char *parent;
+	size_t size, bufSize;
+	int hasDRI=0;
+
+	bufSize = 300;
+	buffer = xf86confmalloc(bufSize);
+	parent = xf86confmalloc(bufSize);
+
+	parsePrologue (XF86ConfDRIPtr, XF86ConfDRIRec);
+
+	ptr->dri_group=-1;
+
+	snprintf(parent, bufSize, "%s/DRI", rootKey);
+
+	settings = ksNew();
+	kdbGetChildKeys(handle, parent, settings, 0);
+
+	snprintf(buffer, bufSize, "%s/Group", parent);
+	if ( (key = ksLookupByName(settings, buffer, KDB_O_LOOP)) ) {
+		long group;
+		char *endptr;
+
+		group=strtol(keyStealValue(key),&endptr,10);
+		if (endptr!=buffer) ptr->dri_group=group;
+		else { /* not a number */
+			size=keyGetDataSize(key);
+			ptr->dri_group_name=xf86confmalloc(size);
+			keyGetString(key, ptr->dri_group_name, size);
+		}
+		hasDRI=1;
+	}
+
+	snprintf(buffer, bufSize, "%s/Mode", parent);
+	if ( (key = ksLookupByName(settings, buffer, KDB_O_LOOP)) ) {
+		ptr->dri_mode=strtol(keyStealValue(key),NULL,0);
+		hasDRI=1;
+	}
+
+
+	snprintf(buffer, bufSize, "%s/Buffers", parent);
+	if ( (key = ksLookupByName(settings, buffer, KDB_O_LOOP)) ) {
+		char *cursor,*numEnd,*cursorEnd;
+
+		size=keyGetDataSize(key);
+		keyGetString(key,buffer,bufSize);
+
+		cursor=buffer;
+		do {
+			XF86ConfBuffersPtr buf;
+			buf=xf86confmalloc(sizeof(XF86ConfBuffersRec));
+			memset(buf,0,sizeof(XF86ConfBuffersRec));
+
+			cursorEnd=index(cursor,',');
+			if (cursorEnd) {
+				*cursorEnd=0;
+				++cursorEnd;
+			}
+
+			buf->buf_count=strtol(cursor,&numEnd,10);
+			cursor=numEnd;
+			buf->buf_size=strtol(cursor,&numEnd,10);
+			cursor=numEnd;
+			
+			if ((size=strlen(cursor))) {
+				/* seems we have flags */
+				buf->buf_flags=xf86confmalloc(size+1);
+				strcpy(buf->buf_flags,cursor);
+			}
+			
+			/* Add this buffer to the list */
+			ptr->dri_buffers_lst=(XF86ConfBuffersPtr)
+				xf86addListItem((glp)ptr->dri_buffers_lst,(glp)buf);
+			cursor=cursorEnd;
+		} while (cursor);
+		hasDRI=1;
+	}
+	ksDel(settings);
+
+	if (hasDRI == 0) {
+		CLEANUP(ptr);
+		ptr=NULL;
+	}
+	
+#ifdef DEBUG
+	ErrorF("DRI keys grabed\n");
+#endif
+
+	xf86conffree(parent);
+	xf86conffree(buffer);
+
+	return ptr;
+}
+
+
+
+/*
+ * Elektra version of DRI.c::xf86printDRISection()
+ *
+ * Generates a KeySet from a passed linked list of XF86ConfDRIPtr struct
+ * plus a root key name.
+ * 
+ */
+void
+xf86addDRI(KeySet *ks, const char *root, XF86ConfDRIPtr ptr)
+{
+	XF86ConfBuffersPtr bufs=0;
+	char *buffer, *value;
+	size_t size;
+	Key *key;
+
+	if (ptr == NULL) return;
+
+	size = 300;
+	buffer = xf86confmalloc(size);
+	value = xf86confmalloc(size);
+
+	if (ptr->dri_group_name) {
+		snprintf(buffer, size, "%s/DRI/Group",root);
+		key = keyNew(buffer, 
+				KEY_SWITCH_VALUE, ptr->dri_group_name,
+				KEY_SWITCH_END);
+		ksAppend(ks,key);
+	} else if (ptr->dri_group >= 0) {
+		snprintf(buffer, size, "%s/DRI/Group",root);
+		snprintf(value, size, "%d", ptr->dri_group);
+		key = keyNew(buffer, 
+				KEY_SWITCH_VALUE, value,
+				KEY_SWITCH_END);
+		ksAppend(ks,key);
+	}
+
+	if (ptr->dri_mode) {
+		snprintf(buffer, size, "%s/DRI/Mode",root);
+		snprintf(value, size, "0%o",ptr->dri_mode);
+		key = keyNew(buffer,
+				KEY_SWITCH_VALUE, value,
+				KEY_SWITCH_END);		
+		ksAppend(ks,key);
+	}
+
+	if ( (bufs = ptr->dri_buffers_lst) ) {
+		snprintf(buffer, size, "%s/DRI/Buffers",root);
+		value[0]=0;
+		for (bufs = ptr->dri_buffers_lst; bufs; bufs = bufs->list.next) {
+			char bufbuf[100];
+			
+			if (*value)
+				strncat(value,",", size-1);
+		
+			snprintf (bufbuf, sizeof(bufbuf), "%d %d", bufs->buf_count, bufs->buf_size);
+			strncat(value, bufbuf, size-1);
+			
+			if (bufs->buf_flags) {
+				snprintf (bufbuf, sizeof(bufbuf), " %s", bufs->buf_flags);
+				strncat(value, bufbuf, size-1);
+			}
+		}
+
+		key = keyNew(buffer,
+				KEY_SWITCH_VALUE, value,
+				KEY_SWITCH_END);
+		ksAppend(ks,key);
+	}
+
+	xf86conffree(value);
+	xf86conffree(buffer);
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+/*
+ * Elektra version for the Screen.c::xf86parseDisplaySubSection() function.
+ *
+ * Helper wrapped by xf86getScreen() that generates a
+ * XF86ConfDisplayPtr struct from a KeySet.
+ *
+ * TODO: check int and float conversions
+ *
+ */
+XF86ConfDisplayPtr
+ksToDisplays(KDBHandle handle, KeySet *ks)
+{
+	Key *key;
+	XF86ConfDisplayPtr ptr;
+	XF86ConfDisplayPtr displays=NULL; /* we'll return this */
+
+	ksRewind(ks);
+	while ((key=ksNext(ks))) {
+		KeySet *settings;
+		KeySet *optionKeys;
+		char *options=NULL;
+		Key *subKey;
+		size_t dataSize, size;
+		char *buffer; /* a big enough buffer */
+
+		/* initialize an object */
+		ptr=xf86confcalloc(1,sizeof(XF86ConfDisplayRec));
+		memset(ptr,0,sizeof(XF86ConfDisplayRec));
+
+		ptr->disp_black.red =
+		ptr->disp_black.green =
+		ptr->disp_black.blue =
+		ptr->disp_white.red =
+		ptr->disp_white.green =
+		ptr->disp_white.blue =
+		ptr->disp_frameX0 =
+		ptr->disp_frameY0 = -1;
+
+		buffer = xf86confmalloc((size = 100));
+				
+		settings = ksNew();
+		kdbGetKeyChildKeys(handle, key, settings, 0);
+		
+		/* Get Viewport.x */
+		snprintf(buffer, size, "%s/Viewport.x", keyStealName(key));
+		if ( (subKey = ksLookupByName(settings, buffer, KDB_O_LOOP)) ) {
+			ptr->disp_frameX0=strtol(keyStealValue(subKey),NULL,10);
+		}
+
+		/* Get Viewport.y */
+		snprintf(buffer, size, "%s/Viewport.y", keyStealName(key));
+		if ( (subKey = ksLookupByName(settings, buffer, KDB_O_LOOP)) ) {
+			ptr->disp_frameY0=strtol(keyStealValue(subKey),NULL,10);
+		}
+
+		/* Get Virtual.x */
+		snprintf(buffer, size, "%s/Virtual.x", keyStealName(key));
+		if ( (subKey = ksLookupByName(settings, buffer, KDB_O_LOOP)) ) {
+			ptr->disp_virtualX=strtol(keyStealValue(subKey),NULL,10);
+		}
+
+		/* Get Virtual.y */
+		snprintf(buffer, size, "%s/Virtual.y", keyStealName(key));
+		if ( (subKey = ksLookupByName(settings, buffer, KDB_O_LOOP)) ) {
+			ptr->disp_virtualY=strtol(keyStealValue(subKey),NULL,10);
+		}
+
+		/* Get Depth */
+		snprintf(buffer, size, "%s/Depth", keyStealName(key));
+		if ( (subKey = ksLookupByName(settings, buffer, KDB_O_LOOP)) ) {
+			ptr->disp_depth=strtol(keyStealValue(subKey),NULL,10);
+		}
+
+		/* Get FbBpp */
+		snprintf(buffer, size, "%s/FbBPP", keyStealName(key));
+		if ( (subKey = ksLookupByName(settings, buffer, KDB_O_LOOP)) ) {
+			ptr->disp_bpp=strtol(keyStealValue(subKey),NULL,10);
+		}
+		
+		/* Get Visual */
+		snprintf(buffer, size, "%s/Visual", keyStealName(key));
+		if ( (subKey = ksLookupByName(settings, buffer, KDB_O_LOOP)) ) {
+			dataSize=keyGetDataSize(subKey);
+			ptr->disp_visual=xf86confmalloc(dataSize);
+			keyGetString(subKey,ptr->disp_visual,dataSize);
+		}
+
+		/* Get Weight.red */
+		snprintf(buffer, size, "%s/Weight.red", keyStealName(key));
+		if ( (subKey = ksLookupByName(settings, buffer, KDB_O_LOOP)) ) {
+			ptr->disp_weight.red=strtol(keyStealValue(subKey),NULL,10);
+		}
+
+		/* Get Weight.green */
+		snprintf(buffer, size, "%s/Weight.green", keyStealName(key));
+		if ( (subKey = ksLookupByName(settings, buffer, KDB_O_LOOP)) ) {
+			ptr->disp_weight.green=strtol(keyStealValue(subKey),NULL,10);
+		}
+
+		/* Get Weight.blue */
+		snprintf(buffer, size, "%s/Weight.blue", keyStealName(key));
+		if ( (subKey = ksLookupByName(settings, buffer, KDB_O_LOOP)) ) {
+			ptr->disp_weight.blue=strtol(keyStealValue(subKey),NULL,10);
+		}
+
+		/* Get Black.red */
+		snprintf(buffer, size, "%s/Blacks.red", keyStealName(key));
+		if ( (subKey = ksLookupByName(settings, buffer, KDB_O_LOOP)) ) {
+			ptr->disp_black.red=strtol(keyStealValue(subKey),NULL,10);
+		}
+
+		/* Get Black.green */
+		snprintf(buffer, size, "%s/Black.green", keyStealName(key));
+		if ( (subKey = ksLookupByName(settings, buffer, KDB_O_LOOP)) ) {
+			ptr->disp_black.green=strtol(keyStealValue(subKey),NULL,10);
+		}
+		
+		/* Get Black.blue */
+		snprintf(buffer, size, "%s/Black.blue", keyStealName(key));
+		if ( (subKey = ksLookupByName(settings, buffer, KDB_O_LOOP)) ) {
+			ptr->disp_black.blue=strtol(keyStealValue(subKey),NULL,10);
+		}
+
+		/* Get White.red */
+		snprintf(buffer, size, "%s/white.red", keyStealName(key));
+		if ( (subKey = ksLookupByName(settings, buffer, KDB_O_LOOP)) ) {
+			ptr->disp_white.red=strtol(keyStealValue(subKey),NULL,10);
+		}
+
+		/* Get White.green */
+		snprintf(buffer, size, "%s/white.green", keyStealName(key));
+		if ( (subKey = ksLookupByName(settings, buffer, KDB_O_LOOP)) ) {
+			ptr->disp_white.green=strtol(keyStealValue(subKey),NULL,10);
+		}
+
+		/* Get White.blue */
+		snprintf(buffer, size, "%s/white.blue", keyStealName(key));
+		if ( (subKey = ksLookupByName(settings, buffer, KDB_O_LOOP)) ) {
+			ptr->disp_white.blue=strtol(keyStealValue(subKey),NULL,10);
+		}
+
+		/* Get Modes */
+		snprintf(buffer, size, "%s/Modes", keyStealName(key));
+		if ( (subKey = ksLookupByName(settings, buffer, KDB_O_LOOP)) ) {
+			char *cursor,*cursorEnd;
+
+			keyGetString(subKey,buffer,sizeof(buffer));
+
+			cursor=buffer;
+			do {
+				XF86ModePtr mptr;
+
+				cursorEnd=index(cursor,',');
+				if (cursorEnd) {
+					*cursorEnd=0;
+					++cursorEnd;
+				}
+
+				mptr=xf86confmalloc(sizeof (XF86ModeRec));
+				mptr->mode_name=xf86confmalloc(strlen(cursor)+1);
+				strcpy(mptr->mode_name,cursor);
+				mptr->list.next=NULL;
+
+				ptr->disp_mode_lst = (XF86ModePtr)
+					xf86addListItem ((glp) ptr->disp_mode_lst, (glp) mptr);
+
+				cursor=cursorEnd;
+			} while (cursor);
+		}
+
+		/* Now get this display's options */
+		dataSize=keyGetFullNameSize(key)+30;
+		options=xf86confmalloc(dataSize);
+		keyGetFullName(key,options,dataSize);
+		strncat(options,"/Options", dataSize-1);
+			
+		optionKeys = ksNew();
+		kdbGetChildKeys(handle, options,optionKeys,KDB_O_SORT);
+		if (ksGetSize(optionKeys))
+			ptr->disp_option_lst=ksToOptions(optionKeys);
+		xf86conffree (options);
+		ksDel(optionKeys);
+		
+		/* Finished with this display. Now add to our displays list */
+		if (displays) ptr=(XF86ConfDisplayPtr)
+			xf86addListItem ((glp) displays, (glp) ptr);
+		else  displays=ptr;
+
+		ksDel(settings);
+		xf86conffree(buffer);
+
+	}
+#ifdef DEBUG
+	printf ("Display subsection keys grabed\n");
+#endif
+
+	return displays;
+}
+
+
+/*
+ * Elektra version for the Screen.c::xf86parseScreenSection() function.
+ *
+ * Fetch keys under [rootKey]/Screens .
+ *
+ */
+XF86ConfScreenPtr
+xf86getScreen (KDBHandle handle, const char *rootKey)
+{
+	XF86ConfScreenPtr ptr=NULL; /* we'll return this */
+	KeySet *screens;
+	Key *key;
+	size_t	size;
+	char *screensRoot;
+
+	screens = ksNew();
+
+	screensRoot = xf86confmalloc((size = 300));
+	strncpy(screensRoot,rootKey, size-1);
+	strncat(screensRoot,"/Screens", size-1);
+
+	kdbGetChildKeys(handle, screensRoot,screens,
+		KDB_O_DIR | KDB_O_NOVALUE | KDB_O_SORT);
+	xf86conffree(screensRoot);
+
+	ksRewind(screens);
+	while ((key=ksNext(screens))) {
+		XF86ConfScreenPtr screen;
+		Key *genericKey;
+		KeySet *optionKeys;
+		KeySet *settings;
+		char *options=NULL;
+		char *buffer;
+		size_t dataSize;
+		
+		screen=xf86confmalloc(sizeof(XF86ConfScreenRec));
+		memset(screen,0,sizeof(XF86ConfScreenRec));
+		
+		buffer = xf86confmalloc((size = 300));
+		
+		/* calculate identifier from key basename */
+		dataSize=keyGetBaseNameSize(key);
+		screen->scrn_identifier=xf86confmalloc(dataSize);
+		keyGetBaseName(key,screen->scrn_identifier,dataSize);
+		
+		settings = ksNew();
+		kdbGetKeyChildKeys(handle, key, settings, 0);
+				
+		/* Get Driver (obsolete) */
+		snprintf(buffer, size, "%s/Driver", keyStealName(key));
+		if ( (genericKey = ksLookupByName(settings, buffer, KDB_O_LOOP)) ) {
+			dataSize=keyGetDataSize(genericKey);
+			screen->scrn_obso_driver=xf86confmalloc(dataSize);
+			keyGetString(genericKey,screen->scrn_obso_driver,dataSize);
+		}
+		
+		/* Get DefaultDepth */
+		snprintf(buffer, size, "%s/DefaultDepth", keyStealName(key));
+		if ( (genericKey = ksLookupByName(settings, buffer, KDB_O_LOOP)) ) {
+			screen->scrn_defaultdepth=strtol(keyStealValue(genericKey), NULL, 10);
+		}
+		
+		/* Get DefaultBPP */
+		snprintf(buffer, size, "%s/DefaultBPPr", keyStealName(key));
+		if ( (genericKey = ksLookupByName(settings, buffer, KDB_O_LOOP)) ) {
+			screen->scrn_defaultbpp=strtol(keyStealValue(genericKey), NULL, 10);
+		}
+		
+		/* Get DefaultFbBPP */
+		snprintf(buffer, size, "%s/DefaultFbBPP", keyStealName(key));
+		if ( (genericKey = ksLookupByName(settings, buffer, KDB_O_LOOP)) ) {
+			screen->scrn_defaultfbbpp=strtol(keyStealValue(genericKey), NULL, 10);
+		}
+		
+		/* Get Device */
+		snprintf(buffer, size, "%s/Device", keyStealName(key));
+		if ( (genericKey = ksLookupByName(settings, buffer, KDB_O_LOOP)) ) {
+			dataSize=keyGetDataSize(genericKey);
+			screen->scrn_device_str=xf86confmalloc(dataSize);
+			keyGetString(genericKey,screen->scrn_device_str,dataSize);
+		}
+		
+		/* Get Monitor */
+		snprintf(buffer, size, "%s/Monitor", keyStealName(key));
+                if ( (genericKey = ksLookupByName(settings, buffer, KDB_O_LOOP)) ) {
+			dataSize=keyGetDataSize(genericKey);
+			screen->scrn_monitor_str=xf86confmalloc(dataSize);
+			keyGetString(genericKey,screen->scrn_monitor_str,dataSize);
+		}
+		
+		/* Get VideoAdaptor  */
+		snprintf(buffer, size, "%s/VideoAdaptor", keyStealName(key));
+		if ( (genericKey = ksLookupByName(settings, buffer, KDB_O_LOOP)) ) {
+			char *cursor,*cursorEnd;
+			
+			keyGetString(genericKey,buffer,size);
+			
+			cursor=buffer;
+			do {
+				XF86ConfAdaptorLinkPtr aptr;
+				
+				cursorEnd=index(cursor,',');
+				if (cursorEnd) {
+					*cursorEnd=0;
+					cursorEnd++;
+				}
+				
+				/* Don't allow duplicates */
+				for (aptr = screen->scrn_adaptor_lst; aptr;
+						aptr = (XF86ConfAdaptorLinkPtr) aptr->list.next)
+					if (xf86nameCompare (cursor, aptr->al_adaptor_str)==0)
+						break;
+				
+				if (aptr == NULL) {
+					aptr = xf86confmalloc (sizeof(XF86ConfAdaptorLinkRec));
+					memset(aptr,0,sizeof(XF86ConfAdaptorLinkRec));
+					aptr->al_adaptor_str=xf86confmalloc(strlen(cursor));
+					strcpy(aptr->al_adaptor_str,cursor);
+					screen->scrn_adaptor_lst = (XF86ConfAdaptorLinkPtr)
+						xf86addListItem ((glp) screen->scrn_adaptor_lst,
+								(glp) aptr);
+				}
+				cursor=cursorEnd;
+			} while (cursor);
+		}
+		
+		/* Get Display subsections */
+		dataSize=keyGetFullNameSize(key)+30;
+		options=xf86confmalloc(dataSize);
+		keyGetFullName(key,options,dataSize);
+		strncat(options,"/Displays", dataSize-1);
+		
+		optionKeys = ksNew();
+		kdbGetChildKeys(handle, options,optionKeys,KDB_O_SORT | KDB_O_DIR);
+		if (ksGetSize(optionKeys))
+			screen->scrn_display_lst=ksToDisplays(handle, optionKeys);
+		xf86conffree (options);
+		ksClose(optionKeys);
+		
+		/* Now get this screen's options */
+		dataSize=keyGetFullNameSize(key)+30;
+		options=xf86confmalloc(dataSize);
+		keyGetFullName(key,options,dataSize);
+		strncat(options,"/Options", dataSize-1);
+		
+		ksInit(optionKeys);
+		kdbGetChildKeys(handle, options,optionKeys,KDB_O_SORT);
+		if (ksGetSize(optionKeys))
+			screen->scrn_option_lst=ksToOptions(optionKeys);
+		xf86conffree (options);
+		ksDel(optionKeys);
+		
+		/* Finished with this Screen. Now add to our screens list */
+		if (ptr) ptr=(XF86ConfScreenPtr)
+			xf86addListItem ((glp) ptr, (glp) screen);
+		else  ptr=screen;
+
+		xf86conffree(buffer);
+		ksDel(settings);
+	}
+
+	ksDel(screens);
+
+#ifdef DEBUG
+	printf ("Screen keys grabed\n");
+#endif
+
+	return ptr;
+}
+
+
+/*
+ * Elektra version of Screen.c::xf86printScreenSection()
+ *
+ * Generates a KeySet from a passed linked list of XF86ConfScreenPtr struct
+ * plus a root key name.
+ * 
+ */
+void
+xf86addScreens (KeySet *ks, const char *root, XF86ConfScreenPtr ptr)
+{
+	XF86ConfAdaptorLinkPtr aptr;
+	XF86ConfDisplayPtr dptr;
+	XF86ModePtr mptr;
+
+	Key *key;
+	size_t size;
+	char *buffer;
+	char *screenroot;
+	char *value;
+	char *superbuffer=NULL;
+	unsigned dn=0;
+
+	size = 300;
+	buffer = xf86confmalloc(size);
+	screenroot = xf86confmalloc(size);
+	value = xf86confmalloc(size);
+	
+	while (ptr)
+	{
+		snprintf(screenroot, size, "%s/Screens/%s",root,ptr->scrn_identifier);
+
+		/* Elektrify . . .
+		if (ptr->scrn_comment)
+			fprintf (cf, "%s", ptr->scrn_comment);
+		*/
+
+		if (ptr->scrn_obso_driver) {
+			snprintf(buffer, size, "%s/Driver",screenroot);
+			key = keyNew(buffer,
+     					KEY_SWITCH_VALUE, ptr->scrn_obso_driver,					
+					KEY_SWITCH_END);
+			ksAppend(ks,key);
+		}
+
+		if (ptr->scrn_device_str) {
+			snprintf(buffer, size, "%s/Device",screenroot);
+			key = keyNew(buffer,
+					KEY_SWITCH_VALUE, ptr->scrn_device_str,
+					KEY_SWITCH_END);			
+			ksAppend(ks,key);
+		}
+
+		if (ptr->scrn_monitor_str) {
+			snprintf(buffer, size, "%s/Monitor",screenroot);
+			key = keyNew(buffer,
+					KEY_SWITCH_VALUE, ptr->scrn_monitor_str,
+					KEY_SWITCH_END);
+			ksAppend(ks,key);
+		}
+
+		if (ptr->scrn_defaultdepth) {
+			snprintf(buffer, size, "%s/DefaultDepth",screenroot);
+			snprintf(value, size, "%d",ptr->scrn_defaultdepth);
+			key = keyNew(buffer,
+					KEY_SWITCH_VALUE, value,
+					KEY_SWITCH_END);
+			ksAppend(ks,key);
+		}
+
+		if (ptr->scrn_defaultbpp) {
+			snprintf(buffer, size, "%s/DefaultBPP",screenroot);
+			snprintf(value, size, "%d",ptr->scrn_defaultbpp);
+			key = keyNew(buffer,
+					KEY_SWITCH_VALUE, value,
+					KEY_SWITCH_END);
+			ksAppend(ks,key);
+		}
+
+		if (ptr->scrn_defaultfbbpp) {
+			snprintf(buffer, size, "%s/DefaultFbBPP",screenroot);
+			snprintf(value, size, "%d",ptr->scrn_defaultfbbpp);
+			key = keyNew(buffer,
+					KEY_SWITCH_VALUE, value,
+					KEY_SWITCH_END);
+			ksAppend(ks,key);
+		}
+
+		snprintf(buffer, size, "%s/Options",screenroot);
+		xf86addOptions(ks,buffer,ptr->scrn_option_lst);
+
+		for (aptr = ptr->scrn_adaptor_lst; aptr; aptr = aptr->list.next)
+		{
+			if (!superbuffer)
+				superbuffer=xf86confmalloc(strlen(aptr->al_adaptor_str)+1);
+			else {
+				char *tmp;
+
+				tmp=xf86confmalloc(strlen(aptr->al_adaptor_str) +
+					strlen(superbuffer) + 1);
+				strcpy(tmp,superbuffer);
+				xf86conffree(superbuffer);
+				superbuffer=tmp;
+				strcat(superbuffer,",");
+				strcat(superbuffer,aptr->al_adaptor_str);
+			}
+		}
+		if (superbuffer) {
+			snprintf(buffer, size, "%s/VideoAdaptor",screenroot);
+			key = keyNew(buffer, 
+					KEY_SWITCH_VALUE, superbuffer,
+					KEY_SWITCH_END);
+			ksAppend(ks,key);
+
+			xf86conffree(superbuffer);
+		}
+
+
+		for (dptr = ptr->scrn_display_lst; dptr; dptr = dptr->list.next)
+		{
+			char disproot[300];
+
+			snprintf(disproot, sizeof(disproot), "%s/Displays/%02d",screenroot,dn);
+			++dn;
+
+			/* Figure out comments....
+			if (dptr->disp_comment)
+				fprintf (cf, "%s", dptr->disp_comment);
+			*/
+			if (dptr->disp_frameX0 >= 0 || dptr->disp_frameY0 >= 0)
+			{
+				snprintf(buffer, size, "%s/Viewport.x",disproot);
+				snprintf(value, size, "%d", dptr->disp_frameX0);
+				key = keyNew(buffer,
+						KEY_SWITCH_VALUE, value,
+						KEY_SWITCH_END);
+				ksAppend(ks,key);
+
+				snprintf(buffer, size, "%s/Viewport.y",disproot);
+				snprintf(value, size, "%d",dptr->disp_frameY0);
+				key = keyNew(buffer,
+						KEY_SWITCH_VALUE, value,
+						KEY_SWITCH_END);
+				ksAppend(ks,key);
+			}
+			if (dptr->disp_virtualX != 0 || dptr->disp_virtualY != 0)
+			{
+				snprintf(buffer, size, "%s/Virtual.x",disproot);
+				snprintf(value, size, "%d",dptr->disp_virtualX);
+				key = keyNew(buffer,
+						KEY_SWITCH_VALUE, value,
+						KEY_SWITCH_END);
+				ksAppend(ks,key);
+
+				snprintf(buffer, size, "%s/Virtual.y",disproot);
+				snprintf(value, size, "%d",dptr->disp_virtualY);
+				key = keyNew(buffer,
+						KEY_SWITCH_VALUE, value,
+						KEY_SWITCH_END);
+				ksAppend(ks,key);
+			}
+			if (dptr->disp_depth)
+			{
+				snprintf(buffer, size, "%s/Depth",disproot);
+				snprintf(value, size, "%d",dptr->disp_depth);
+				key = keyNew(buffer,
+						KEY_SWITCH_VALUE, value,
+						KEY_SWITCH_END);
+				ksAppend(ks,key);
+			}
+			if (dptr->disp_bpp)
+			{
+				snprintf(buffer, size, "%s/FbBPP",disproot);
+				snprintf(value, size,"%d",dptr->disp_bpp);
+				key = keyNew(buffer,
+						KEY_SWITCH_VALUE, value,
+						KEY_SWITCH_END);
+				ksAppend(ks,key);
+			}
+			if (dptr->disp_visual)
+			{
+				snprintf(buffer, size, "%s/Visual",disproot);
+				key = keyNew(buffer,
+						KEY_SWITCH_VALUE, dptr->disp_visual,
+						KEY_SWITCH_END);
+				ksAppend(ks,key);
+			}
+			if (dptr->disp_weight.red != 0)
+			{
+				snprintf(buffer, size, "%s/Weight.red",disproot);
+				snprintf(value, size, "%d",dptr->disp_weight.red);
+				key = keyNew(buffer,
+						KEY_SWITCH_VALUE, value,
+						KEY_SWITCH_END);
+				ksAppend(ks,key);
+
+				snprintf(buffer, size, "%s/Weight.green",disproot);
+				snprintf(value, size, "%d",dptr->disp_weight.green);
+				key = keyNew(buffer,
+						KEY_SWITCH_VALUE, value,
+						KEY_SWITCH_END);
+				ksAppend(ks,key);
+
+				snprintf(buffer, size, "%s/Weight.blue",disproot);
+				snprintf(buffer, size, "%d",dptr->disp_weight.blue);
+				key = keyNew(buffer,
+						KEY_SWITCH_VALUE, value,
+						KEY_SWITCH_END);
+				ksAppend(ks,key);
+			}
+			if (dptr->disp_black.red != -1)
+			{
+				snprintf(buffer, size, "%s/Black.red",disproot);
+				snprintf(value, size, "0x%04x",dptr->disp_black.red);
+				key = keyNew(buffer,
+						KEY_SWITCH_VALUE, value,
+						KEY_SWITCH_END);
+				ksAppend(ks,key);
+
+				snprintf(buffer, size, "%s/Black.green",disproot);
+				snprintf(value, size, "0x%04x",dptr->disp_black.green);
+				key = keyNew(buffer,
+						KEY_SWITCH_VALUE, value,
+						KEY_SWITCH_END);
+				ksAppend(ks,key);
+
+				snprintf(buffer, size, "%s/Black.blue",disproot);
+				snprintf(value, size, "0x%04x",dptr->disp_black.blue);
+				key = keyNew(buffer,
+						KEY_SWITCH_VALUE, value,
+						KEY_SWITCH_END);
+				ksAppend(ks,key);
+			}
+			if (dptr->disp_white.red != -1)
+			{
+				snprintf(buffer, size, "%s/White.red",disproot);
+				snprintf(value, size, "0x%04x",dptr->disp_white.red);
+				key = keyNew(buffer,
+						KEY_SWITCH_VALUE, value,
+						KEY_SWITCH_END);
+				ksAppend(ks,key);
+
+				snprintf(buffer, size, "%s/White.green",disproot);
+				snprintf(value, size, "0x%04x",dptr->disp_white.green);
+				key = keyNew(buffer,
+						KEY_SWITCH_VALUE, value,
+						KEY_SWITCH_END);
+				ksAppend(ks,key);
+
+				snprintf(buffer, size, "%s/White.blue",disproot);
+				snprintf(value, size, "0x%04x",dptr->disp_white.blue);
+				key = keyNew(buffer,
+						KEY_SWITCH_VALUE, value,
+						KEY_SWITCH_END);
+				ksAppend(ks,key);
+			}
+			if (dptr->disp_mode_lst)
+			{
+				snprintf(buffer, size, "%s/Modes",disproot);
+				value[0]=0;
+				for (mptr = dptr->disp_mode_lst; mptr; mptr = mptr->list.next)
+				{
+					if (value[0] != 0)
+						strncat(value,",", size-1);
+					strncat(value,mptr->mode_name,size-1);
+				}
+				key = keyNew(buffer,
+						KEY_SWITCH_VALUE, value,
+						KEY_SWITCH_END);
+
+				ksAppend(ks,key);
+			}
+
+			xf86addOptions(ks,disproot,dptr->disp_option_lst);
+		}
+		ptr = ptr->list.next;
+	}
+
+	xf86conffree(value);
+	xf86conffree(screenroot);
+	xf86conffree(buffer);
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+/*
+ * Elektra version for the Module.c::xf86parseModuleSection() and
+ * xf86parseModuleSubSection() functions.
+ *
+ * Fetch keys under [rootKey]/Modules .
+ *
+ */
+XF86ConfModulePtr
+xf86getModules (KDBHandle handle, const char *rootKey)
+{
+	KeySet *ksModules;
+	Key *key;
+	Key *loadDriver;
+	size_t size;
+	char *localRootKey;
+	char *buffer;
+	int  ret;
+
+	parsePrologue (XF86ConfModulePtr, XF86ConfModuleRec)
+
+	size = strlen(rootKey)+100;
+	localRootKey = xf86confmalloc(size);
+	buffer = xf86confmalloc(size);
+	
+	snprintf(localRootKey, size, "%s/Modules", rootKey);	
+
+	/* Look for the Load modules */
+        /* Look for the modules to be loaded and their options */
+	ksModules = ksNew();
+	kdbGetChildKeys(handle, localRootKey,ksModules,KDB_O_NOVALUE | KDB_O_DIR);
+	
+ 	if (ksGetSize(ksModules)) {
+ 		ksRewind(ksModules);
+ 		while ((key=ksNext(ksModules))) {
+ 			XF86LoadPtr lptr;
+ 			KeySet *optionKeys;
+			
+ 			lptr=xf86confmalloc(sizeof(XF86LoadRec));
+ 			memset(lptr,0,sizeof(XF86LoadRec));
+ 			lptr->load_type=XF86_LOAD_MODULE;
+ 			size=keyGetBaseNameSize(key);
+ 			lptr->load_name=xf86confmalloc(size);
+ 			keyGetBaseName(key,lptr->load_name,size);
+			
+			optionKeys = ksNew();
+ 			keyGetName(key,localRootKey,sizeof(localRootKey));
+ 			kdbGetChildKeys(handle, localRootKey,optionKeys,KDB_O_SORT);
+ 			if (ksGetSize(optionKeys))
+ 				lptr->load_opt=ksToOptions(optionKeys);
+ 			ksDel(optionKeys);
+			
+ 			ptr->mod_load_lst=(XF86LoadPtr)
+				xf86addListItem((glp)ptr->mod_load_lst,(glp)lptr);
+ 		}
+ 	}
+ 	ksDel(ksModules);
+
+	/* Look for the (undocumented) LoadDriver modules */
+	loadDriver = keyNew(KEY_SWITCH_END);
+	ret=kdbGetKeyByParent(handle, localRootKey,"LoadDrivers",loadDriver);
+	snprintf(buffer, size, "%s/LoadDivers", localRootKey);
+	if ( ret == 0 ) {
+		char *cursor, *cursorEnd;
+
+		keyGetString(loadDriver, buffer, size);
+		cursor=buffer;
+		do {
+			char *name=NULL;
+
+			cursorEnd=index(cursor,',');
+			if (cursorEnd) {
+				*cursorEnd=0;
+				cursorEnd++;
+			}
+
+			name=xf86confmalloc(strlen(cursor)+1);
+			strcpy(name,cursor);
+
+			ptr->mod_load_lst =
+			xf86addNewLoadDirective (ptr->mod_load_lst, name,
+				XF86_LOAD_DRIVER, NULL);
+
+			cursor=cursorEnd;
+		} while (cursor);
+	}
+	keyDel(loadDriver);
+
+	xf86conffree(buffer);
+	xf86conffree(localRootKey);
+	
+#ifdef DEBUG
+	printf ("Module keys grabed\n");
+#endif
+
+	return ptr;
+}
+
+
+/*
+ * Elektra version of Modules.c::xf86printModuleSection()
+ *
+ * Generates a KeySet from a passed linked list of XF86ConfModulePtr struct
+ * plus a root key name.
+ * 
+ */
+void
+xf86addModules (KeySet *ks, const char *root, XF86ConfModulePtr ptr) {
+	XF86LoadPtr lptr;
+	Key *key;
+	char *buffer;
+	char *modroot;
+	char *loaddrivers=NULL;
+	char *tmp;
+	size_t size;
+
+	if (ptr == NULL)
+		return;
+
+	size = 300;
+	buffer = xf86confmalloc(size);
+	modroot = xf86confmalloc(size);
+	
+	snprintf(modroot, size, "%s/Modules",root);
+
+	/* figure out how to Elektrify comments . . . .
+	if (ptr->mod_comment)
+		fprintf(cf, "%s", ptr->mod_comment);
+	*/
+
+	for (lptr = ptr->mod_load_lst; lptr; lptr = lptr->list.next)
+	{
+		switch (lptr->load_type)
+		{
+		case XF86_LOAD_MODULE:
+
+			/* Extract path & filename */
+			strncpy(buffer, lptr->load_name, size-1);
+			tmp = rindex(buffer, PATHSEPARATOR);
+			if ( tmp != NULL ) {
+				/* A path is provided 
+				 * Add this path to "ModulePath" directive  
+				 */
+				char keyName[300];
+				Key  *modPath;
+
+				/* Make "buffer" a string which contain dirname */
+				*tmp = '\0';
+
+				/* Now tmp point to the module basename */
+				tmp++;
+				
+				/* Fetch "ModulePath" from the keyset */
+				snprintf(keyName, sizeof(keyName), "%s/Files/ModulePath", root);
+				ksRewind(ks);
+				if ( (modPath = ksLookupByName(ks, keyName, KDB_O_LOOP)) == NULL ) {
+					/* ModulePath doesn't exist 
+					 * Create & set it to the module path
+					 */
+					modPath = keyNew(keyName,
+							KEY_SWITCH_VALUE, buffer,
+							KEY_SWITCH_END);
+					ksAppend(ks, modPath);
+										
+					keySetString(modPath, buffer);
+				} else {
+					/* ModulePath exist, add this module path 
+					 * We put this path at the begining
+					 * since a module with the same name could exist
+					 * in the standard path.
+					 */
+					char *oldPath, *newPath;
+					
+					oldPath = keyStealValue(modPath);
+					newPath = xf86confmalloc(strlen(oldPath) + 1 + strlen(buffer) + 1);
+					sprintf(newPath, "%s,%s", buffer, oldPath);
+					keySetString(modPath, newPath);
+					xf86conffree(newPath);
+				}
+
+				/* Set key name to Load/<module basename> */
+				snprintf(buffer, size, "%s/%s", modroot, tmp);	
+			} else {
+				/* Module name provided without path */
+				snprintf(buffer, size, "%s/%s", modroot, lptr->load_name);
+			}
+			key = keyNew(buffer,
+					KEY_SWITCH_TYPE, KEY_TYPE_DIR,
+    					KEY_SWITCH_END);
+  			ksAppend(ks,key);
+
+			if( lptr->load_opt) {
+ 				xf86addOptions(ks,buffer,lptr->load_opt);
+ 			}
+			break;
+
+		case XF86_LOAD_DRIVER:
+			if (loaddrivers==0)
+				loaddrivers=xf86confmalloc(strlen(lptr->load_name));
+			else {
+				char *tmp=xf86confmalloc(strlen(lptr->load_name) +
+					strlen(loaddrivers) + 1 /* for the coma */);
+
+				strcpy(tmp,loaddrivers);
+				if ( strlen(tmp) )
+					strcat(tmp,",");
+				xf86conffree(loaddrivers);
+				loaddrivers=tmp;
+				strcat(loaddrivers,lptr->load_name);
+			}
+			break;
+#if 0
+		default:
+			fprintf (cf, "#\tUnknown type  \"%s\"\n", lptr->load_name);
+			break;
+#endif
+		}
+	}
+
+	if (loaddrivers) {
+		snprintf(buffer, size, "%s/LoadDrivers",modroot);
+		key = keyNew(buffer, 
+				KEY_SWITCH_VALUE, loaddrivers,
+				KEY_SWITCH_END);
+		ksAppend(ks,key);
+	}
+
+	xf86conffree(modroot);
+	xf86conffree(buffer);
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+/*
+ * Elektra version for the Layout.c::xf86parseLayoutSection() function.
+ *
+ * Fetch keys under [rootKey]/Layouts .
+ *
+ */
+XF86ConfLayoutPtr
+xf86getLayout (KDBHandle handle, const char *rootKey)
+{
+	XF86ConfLayoutPtr lay=NULL; /* we'll return this */
+	KeySet *layouts;
+	KeySet *screens;
+	KeySet *inputs;
+	KeySet *options;
+	Key *key,*layout;
+	char *buffer;
+	size_t size, bufSize;
+
+	bufSize = 300;
+	buffer = xf86confmalloc(bufSize); 
+
+	snprintf(buffer, bufSize, "%s/Layouts", rootKey);	 
+
+	layouts = ksNew();
+	kdbGetChildKeys(handle, buffer,layouts, KDB_O_DIR);
+	ksRewind(layouts);
+	while ((layout=ksNext(layouts))) {
+		parsePrologue (XF86ConfLayoutPtr, XF86ConfLayoutRec) 
+
+		/* Calculate Identifier */
+		size=keyGetBaseNameSize(layout);
+		ptr->lay_identifier=xf86confmalloc(size);
+		keyGetBaseName(layout,ptr->lay_identifier,size);  
+
+		/* Get screens layout */
+		snprintf(buffer, bufSize, "%s/Screens", keyStealName(layout)); 
+		
+		screens = ksNew();
+		kdbGetChildKeys(handle, buffer,screens, KDB_O_DIR);
+		ksRewind(screens);
+		while ((key=ksNext(screens))) { 
+			XF86ConfAdjacencyPtr aptr;
+			KeySet *screenParameters;
+			Key *screenPar; 
+			
+			/* initialize object */
+			aptr=xf86confmalloc (sizeof (XF86ConfAdjacencyRec));
+			aptr->list.next = NULL;
+			aptr->adj_scrnum = -1;
+			aptr->adj_where = CONF_ADJ_OBSOLETE;
+			aptr->adj_x = 0;
+			aptr->adj_y = 0;
+			aptr->adj_refscreen = NULL; 
+			
+			/* Get screen name */
+			size=keyGetBaseNameSize(key);
+			aptr->adj_screen_str=xf86confmalloc(size);
+			keyGetBaseName(key,aptr->adj_screen_str,size);
+			
+			screenParameters = ksNew();
+			kdbGetKeyChildKeys(handle, key, screenParameters, KDB_O_DIR);
+			ksRewind(screenParameters); 
+	
+				
+			snprintf(buffer, bufSize, "%s/RightOf", keyStealName(key));  
+			if ( (screenPar = ksLookupByName(screenParameters, buffer, KDB_O_LOOP)) ) {
+				aptr->adj_where = CONF_ADJ_RIGHTOF;
+				size=keyGetDataSize(screenPar);
+				aptr->adj_refscreen=xf86confmalloc(size);
+				keyGetString(screenPar,aptr->adj_refscreen,size);
+			}
+			
+			snprintf(buffer, bufSize, "%s/LeftOf", keyStealName(key));
+			if ( (screenPar = ksLookupByName(screenParameters, buffer, KDB_O_LOOP)) ) {
+				aptr->adj_where = CONF_ADJ_LEFTOF;
+				size=keyGetDataSize(screenPar);
+				aptr->adj_refscreen=xf86confmalloc(size);
+				keyGetString(screenPar,aptr->adj_refscreen,size);
+			}
+
+			snprintf(buffer, bufSize, "%s/Above", keyStealName(key));
+			if ( (screenPar = ksLookupByName(screenParameters, buffer, KDB_O_LOOP)) ) {
+				aptr->adj_where = CONF_ADJ_ABOVE;
+				size=keyGetDataSize(screenPar);
+				aptr->adj_refscreen=xf86confmalloc(size);
+				keyGetString(screenPar,aptr->adj_refscreen,size);
+			}
+
+			snprintf(buffer, bufSize, "%s/Below", keyStealName(key));
+			if ( (screenPar = ksLookupByName(screenParameters, buffer, KDB_O_LOOP)) ) {
+				aptr->adj_where = CONF_ADJ_BELOW;
+				size=keyGetDataSize(screenPar);
+				aptr->adj_refscreen=xf86confmalloc(size);
+				keyGetString(screenPar,aptr->adj_refscreen,size);
+			}
+
+			snprintf(buffer, bufSize, "%s/Relative", keyStealName(key));
+			if ( (screenPar = ksLookupByName(screenParameters, buffer, KDB_O_LOOP)) ) {
+				aptr->adj_where = CONF_ADJ_RELATIVE;
+				size=keyGetDataSize(screenPar);
+				aptr->adj_refscreen=xf86confmalloc(size);
+				keyGetString(screenPar,aptr->adj_refscreen,size);
+			}
+
+			snprintf(buffer, bufSize, "%s/Relative.x", keyStealName(key));
+			if ( (screenPar = ksLookupByName(screenParameters, buffer, KDB_O_LOOP)) ) {
+				aptr->adj_where = CONF_ADJ_RELATIVE;
+				aptr->adj_x=strtol(keyStealValue(screenPar),NULL,10);
+				
+				size=keyGetDataSize(screenPar);
+				aptr->adj_refscreen=xf86confmalloc(size);
+				keyGetString(screenPar,aptr->adj_refscreen,size);
+			}
+
+			snprintf(buffer, bufSize, "%s/Relative.y", keyStealName(key));
+			if ( (screenPar = ksLookupByName(screenParameters, buffer, KDB_O_LOOP)) ) {
+				aptr->adj_where = CONF_ADJ_RELATIVE;
+				aptr->adj_y=strtol(keyStealValue(screenPar),NULL,10);
+				
+				size=keyGetDataSize(screenPar);
+				aptr->adj_refscreen=xf86confmalloc(size);
+				keyGetString(screenPar,aptr->adj_refscreen,size);
+			}
+
+			snprintf(buffer, bufSize, "%s/Absolute.x", keyStealName(key));
+			if ( (screenPar = ksLookupByName(screenParameters, buffer, KDB_O_LOOP)) ) {
+				aptr->adj_where = CONF_ADJ_ABSOLUTE;
+				aptr->adj_x=strtol(keyStealValue(screenPar),NULL,10);
+			}
+
+			snprintf(buffer, bufSize, "%s/Absolute.y", keyStealName(key));
+			if ( (screenPar = ksLookupByName(screenParameters, buffer, KDB_O_LOOP)) ) {
+				aptr->adj_where = CONF_ADJ_ABSOLUTE;
+				aptr->adj_y=strtol(keyStealValue(screenPar),NULL,10);
+			}
+
+			snprintf(buffer, bufSize, "%s/ScreenNumber", keyStealName(key));
+			if ( (screenPar = ksLookupByName(screenParameters, buffer, KDB_O_LOOP)) ) {
+				aptr->adj_scrnum=strtol(keyStealValue(screenPar),NULL,10);
+			}
+			
+			ptr->lay_adjacency_lst = (XF86ConfAdjacencyPtr)
+				xf86addListItem ((glp) ptr->lay_adjacency_lst, (glp) aptr); 
+			
+			ksDel(screenParameters); 
+		
+		} 
+		ksDel(screens); 
+		
+		/* Get used input devices */
+		snprintf(buffer, bufSize, "%s/Inputs/", keyStealName(layout));
+
+		inputs = ksNew();
+		kdbGetChildKeys(handle, buffer,inputs,KDB_O_DIR);
+		ksRewind(inputs);
+		
+		while ((key=ksNext(inputs))) {
+			XF86ConfInputrefPtr iptr;
+			KeySet *iopts;
+			char dev[300];
+			size_t size;
+
+			iptr = xf86confmalloc (sizeof (XF86ConfInputrefRec));
+			iptr->list.next = NULL;
+			iptr->iref_option_lst = NULL;
+
+			size=keyGetBaseNameSize(key);
+			iptr->iref_inputdev_str = xf86confmalloc(size);
+			keyGetBaseName(key,iptr->iref_inputdev_str,size); 
+
+			/* Get options for current input device */
+			strncpy(dev,buffer, sizeof(dev)-1);
+			strncat(dev,iptr->iref_inputdev_str, sizeof(dev)-1);
+
+			iopts = ksNew();
+			kdbGetChildKeys(handle, dev,iopts,KDB_O_SORT);
+			if (ksGetSize(iopts))
+				iptr->iref_option_lst=ksToOptions(iopts);
+			ksDel(iopts); 
+			
+			 ptr->lay_input_lst = (XF86ConfInputrefPtr)
+				xf86addListItem ((glp) ptr->lay_input_lst, (glp) iptr); 
+		}
+		ksDel(inputs);
+
+		/* Get general Layout Options */
+		snprintf(buffer, bufSize, "%s/Options", keyStealName(layout));
+
+		options = ksNew();
+		kdbGetChildKeys(handle, buffer,options,KDB_O_SORT);
+		if (ksGetSize(options))
+			ptr->lay_option_lst=ksToOptions(options);
+		ksDel(options); 
+
+		/* Finalize adding to the list */
+		lay=(XF86ConfLayoutPtr)xf86addListItem ((glp) lay, (glp) ptr); 
+	}
+	ksDel(layouts);
+	xf86conffree(buffer); 
+
+#ifdef DEBUG
+	printf ("Server Layouts grabed\n");
+#endif
+
+	return lay;
+}
+
+
+
+/*
+ * Elektra version of Layout.c::xf86printLayoutSection()
+ *
+ * Generates a KeySet from a passed linked list of XF86ConfLayoutPtr struct
+ * plus a root key name.
+ * 
+ */
+void
+xf86addLayout(KeySet *ks, const char *root, XF86ConfLayoutPtr ptr) {
+	XF86ConfAdjacencyPtr aptr;
+	XF86ConfInputrefPtr inptr;
+
+	char *buffer;
+	char *layroot;
+	char *value;
+	size_t size;
+	Key *key;
+
+	size=300;
+	buffer = xf86confmalloc(size);
+	layroot = xf86confmalloc(size);
+	value = xf86confmalloc(size);
+	
+	while (ptr) {
+		snprintf(layroot, size, "%s/Layouts/%s",root,ptr->lay_identifier);
+
+		/* Figure out where to put this....
+		if (ptr->lay_comment)
+			fprintf (cf, "%s", ptr->lay_comment);
+		*/
+
+		for (aptr = ptr->lay_adjacency_lst; aptr; aptr = aptr->list.next)
+		{
+			char screenroot[300];
+
+			snprintf(screenroot, sizeof(screenroot), "%s/Screens/%s",layroot,aptr->adj_screen_str);
+
+			if (aptr->adj_scrnum >= 0) {
+				snprintf(buffer, size, "%s/ScreenNumber",screenroot);
+				snprintf(value, size, "%d",aptr->adj_scrnum);
+				key = keyNew(buffer,
+						KEY_SWITCH_VALUE, value,
+						KEY_SWITCH_END);
+				ksAppend(ks,key);
+			}
+
+			switch(aptr->adj_where)
+			{
+/*			case CONF_ADJ_OBSOLETE:
+				fprintf (cf, " \"%s\"", aptr->adj_top_str);
+				fprintf (cf, " \"%s\"", aptr->adj_bottom_str);
+				fprintf (cf, " \"%s\"", aptr->adj_right_str);
+				fprintf (cf, " \"%s\"\n", aptr->adj_left_str);
+				break;*/
+			case CONF_ADJ_ABSOLUTE:
+				if (aptr->adj_x != -1) {
+					snprintf(buffer, size, "%s/Absolute.x",screenroot);
+					snprintf(value, size, "%d",aptr->adj_x);
+					key = keyNew(buffer,
+							KEY_SWITCH_VALUE, value,
+							KEY_SWITCH_END);
+					ksAppend(ks,key);
+
+					snprintf(buffer, size, "%s/Absolute.y",screenroot);
+					snprintf(value, size, "%d",aptr->adj_y);
+					key = keyNew(buffer,
+							KEY_SWITCH_VALUE, value,
+							KEY_SWITCH_END);
+					ksAppend(ks,key);
+				}
+				break;
+			case CONF_ADJ_RIGHTOF:
+				snprintf(buffer, size, "%s/RightOf",screenroot);
+				snprintf(value, size, "%s",aptr->adj_refscreen);
+				key = keyNew(buffer,
+						KEY_SWITCH_VALUE, value,
+						KEY_SWITCH_END);
+				ksAppend(ks,key);
+				break;
+			case CONF_ADJ_LEFTOF:
+				snprintf(buffer, size, "%s/LeftOf",screenroot);
+				snprintf(value, size,"%s",aptr->adj_refscreen);
+				key = keyNew(buffer,
+						KEY_SWITCH_VALUE, value,
+						KEY_SWITCH_END);
+				ksAppend(ks,key);
+				break;
+			case CONF_ADJ_ABOVE:
+				snprintf(buffer, size, "%s/Above",screenroot);
+				snprintf(value, size,"%s",aptr->adj_refscreen);
+				key = keyNew(buffer,
+						KEY_SWITCH_VALUE, value,
+						KEY_SWITCH_END);
+				ksAppend(ks,key);
+				break;
+			case CONF_ADJ_BELOW:
+				snprintf(buffer, size, "%s/Below",screenroot);
+				snprintf(value, size,"%s",aptr->adj_refscreen);
+				key = keyNew(buffer,
+						KEY_SWITCH_VALUE, value,
+						KEY_SWITCH_END);
+				ksAppend(ks,key);
+				break;
+			case CONF_ADJ_RELATIVE:
+				snprintf(buffer, size, "%s/Relative",screenroot);
+				snprintf(value, size,"%s",aptr->adj_refscreen);
+				key = keyNew(buffer,
+						KEY_SWITCH_VALUE, value,
+						KEY_SWITCH_END);
+				ksAppend(ks,key);
+
+				snprintf(buffer, size, "%s/Relative.x",screenroot);
+				snprintf(value, size, "%d",aptr->adj_x);
+				key = keyNew(buffer,
+						KEY_SWITCH_VALUE, value,
+						KEY_SWITCH_END);
+				ksAppend(ks,key);
+
+				snprintf(buffer, size, "%s/Relative.y",screenroot);
+				snprintf(value, size,"%d",aptr->adj_y);
+				key = keyNew(buffer,
+						KEY_SWITCH_VALUE, value,
+						KEY_SWITCH_END);
+				ksAppend(ks,key);
+
+				break;
+			}
+		}
+
+		/* Convert to Elektra....
+		for (iptr = ptr->lay_inactive_lst; iptr; iptr = iptr->list.next)
+			fprintf (cf, "\tInactive       \"%s\"\n", iptr->inactive_device_str);
+		*/
+
+		for (inptr = ptr->lay_input_lst; inptr; inptr = inptr->list.next)
+		{
+			snprintf(buffer, size, "%s/Inputs/%s",layroot,inptr->iref_inputdev_str);
+			xf86addOptions(ks,buffer,inptr->iref_option_lst);
+		}
+
+		/* The generic Layout options */
+		xf86addOptions(ks, layroot ,ptr->lay_option_lst);
+
+		ptr = ptr->list.next;
+	}
+
+	xf86conffree(value);
+	xf86conffree(layroot);
+	xf86conffree(buffer);
+}
+
+
+
+
+
+
+
+
+
+
+
+
+
+
+#undef CLEANUP
+#define CLEANUP xf86freeConfig
+
+
+/*
+ * Triggers all xf86get*() to fetch X.org configuration keys, and assemble a
+ * XF86ConfigPtr structure to be returned.
+ *
+ * This function is exported in elektra.h and will be called by
+ * xc/programs/Xserver/hw/xfree86/common/xf86Config.c::xf86HandleConfigFile()
+ *
+ * Elektra version for read.c::xf86readConfigFile() that triggers the read of
+ * plain-text human-readable xorg.conf file.
+ *
+ */
+XF86ConfigPtr
+xf86getConfigKeys (const char *rootKey)
+{
+	KDBHandle handle;
+	XF86ConfigPtr ptr = NULL;
+	Key *kroot;
+	
+	kdbOpen(&handle);
+
+	if ((ptr = xf86confcalloc(1, sizeof(XF86ConfigRec))) == NULL)	
+	{
+		return NULL;
+	}
+	memset (ptr, 0, sizeof (XF86ConfigRec));
+
+	/* First check if root key is there to avoid tons of key fetching */
+	kroot = keyNew(rootKey, KEY_SWITCH_END);
+	if (kdbStatKey(handle, kroot) == 0) {
+
+		/* assemble sub-structures */
+		ptr->conf_files = xf86getFiles (handle, rootKey);
+	
+ 		ptr->conf_flags = xf86getFlags (handle, rootKey);  
+	
+		/* keyboard, mouse and generic input */
+		ptr->conf_input_lst = xf86getInput (handle, rootKey);
+	
+		ptr->conf_device_lst = xf86getDevice (handle, rootKey);
+	
+		ptr->conf_monitor_lst = xf86getMonitor (handle, rootKey);
+	
+		ptr->conf_modes_lst = xf86getModes (handle, rootKey);
+	
+		ptr->conf_screen_lst = xf86getScreen (handle, rootKey);
+	
+		ptr->conf_modules = xf86getModules (handle, rootKey);  
+	
+		ptr->conf_layout_lst = xf86getLayout (handle, rootKey); 
+		/*ptr->conf_vendor_lst = xf86getVendor (rootKey);*/
+	
+		ptr->conf_dri = xf86getDRI (handle, rootKey); 
+		/*ptr->conf_videoadaptor_lst = xf86getVideo (rootKey);*/
+	}
+	
+	keyDel(kroot);
+	kdbClose(&handle);
+
+	/* validate and return */
+	if (xf86validateConfig (ptr))
+		return (ptr);
+	else
+	{
+		CLEANUP (ptr);
+		return (NULL);
+	}
+}
+
+
+
+/*
+ * Converts X internal structs into Elektra Keys.
+ * It does that triggering all xf86add*() functions.
+ *
+ * This function is exported in elektra.h and will be called by
+ * xc/programs/Xserver/hw/xfree86/common/xf86Config.c::xf86HandleConfigFile()
+ *
+ * Elektra version to write.c::xf86writeConfigFile() function.
+ *
+ */
+KeySet *xf86collectConfigKeys (const char *root, XF86ConfigPtr cptr) {
+	KeySet *ks=0;
+
+	ks = ksNew();
+	xf86addFiles(   ks, root, cptr->conf_files);
+	xf86addFlags(   ks, root, cptr->conf_flags);
+	xf86addInput(   ks, root, cptr->conf_input_lst);
+	xf86addDevice(  ks, root, cptr->conf_device_lst);
+	xf86addMonitor( ks, root, cptr->conf_monitor_lst);
+	xf86addModes(   ks, root, cptr->conf_modes_lst); 
+	xf86addLayout(  ks, root, cptr->conf_layout_lst);
+	xf86addModules( ks, root, cptr->conf_modules);
+	xf86addScreens( ks, root, cptr->conf_screen_lst);
+	xf86addDRI(     ks, root, cptr->conf_dri); 
+
+	if (ksGetSize(ks) == 0) {
+		xf86conffree(ks);
+		ks=0;
+	}
+
+	return ks;
+}
diff -Naur xc.orig/programs/Xserver/hw/xfree86/parser/elektra.h xc/programs/Xserver/hw/xfree86/parser/elektra.h
--- xc.orig/programs/Xserver/hw/xfree86/parser/elektra.h	1970-01-01 01:00:00.000000000 +0100
+++ xc/programs/Xserver/hw/xfree86/parser/elektra.h	2006-03-11 16:09:00.000000000 +0100
@@ -0,0 +1,61 @@
+/* $Id$ */
+
+
+/*
+ * Copyright (c) 2004 by Avi Alkalay <avi at unix.sh>
+ *
+ * The Elektra Project :: http://elektra.sourceforge.net
+ *
+ */
+
+/*
+ * Copyright (c) 1997-2003 by The XFree86 Project, Inc.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE COPYRIGHT HOLDER(S) OR AUTHOR(S) BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ *
+ * Except as contained in this notice, the name of the copyright holder(s)
+ * and author(s) shall not be used in advertising or otherwise to promote
+ * the sale, use or other dealings in this Software without prior written
+ * authorization from the copyright holder(s) and author(s).
+ */
+
+
+/* 
+ * This file contains the external interfaces for the X.org configuration
+ * based on a Key Database (Elektra).
+ */
+ 
+#ifndef _elektra_h_
+#define _elektra_h_
+
+
+
+#include "xf86Parser.h"
+#include <kdb.h> /* Elektra */
+
+/* Grab the configuration and put in X internal structs */
+extern XF86ConfigPtr xf86getConfigKeys (const char *rootKey);
+
+
+/* Convert X internal structs to Elektra Keys */
+extern KeySet *xf86collectConfigKeys (const char *root, XF86ConfigPtr);
+
+
+#endif /* _elektra_h_ */
+
diff -Naur xc.orig/programs/Xserver/hw/xfree86/parser/Imakefile xc/programs/Xserver/hw/xfree86/parser/Imakefile
--- xc.orig/programs/Xserver/hw/xfree86/parser/Imakefile	2006-03-11 18:15:38.000000000 +0100
+++ xc/programs/Xserver/hw/xfree86/parser/Imakefile	2006-03-19 09:41:00.000000000 +0100
@@ -16,7 +16,12 @@
 DBMALLOCDEFINE=-DDBMALLOC
 #endif
 
-SYS_LIBRARIES = MathLibrary
+#if defined(UseElektra)
+ELEKTRA_LIBRARIES=-L/lib -lelektra
+#endif
+
+SYS_LIBRARIES = MathLibrary  $(ELEKTRA_LIBRARIES)
+
 
 XCONFIGFILE = XConfigFile
 XCONFIGDIR = XConfigDir
@@ -37,6 +42,11 @@
 	Video.o Monitor.o Pointer.o Screen.o Vendor.o read.o scan.o write.o \
 	DRI.o Extensions.o
 
+#if defined(UseElektra)
+SRCS += elektra.c
+OBJS += elektra.o
+#endif
+
 CONFIG_DEFINES = -DXCONFIGDIR=\"$(XCONFIGDIR)\" \
 		 -DXCONFIGFILE=\"$(XCONFIGFILE)\" \
 		 -DXVERSION="$(XVERS)"
@@ -44,10 +54,15 @@
 #define IncludeSharedObjectInNormalLib
 
 #include <Library.tmpl>
-
+#ifdefined(UseElektra)
+SpecialCObjectRule(elektra,NullParameter,$(CONFIG_DEFINES) -DMODULE_DIR=\"$(MODULEDIR)\" $(EXT_DEFINES) $(PICFLAGS))
 SpecialCObjectRule(scan,NullParameter,$(CONFIG_DEFINES) $(MODULEDEFINES) $(EXT_DEFINES) $(PICFLAGS))
 
 NormalProgramTarget(cpconfig,cpconfig.o $(OBJS),NullParameter,$(LOCAL_LIBRARIES),NullParameter)
-
+NormalProgramTarget(xelektrify,xelektrify.o $(OBJS),NullParameter,$(LOCAL_LIBRARIES),NullParameter)
+																															    
 AllTarget(ProgramTargetName(cpconfig))
+#if defined(UseElektra)
+AllTarget(ProgramTargetName(xelektrify))
+#endif
 DependTarget()
diff -Naur xc.orig/programs/Xserver/hw/xfree86/parser/README.Elektra xc/programs/Xserver/hw/xfree86/parser/README.Elektra
--- xc.orig/programs/Xserver/hw/xfree86/parser/README.Elektra	1970-01-01 01:00:00.000000000 +0100
+++ xc/programs/Xserver/hw/xfree86/parser/README.Elektra	2006-03-11 16:09:00.000000000 +0100
@@ -0,0 +1,206 @@
+ELEKTRIFYIED X.ORG: PRECISE AND PROGRAMATICALLY EASY X CONFIGURATION       |
+
+   Your X server has to work with your installed video card, monitor, find
+   your font server and dirs, modules, extensions, drivers, plugins.
+   You have to tell him how to integrate it all through its xorg.conf file.
+   If you need to change something, you start a text editor and use your
+   human brain and eyes to find the correct line, understand it, have the
+   skills to change it, and change it in order to work.
+   
+   This is good for advanced technical guys, but very bad for people that
+   don't have this skills, and in fact, don't really want to. He just
+   wants to change the screen resolution to make that projector work with his
+   laptop, and go ahead with his sales presentation. This is just an example.
+   
+   The point is: it is very difficult to make simple programs or scripts
+   that make simple changes to X configuration. Another example is a monitor
+   vendor that wants to support X, and for this he'd like to provide easy
+   installation of his product, without having to ask his user to read
+   documentation about horizontal Sync, and vertical refresh rates. For him
+   again is difficult to write some simple software that preciselly changes X
+   configuration to work correctly with his product.
+   
+   The xorg.conf file (as most Unix configuration files) was designed for
+   human beings.
+   
+   The Elektra Project (http://elektra.sourceforge.net) introduces a new way
+   to handle configurations through a clean API (or command line
+   tool) that accesses atomic configuration data, into a standarized
+   hierarchycal tree of key-value pairs. It is similar to GConf, but
+   designed for system-wide use, which also implies it does not have
+   dependencies.
+   
+   And this is what this patch is about: to make the X server look for its
+   configurations into a machine-ready tree of key-value pairs, instead of
+   the human-ready xorg.conf.
+  
+   So where you had to look for "Device radeon" into a "Section Device",
+   with the key/value tree, X and other programs can look for it
+   preciselly at
+   
+      system/sw/xorg/current/Devices/Videocard0/Driver = radeon
+
+   
+   Where you once had to "vi" your "Section Monitor", now X and other
+   programs can do it accessing the keys:
+   
+      system/sw/xorg/current/Monitors/Monitor0/HorizSync = 31.5 - 48.5
+      system/sw/xorg/current/Monitors/Monitor0/VertRefresh = 40.0 - 70.0
+      system/sw/xorg/current/Monitors/Monitor0/ModelName = IBM T40 LCD Panel
+      system/sw/xorg/current/Monitors/Monitor0/VendorName = IBM
+      system/sw/xorg/current/Monitors/Monitor0/Options/dpms
+  
+   
+   Where once the salesman above had to "vi" the Screen Section to change
+   the resolution, color depth, etc, a program can help him accessing:
+   
+      system/sw/xorg/current/Screens/Screen0/Displays/00/Depth=24
+      system/sw/xorg/current/Screens/Screen0/Displays/00/Modes=1024x768
+
+   
+   And so on....
+   
+   We believe an elektrified X server can leverage more plug-and-play
+   configurations, providing configuration power to HW vendors in a
+   very simple way, and making users experience less painfull.
+   
+   
+
+   
+      
+
+BEHAVIOR OF AN ELEKTRIFIED X SERVER
+
+   A patched X server will look for its configuration keys under the
+   namespace:
+   
+      system/sw/xorg/current   first, then if not found it tries
+      system/sw/xorg
+      
+   If not found, it will default to some xorg.conf file, parse it, and store
+   in its internal structures, then convert and commit it to a set of
+   keys under system/sw/xorg/current, and reload these keys.
+   
+   So you get automatic one-time conversion from xorg.conf to the
+   hierarchycal configuration key/value pairs 
+   
+   Very complex examples of xorg.conf files were tested for conversion. Even
+   undocumented configuration parameters (because the original source was
+   used as the reference).
+   
+   The Elektrifyied X server also works for the Red Hat Graphical Boot,
+   where you still don't have mounted partitions, network, etc.
+
+   
+      
+
+
+ELEKTRIFING X.ORG
+
+   You'll need the elektra-devel package installed in order to build X with
+   Elektra support.
+
+     1. Download and unpack X.org source code from
+     2. Download the xorg-x11-6.8.1-elektra.patch file from 
+     3. Apply it:
+         ~/src/xc$ cd ..
+         ~/src$ patch -p0 < xorg-x11-6.8.1-elektra.patch
+         ~/src$ cd xc
+         ~/src/xc$ # ...configure your build in host.def
+     4. Enable the patch:
+         ~/src/xc$ echo “#define UseElektra” >> config/cf/host.def
+     5. Build X.Org
+
+   You'll find the new X server as file xc/programs/Xserver/Xorg .
+   
+   The patch will add the following files:
+
+      xc/programs/Xserver/hw/xfree86/parser/
+        elektra.h (exported methods)
+        elektra.c (key fetching and X structs integration business logic)
+        xorg-example.conf (a very complex conf file to test conversion)
+        xelektrify.c (cmd to convert xorg.conf->keys and vice-versa)
+        README.Elektra (this file)
+   
+   And it will instrument 
+   xc/programs/Xserver/hw/xfree86/common/xf86Config.c::xf86HandleConfigFile()
+   to trigger the one-time conversion, and key fetching logic.
+   
+   And instrument the Imakefiles for correct builds:
+   
+      xc/programs/Xserver/hw/xfree86/parser/Imakefile
+      xc/programs/Xserver/hw/xfree86/common/Imakefile
+      xc/programs/Xserver/Imakefile
+      
+   If "#define UseElektra" is not present in host.def, the patch is
+   completelly disabled, and you'll get a binary-identicall built as before
+   applying the patch. All patched code are surrounded by #ifdefs.
+
+   
+   
+      
+
+ELEKTRA MEETS X.ORG SOURCE CODE
+or how we wrote the patch....
+
+   X.org has an xorg.conf parser that takes this steps to handle
+   configuration:
+   
+      1. Lexically parse the xorg.conf file
+      2. Put each Section info in an equivalent struct
+      3. Encapsulate all structs together and pass them to a validator
+      4. Use structs to define X behavior
+
+   This process is triggered by the xf86HandleConfigFile() method from
+   
+      xc/programs/Xserver/hw/xfree86/common/xf86Config.c
+   
+   Each xorg.conf Section has an equivalent structure defined in
+
+      xc/programs/Xserver/hw/xfree86/parser/xf86Parser.h
+      
+   and the lexycall analyzer code to parse each Section is under
+   
+      xc/programs/Xserver/hw/xfree86/parser/
+   
+   A fully parsed file has its equivalent structures encapsulated in a
+   parent XF86Config struct. We have:
+   
+      struct XF86ConfModuleRec for the "Section Modules"
+      struct XF86ConfMonitorRec for the "Section Monitor"
+      struct XF86ConfDeviceRec for the "Section Device"
+      etc...
+      
+   These structs are a pure computer representation of the text in each
+   Section, so the methods under "parser/" convert text to structs, and
+   the structs to text. This is how original X.org source handles xorg.conf.
+   
+   The Elektrification add methods that act in steps 1 and 2 above. And also
+   include methods to convert each struct to a KeySet. Both old (xorg.conf)
+   and new (Elektra) ways to get configuration information can live together
+   and they are actually used to automatically convert xorg.conf to keys. So
+   at the first time you'll run your elektrified X server, it will:
+
+      1. Not find configuration keys (because it is the first time)
+      2. Parse xorg.conf into structs
+      3. Convert structs to Keys
+      4. Commit the keys to key database
+      5. Reload configurations from the key database
+
+   See the behavior in the previous section.
+      
+   After assembling the XF86Config C structure, X will decode all its info
+   into more practicall parameters for its further operation.
+   
+   As a side note, with a key/value pair configuration hierarchy paradigm,
+   the XF86Config assembling code (the parser) could be avoided, making X
+   look for its configurations in a programatically easier, yet
+   human-readable, configuration organization.
+   We worked at the parser level to keep compatibility and to not go too
+   deep in X.org source code.
+
+   
+http://elektra.sourceforge.net
+The Elektra Project
+Avi Alkalay
+November 2004
\ Pas de fin de ligne à la fin du fichier.
diff -Naur xc.orig/programs/Xserver/hw/xfree86/parser/xelektrify.c xc/programs/Xserver/hw/xfree86/parser/xelektrify.c
--- xc.orig/programs/Xserver/hw/xfree86/parser/xelektrify.c	1970-01-01 01:00:00.000000000 +0100
+++ xc/programs/Xserver/hw/xfree86/parser/xelektrify.c	2006-03-11 16:09:00.000000000 +0100
@@ -0,0 +1,308 @@
+/* $XFree86: xc/programs/Xserver/hw/xfree86/parser/cpconfig.c,v 1.6 2000/10/20 14:59:03 alanh Exp $ */
+/* 
+ * 
+ * Copyright (c) 1997  Metro Link Incorporated
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"), 
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ * 
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE X CONSORTIUM BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+ * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF
+ * OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
+ * SOFTWARE.
+ * 
+ * Except as contained in this notice, the name of the Metro Link shall not be
+ * used in advertising or otherwise to promote the sale, use or other dealings
+ * in this Software without prior written authorization from Metro Link.
+ * 
+ */
+
+/* View/edit this file with tab stops set to 4 */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <stdarg.h>
+#include <ctype.h>
+#include <unistd.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <fcntl.h>
+#include "xf86Parser.h"
+#include "configProcs.h"
+#include "elektra.h"
+
+#ifdef MALLOC_FUNCTIONS
+void
+xfree (void *p)
+{
+	free (p);
+	return;
+}
+
+void *
+xalloc (int size)
+{
+	return malloc (size);
+}
+
+void *
+xrealloc (void *p, int size)
+{
+	return realloc (p, size);
+}
+
+#endif
+
+#define CONFPATH "%A,%R,/etc/X11/%R,%P/etc/X11/%R,%E,%F,/etc/X11/%F," \
+		 "%P/etc/X11/%F,%D/%X,/etc/X11/%X,/etc/%X,%P/etc/X11/%X.%H," \
+		 "%P/etc/X11/%X,%P/lib/X11/%X.%H,%P/lib/X11/%X"
+
+
+/**Some systems have even longer pathnames*/
+#ifdef PATH_MAX
+#define MAX_PATH_LENGTH PATH_MAX
+/**This value is garanteed on any Posixsystem*/
+#elif __USE_POSIX
+#define MAX_PATH_LENGTH _POSIX_PATH_MAX
+#else 
+#define MAX_PATH_LENGTH 4096
+#endif
+                          
+
+int conf2kdb;
+int xml;
+char gxorgconf[500]="";
+char grootkey[500]="";
+
+
+int
+parseCommandLine(int argc, char *argv[]) {
+	int fromApeared=0;
+	int opt;
+
+	while ((opt=getopt(argc,argv,"c:k:fx"))!=-1) {
+		switch (opt) {
+			case 'x':
+				xml=1;
+				break;
+			case 'c':
+				if (fromApeared) {
+					conf2kdb=1;
+					fromApeared=0;
+				}
+				strncpy(gxorgconf,optarg,sizeof(gxorgconf));
+				break;
+			case 'k':
+				if (fromApeared) {
+					conf2kdb=-1;
+					fromApeared=0;
+				}
+				strncpy(grootkey,optarg,sizeof(grootkey));
+				break;
+			case 'f':
+				fromApeared=1;
+				break;
+		}
+	}
+	
+	/* Verify and set some defaults */
+	if (conf2kdb == 0) conf2kdb=1;
+	
+	return 0;
+}
+
+
+int
+convert(int direction,char *xc,char *rk) {
+	KDBHandle handle;
+	const char *filename;
+	XF86ConfigPtr conf;
+	KeySet *ks=0;
+	char xorgconf[500]="";
+	char rootkey[500]="";
+	
+	if (direction == 1) {
+		
+		fprintf(stderr,"Converting a configuration file to a key database...\n");
+		if ((filename = xf86openConfigFile (CONFPATH, xc, NULL))) {
+			fprintf (stderr, "Opened %s for the config file\n", filename);
+		} else {
+			fprintf (stderr, "Unable to open config file\n");
+			return 1;
+		}
+
+		if ((conf = xf86readConfigFile ()) == NULL)
+			fprintf (stderr, "Problem when parsing config file\n");
+		xf86closeConfigFile ();
+		
+		/* Check if we have a good rootkey */
+		if (rk) strcpy(rootkey,rk);
+		else {
+			/* Defaults to our standard */
+			strcpy(rootkey,"system/sw/xorg/current");
+		}
+		
+		/* Put the in-memory X configurations in a KeySet, also in memory */
+		ks=xf86collectConfigKeys(rootkey,conf);
+		
+		if (xml) {
+			/* We only want an XML output */
+			ksToStream(ks,stdout,KDB_O_XMLHEADERS);
+		} else {
+			int ret; 
+			
+			/* Really commit to the Key database */
+			kdbOpen(&handle);
+			fprintf(stderr,"Writing X.org configuration keys to %s\n",rootkey);
+			ksRewind(ks);
+			ret=kdbSetKeys(handle, ks);
+			if (ret != 0) {
+				Key *problem;
+				char error[500];
+				char keyname[300]="";
+		
+				problem=ksCurrent(ks);
+				if (problem) keyGetFullName(problem,keyname,sizeof(keyname));
+				sprintf(error,"Error when commiting %s",keyname);
+				perror(error);
+			}
+			kdbClose(&handle);
+			ksClose(ks);
+		}
+		
+	} else if (direction == -1) {
+		fprintf(stderr,"Converting a key database to a configuration file...\n");
+		
+		/* Check if we have a good rootkey */
+		if (rk) strcpy(rootkey,rk);
+		else {
+			/* Defaults to our standard */
+			strcpy(rootkey,"system/sw/xorg/current");
+		}
+		
+		conf=xf86getConfigKeys(rootkey);
+		
+		if (xc) {
+			fprintf(stderr, "Writing config file to `%s'\n", xc);
+			xf86writeConfigFile (xc, conf);
+		} else {
+			/* use stdout */
+			int fd;
+			ssize_t bytes;
+			char buffer[500];
+
+			strcpy(xorgconf,"/var/tmp/xorgconfXXXXXX");
+			
+			fd=mkstemp(xorgconf);
+			close(fd);
+			
+			xf86writeConfigFile (xorgconf, conf);
+			
+			fd=open(xorgconf,O_RDONLY);
+			if (fd) {
+				bytes=1;
+				while (bytes>0) {
+					bytes=read(fd,buffer,sizeof(buffer));
+					write(fileno(stdout),buffer,bytes);
+				}
+			}
+			
+			close(fd);
+			remove(xorgconf);
+		}
+	}
+}
+
+
+int
+main (int argc, char *argv[])
+{
+	char *xorgconf=0,*rootkey=0;
+
+	parseCommandLine(argc,argv);
+	
+	if (*gxorgconf) xorgconf=gxorgconf;
+	if (*grootkey) rootkey=grootkey;
+	
+	convert(conf2kdb,xorgconf,rootkey);
+
+/*	
+	const char *filename;
+	char *cmdline = NULL;
+	XF86ConfigPtr conf;
+	KeySet *ks;
+
+	fprintf(stderr,"Reading Xorg config keys\n");
+	conf=xf86getConfigKeys(argv[1]);
+	fprintf(stderr,"Xorg config keys read\n");
+*/
+/*	
+	if (argc > 1)
+	{
+		cmdline = argv[1];
+	}
+	if ((filename = xf86openConfigFile (CONFPATH, cmdline, NULL)))
+	{
+		fprintf (stderr, "Opened %s for the config file\n", filename);
+	}
+	else
+	{
+		fprintf (stderr, "Unable to open config file\n");
+		exit (1);
+	}
+
+	if ((conf = xf86readConfigFile ()) == NULL)
+	{
+		fprintf (stderr, "Problem when parsing config file\n");
+	}
+	else
+	{
+		fprintf (stderr, "Config file parsed OK\n");
+	}
+	xf86closeConfigFile ();
+*/                      
+/*
+	if (argc > 2) {
+		fprintf(stderr, "Writing config file to `%s'\n", argv[2]);
+		xf86writeConfigFile (argv[2], conf);
+	}
+*/
+/*
+	fprintf(stderr,"Writing config in old Xorg.conf format\n");
+	xf86writeConfigFile ("xis", conf);
+*/
+/*
+	ks=xf86collectConfigKeys("user/tmp/xorg",conf);
+
+	ksToStream(ks,stdout,KDB_O_XMLHEADERS);
+*/
+	exit(0);
+}
+
+/* Functions that the parser requires */
+
+void
+VErrorF(const char *f, va_list args)
+{
+	vfprintf(stderr, f, args);
+}
+
+void
+ErrorF(const char *f, ...)
+{
+	va_list args;
+
+	va_start(args, f);
+	vfprintf(stderr, f, args);
+	va_end(args);
+}
diff -Naur xc.orig/programs/Xserver/hw/xfree86/parser/xorg-example.conf xc/programs/Xserver/hw/xfree86/parser/xorg-example.conf
--- xc.orig/programs/Xserver/hw/xfree86/parser/xorg-example.conf	1970-01-01 01:00:00.000000000 +0100
+++ xc/programs/Xserver/hw/xfree86/parser/xorg-example.conf	2006-03-11 16:09:00.000000000 +0100
@@ -0,0 +1,275 @@
+Section "ServerLayout"
+    Identifier  "Simple Layout"
+    Screen "Screen 2"
+    Screen "Screen 1" Rightof "Screen 2"
+    InputDevice "Mouse1" "CorePointer"
+    InputDevice "Keyboard1" "CoreKeyboard"
+EndSection
+
+
+
+
+
+Section "ServerLayout"
+    Identifier  "Other Layout"
+    Screen "Screen 2"
+    Screen "Screen 1" Relative "Screen 2" 1200 0
+    InputDevice "Mouse1" "CorePointer"
+    InputDevice "Keyboard1" "CoreKeyboard"
+EndSection
+
+
+
+
+
+
+Section "Module"
+    Load        "dbe"   # Double buffer extension
+    SubSection  "extmod"
+      Option    "omit xfree86-dga"   # don't initialise the DGA extension
+    EndSubSection
+    Load        "type1"
+    Load        "freetype"
+# This loads the GLX module
+#    Load       "glx"
+EndSection
+
+
+
+
+
+Section "Files"
+    RgbPath     "/usr/X11R6/lib/X11/rgb"
+    FontPath   "/usr/X11R6/lib/X11/fonts/local/"
+    FontPath   "/usr/X11R6/lib/X11/fonts/misc/"
+    FontPath   "/usr/X11R6/lib/X11/fonts/75dpi/:unscaled"
+    FontPath   "/usr/X11R6/lib/X11/fonts/100dpi/:unscaled"
+    FontPath   "/usr/X11R6/lib/X11/fonts/Type1/"
+    FontPath   "/usr/X11R6/lib/X11/fonts/Speedo/"
+    FontPath   "/usr/X11R6/lib/X11/fonts/75dpi/"
+    FontPath   "/usr/X11R6/lib/X11/fonts/100dpi/"
+# The module search path.  The default path is shown here.
+#   ModulePath "/usr/X11R6/lib/modules"
+EndSection
+
+
+
+
+
+Section "ServerFlags"
+       Option "BlankTime" "10"
+       Option "HandleSpecialKeys" "WhenNeeded"
+EndSection
+
+
+
+
+
+
+Section "InputDevice"
+    Identifier  "Keyboard1"
+    Driver      "Keyboard"
+    Option "AutoRepeat" "500 30"
+    Option "XkbRules"   "xfree86"
+    Option "XkbModel"   "pc101"
+    Option "XkbLayout"  "us"
+EndSection
+
+
+
+
+
+Section "InputDevice"
+    Identifier  "Mouse1"
+    Driver      "mouse"
+    Option "Protocol"    "PS/2"
+    Option "Device"      "/dev/psaux"
+EndSection
+
+
+
+
+
+
+
+Section "Monitor"
+    Identifier  "Mini"
+    HorizSync   31.5
+    VertRefresh 50-90
+    Modeline "1280x1024@100" 190.960 1280 1376 1520 1760 1024 1025 1028 1085 +hsync +vsync
+    Modeline "GDM-1950"  109.62  1280 1336 1472 1720  1024 1024 1026 1062 -hsync -vsync
+       ModeLine     "1600x1000" 133.1 1600 1704 1872 2144 1000 1001 1004 1035 +hsync +vsync
+EndSection
+
+
+
+
+
+Section "Monitor"
+    Identifier  "Impression"
+    HorizSync   31.5 - 82.0
+    VertRefresh 50-100
+    Modeline "640x480@100" 43.163 640 680 744 848 480 481 484 509 +hsync +vsync
+    Modeline "1152x864@100" 143.472 1152 1232 1360 1568 864 865 868 915 +hsync +vsync
+       ModeLine     "1152x864@100" 143.5 1152 1232 1360 1568 864 865 868 915 +hsync +vsync
+EndSection
+
+
+
+Section "Modes"
+       Identifier     "Some mode for you"
+       ModeLine     "1920x1080" 172.8 1920 2040 2248 2576 1080 1081 1084 1118 -hsync -vsync
+       ModeLine     "2048x1536" 267.0 2048 2200 2424 2800 1536 1537 1540 1589 +hsync +vsync
+EndSection
+
+
+
+
+Section "Modes"
+       Identifier     "Other mode"
+       ModeLine     "1600x1000" 133.1 1600 1704 1872 2144 1000 1001 1004 1035 +hsync +vsync
+       ModeLine     "1920x2400@30" 149.2 1920 1928 1982 2044 2400 2402 2404 2434 +hsync +vsync
+EndSection
+
+
+
+
+
+Section "Device"
+       Identifier  "ATI Graphics Adapter"
+       Driver      "fglrx"
+       ChipId      0x0
+       ChipRev     0x0
+       Option      "BlockSignalsOnLock" "on"
+       Option      "Capabilities" "0x00000000"
+
+       Option      "CenterMode" "off"
+
+       Option      "DesktopSetup" "0x00000000"
+       Option      "FSAACustomizeMSPos" "no"
+       Option      "FSAADisableGamma" "no"
+       Option      "FSAAEnable" "no"
+       Option      "FSAAMSPosX0" "0.000000"
+       Option      "FSAAMSPosX1" "0.000000"
+       Option      "FSAAMSPosX2" "0.000000"
+       Option      "FSAAMSPosX3" "0.000000"
+       Option      "FSAAMSPosX4" "0.000000"
+       Option      "FSAAMSPosX5" "0.000000"
+       Option      "FSAAMSPosY0" "0.000000"
+       Option      "FSAAMSPosY1" "0.000000"
+       Option      "FSAAMSPosY2" "0.000000"
+       Option      "FSAAMSPosY3" "0.000000"
+       Option      "FSAAMSPosY4" "0.000000"
+       Option      "FSAAMSPosY5" "0.000000"
+
+       Option      "FSAAScale" "1"
+       Option      "ForceGenericCPU" "no"
+       Option      "GammaCorrectionI" "0x00000000"
+       Option      "GammaCorrectionII" "0x00000000"
+
+       Option      "HSync2" "unspecified"
+       Option      "IgnoreEDID" "off"
+       Option      "MonitorLayout" "AUTO, AUTO"
+       Option      "NoTV" "yes"
+       Option      "OpenGLOverlay" "off"
+
+       Option      "PseudoColorVisuals" "off"
+
+       Option      "ScreenOverlap" "0"
+
+       Option      "Stereo" "off"
+       Option      "StereoSyncEnable" "1"
+
+       Option      "TVColorAdj" "0"
+       Option      "TVHPosAdj" "0"
+       Option      "TVHSizeAdj" "0"
+       Option      "TVHStartAdj" "0"
+       Option      "TVStandard" "NTSC-M"
+       Option      "TVVPosAdj" "0"
+       Option      "TVVSizeAdj" "0"
+       Option      "UseFastTLS" "0"
+       Option      "UseInternalAGPGART" "no"
+       Option      "VRefresh2" "unspecified"
+       Option      "VideoOverlay" "on"
+
+       Option      "mtrr" "off" # disable DRI mtrr mapper, driver has its own code for mtrr
+
+       Option      "no_accel" "no"
+       Option      "no_dri" "no"
+
+       BusID       "PCI:2:0:0"
+       IRQ         0
+EndSection
+
+
+
+
+
+# Video Card #1, Matrox Millenium II PCI Video Card
+Section "Device"
+    Identifier  "Matrox"
+    Driver      "mga"
+    VideoRam 8192
+    BusID      "PCI:0:12:0"
+EndSection
+
+
+
+
+
+
+# Video Card # 2, Fire GL 1000 AGP video card.
+Section "Device"
+    Identifier  "FireGL"
+    Driver      "glint"
+    #VideoRam    8192
+    BusID      "PCI:1:0:0"
+
+EndSection
+
+
+
+
+Section "Screen"
+    Identifier  "Screen 2"
+    Device      "FireGL"
+    Monitor     "Impression"
+    DefaultDepth 16
+
+    Subsection "Display"
+        Depth       16
+        Modes       "1280x1024" "640x480"
+        ViewPort    0 0
+    EndSubsection
+EndSection
+
+
+
+
+# My Miniature monitor,  notice that I used the virtual option so it is
+#   the same heighth as the larger monitor,  this is not necessary.
+Section "Screen"
+    Identifier  "Screen 1"
+    Device      "Matrox"
+    Monitor     "Mini"
+    DefaultDepth 16
+
+    Subsection "Display"
+        Depth       16
+        Modes       "640x480"
+        ViewPort    0 0
+        Virtual     640 1024
+    EndSubsection
+EndSection
+
+
+
+
+
+Section "DRI"
+        Group        0
+        Mode         0666
+               Buffers      20 10 flag1
+               Buffers      40 30 flag2
+EndSection
+
diff -Naur xc.orig/programs/Xserver/Imakefile xc/programs/Xserver/Imakefile
--- xc.orig/programs/Xserver/Imakefile	2006-03-11 18:15:42.000000000 +0100
+++ xc/programs/Xserver/Imakefile	2006-03-11 16:09:00.000000000 +0100
@@ -319,6 +319,12 @@
 #endif
         SYSLIBS = $(ZLIB) MathLibrary Krb5Libraries $(DBMLIBS) $(USB) \
 		  $(PAMLIBS)  $(XAUTHLIB) $(XDMCPLIB) $(EXTRASYSLIBS)
+
+#if defined(UseElektra)
+ELEKTRA_LIBS=-L/lib -lelektra
+SYSLIBS += $(ELEKTRA_LIBS)
+#endif
+
 #if !HasCbrt
            CBRT = mi/LibraryTargetName(cbrt)
 #endif
