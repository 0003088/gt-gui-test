diff -Naur kdelibs-3.5.2.orig/kdecore/kconfigbackend.cpp kdelibs-3.5.2/kdecore/kconfigbackend.cpp
--- kdelibs-3.5.2.orig/kdecore/kconfigbackend.cpp	2005-10-10 17:06:02.000000000 +0200
+++ kdelibs-3.5.2/kdecore/kconfigbackend.cpp	2006-05-08 19:08:43.000000000 +0200
@@ -15,8 +15,12 @@
 
   You should have received a copy of the GNU Library General Public License
   along with this library; see the file COPYING.LIB.  If not, write to
-  the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-  Boston, MA 02110-1301, USA.
+  the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+  Boston, MA 02111-1307, USA.
+
+  Yannick Lecaillez - <yl@itioweb.com>
+  Elektra support added. KConfigBackEnd act now as a wrapper for
+  configuration parser.
 */
 
 #include <config.h>
@@ -40,6 +44,8 @@
 #include <qtextstream.h>
 
 #include "kconfigbackend.h"
+#include "kconfigparser.h"
+#include "kconfigparserfactory.h"
 #include "kconfigbase.h"
 #include <kapplication.h>
 #include <kglobal.h>
@@ -50,1066 +56,135 @@
 #include <kurl.h>
 #include <kde_file.h>
 
-extern bool checkAccess(const QString& pathname, int mode);
-/* translate escaped escape sequences to their actual values. */
-static QCString printableToString(const char *str, int l)
-{
-  // Strip leading white-space.
-  while((l>0) &&
-        ((*str == ' ') || (*str == '\t') || (*str == '\r')))
-  {
-     str++; l--;
-  }
-
-  // Strip trailing white-space.
-  while((l>0) &&
-        ((str[l-1] == ' ') || (str[l-1] == '\t') || (str[l-1] == '\r')))
-  {
-     l--;
-  }
-
-  QCString result(l + 1);
-  char *r = result.data();
-
-  for(int i = 0; i < l;i++, str++)
-  {
-     if (*str == '\\')
-     {
-        i++, str++;
-        if (i >= l) // End of line. (Line ends with single slash)
-        {
-           *r++ = '\\';
-           break;
-        }
-        switch(*str)
-        {
-           case 's':
-              *r++ = ' ';
-              break;
-           case 't':
-              *r++ = '\t';
-              break;
-           case 'n':
-              *r++ = '\n';
-              break;
-           case 'r':
-              *r++ = '\r';
-              break;
-           case '\\':
-              *r++ = '\\';
-              break;
-           default:
-              *r++ = '\\';
-              *r++ = *str;
-        }
-     }
-     else
-     {
-        *r++ = *str;
-     }
-  }
-  result.truncate(r-result.data());
-  return result;
-}
-
-static QCString stringToPrintable(const QCString& str){
-  QCString result(str.length()*2); // Maximum 2x as long as source string
-  register char *r = result.data();
-  register char *s = str.data();
-
-  if (!s) return QCString("");
-
-  // Escape leading space
-  if (*s == ' ')
-  {
-     *r++ = '\\'; *r++ = 's';
-     s++;
-  }
-
-  if (*s)
-  {
-   while(*s)
-   {
-    if (*s == '\n')
-    {
-      *r++ = '\\'; *r++ = 'n';
-    }
-    else if (*s == '\t')
-    {
-      *r++ = '\\'; *r++ = 't';
-    }
-    else if (*s == '\r')
-    {
-      *r++ = '\\'; *r++ = 'r';
-    }
-    else if (*s == '\\')
-    {
-      *r++ = '\\'; *r++ = '\\';
-    }
-    else
-    {
-      *r++ = *s;
-    }
-    s++;
-   }
-   // Escape trailing space
-   if (*(r-1) == ' ')
-   {
-      *(r-1) = '\\'; *r++ = 's';
-   }
-  }
-
-  result.truncate(r - result.data());
-  return result;
-}
+#include <kdb.h>
 
-static QCString decodeGroup(const char*s, int l)
-{
-  QCString result(l);
-  register char *r = result.data();
+class KConfigParser;
 
-  l--; // Correct for trailing \0
-  while(l)
-  {
-    if ((*s == '[') && (l > 1))
-    {
-       if ((*(s+1) == '['))
-       {
-          l--;
-          s++;
-       }
-    }
-    if ((*s == ']') && (l > 1))
-    {
-       if ((*(s+1) == ']'))
-       {
-          l--;
-          s++;
-       }
-    }
-    *r++ = *s++;
-    l--;
-  }
-  result.truncate(r - result.data());
-  return result;
-}
-
-static QCString encodeGroup(const QCString &str)
+KConfigBackEnd::KConfigBackEnd(KConfigBase *_config,
+			       const QString &_fileName,
+			       const char * _resType,
+			       bool _useKDEGlobals)
+  : pConfig(_config), mFileMode(-1)
 {
-  int l = str.length();
-  QCString result(l*2+1);
-  register char *r = result.data();
-  register char *s = str.data();
-  while(l)
-  {
-    if ((*s == '[') || (*s == ']'))
-       *r++ = *s;
-    *r++ = *s++;
-    l--;
-  }
-  result.truncate(r - result.data());
-  return result;
+   mParser = NULL;
+   changeFileName(_fileName, _resType, _useKDEGlobals);
 }
 
-class KConfigBackEnd::KConfigBackEndPrivate
-{
-public:
-   QDateTime localLastModified;
-   uint      localLastSize;
-   KLockFile::Ptr localLockFile;
-   KLockFile::Ptr globalLockFile;
-};
-
 void KConfigBackEnd::changeFileName(const QString &_fileName,
                                     const char * _resType,
                                     bool _useKDEGlobals)
 {
-   mfileName = _fileName;
-   resType = _resType;
-   useKDEGlobals = _useKDEGlobals;
-   if (mfileName.isEmpty())
-      mLocalFileName = QString::null;
-   else if (!QDir::isRelativePath(mfileName))
-      mLocalFileName = mfileName;
-   else
-      mLocalFileName = KGlobal::dirs()->saveLocation(resType) + mfileName;
-
-   if (useKDEGlobals)
-      mGlobalFileName = KGlobal::dirs()->saveLocation("config") +
-	      QString::fromLatin1("kdeglobals");
-   else
-      mGlobalFileName = QString::null;
-
-   d->localLastModified = QDateTime();
-   d->localLastSize = 0;
-   d->localLockFile = 0;
-   d->globalLockFile = 0;
-}
 
-KLockFile::Ptr KConfigBackEnd::lockFile(bool bGlobal)
-{
-   if (bGlobal)
-   {
-      if (d->globalLockFile)
-         return d->globalLockFile;
-      
-      if (!mGlobalFileName.isEmpty())
-      {
-         d->globalLockFile = new KLockFile(mGlobalFileName+".lock");
-         return d->globalLockFile;
-      }
-   }
-   else
-   {
-      if (d->localLockFile)
-         return d->localLockFile;
-      
-      if (!mLocalFileName.isEmpty())
-      {
-         d->localLockFile = new KLockFile(mLocalFileName+".lock");
-         return d->localLockFile;
-      }
-   }
-   return 0;
-}
+	FILE *fp;
 
-KConfigBackEnd::KConfigBackEnd(KConfigBase *_config,
-			       const QString &_fileName,
-			       const char * _resType,
-			       bool _useKDEGlobals)
-  : pConfig(_config), bFileImmutable(false), mConfigState(KConfigBase::NoAccess), mFileMode(-1)
-{
-   d = new KConfigBackEndPrivate;
-   changeFileName(_fileName, _resType, _useKDEGlobals);
+	if ( mParser ) {
+		delete mParser;
+		mParser = NULL;
+	}
+
+	mParser = KConfigParserFactory::create(pConfig, _fileName, _resType, _useKDEGlobals);
+	mParser->setFileImmutable(false);
+	mParser->setConfigState(KConfigBase::NoAccess);
 }
 
-KConfigBackEnd::~KConfigBackEnd()
+KConfigBase::ConfigState KConfigBackEnd::getConfigState()
 {
-   delete d;
+	if ( mParser )
+		return mParser->getConfigState();
+
+	return KConfigBase::NoAccess;
 }
 
-void KConfigBackEnd::setFileWriteMode(int mode)
+void KConfigBackEnd::setConfigState(KConfigBase::ConfigState state)
 {
-  mFileMode = mode;
+	if ( mParser )
+		return mParser->setConfigState(state);
 }
 
-bool KConfigINIBackEnd::parseConfigFiles()
+QString KConfigBackEnd::fileName()
 {
-  // Check if we can write to the local file.
-  mConfigState = KConfigBase::ReadOnly;
-  if (!mLocalFileName.isEmpty() && !pConfig->isReadOnly())
-  {
-     if (checkAccess(mLocalFileName, W_OK))
-     {
-        mConfigState = KConfigBase::ReadWrite;
-     }
-     else
-     {
-        // Create the containing dir, maybe it wasn't there
-        KURL path;
-        path.setPath(mLocalFileName);
-        QString dir=path.directory();
-        KStandardDirs::makeDir(dir);
-
-        if (checkAccess(mLocalFileName, W_OK))
-        {
-           mConfigState = KConfigBase::ReadWrite;
-        }
-     }
-     QFileInfo info(mLocalFileName);
-     d->localLastModified = info.lastModified();
-     d->localLastSize = info.size();
-  }
-
-  // Parse all desired files from the least to the most specific.
-  bFileImmutable = false;
-
-  // Parse the general config files
-  if (useKDEGlobals) {
-    QStringList kdercs = KGlobal::dirs()->
-      findAllResources("config", QString::fromLatin1("kdeglobals"));
-
-#ifdef Q_WS_WIN
-    QString etc_kderc = QFile::decodeName( QCString(getenv("WINDIR")) + "\\kderc" );
-#else
-    QString etc_kderc = QString::fromLatin1("/etc/kderc");
-#endif
-
-    if (checkAccess(etc_kderc, R_OK))
-      kdercs += etc_kderc;
+	if ( mParser )
+		return mParser->fileName();
 
-    kdercs += KGlobal::dirs()->
-      findAllResources("config", QString::fromLatin1("system.kdeglobals"));
-
-    QStringList::ConstIterator it;
+	return "";
+}
 
-    for (it = kdercs.fromLast(); it != kdercs.end(); --it) {
-
-      QFile aConfigFile( *it );
-      if (!aConfigFile.open( IO_ReadOnly ))
-	   continue;
-      parseSingleConfigFile( aConfigFile, 0L, true, (*it != mGlobalFileName) );
-      aConfigFile.close();
-      if (bFileImmutable)
-         break;
-    }
-  }
-
-  bool bReadFile = !mfileName.isEmpty();
-  while(bReadFile) {
-    bReadFile = false;
-    QString bootLanguage;
-    if (useKDEGlobals && localeString.isEmpty() && !KGlobal::_locale) {
-       // Boot strap language
-       bootLanguage = KLocale::_initLanguage(pConfig);
-       setLocaleString(bootLanguage.utf8());
-    }
-
-    bFileImmutable = false;
-    QStringList list;
-    if ( !QDir::isRelativePath(mfileName) )
-       list << mfileName;
-    else
-       list = KGlobal::dirs()->findAllResources(resType, mfileName);
-
-    QStringList::ConstIterator it;
-
-    for (it = list.fromLast(); it != list.end(); --it) {
-
-      QFile aConfigFile( *it );
-      // we can already be sure that this file exists
-      bool bIsLocal = (*it == mLocalFileName);
-      if (aConfigFile.open( IO_ReadOnly )) {
-         parseSingleConfigFile( aConfigFile, 0L, false, !bIsLocal );
-         aConfigFile.close();
-         if (bFileImmutable)
-            break;
-      }
-    }
-    if (KGlobal::dirs()->isRestrictedResource(resType, mfileName))
-       bFileImmutable = true;
-    QString currentLanguage;
-    if (!bootLanguage.isEmpty())
-    {
-       currentLanguage = KLocale::_initLanguage(pConfig);
-       // If the file changed the language, we need to read the file again
-       // with the new language setting.
-       if (bootLanguage != currentLanguage)
-       {
-          bReadFile = true;
-          setLocaleString(currentLanguage.utf8());
-       }
-    }
-  }
-  if (bFileImmutable)
-     mConfigState = KConfigBase::ReadOnly;
+KLockFile::Ptr KConfigBackEnd::lockFile(bool bGlobal)
+{
+	if ( mParser )
+		return mParser->lockFile(bGlobal);
 
-  return true;
+	return 0;
 }
 
-#ifdef HAVE_MMAP
-#ifdef SIGBUS
-static sigjmp_buf mmap_jmpbuf;
-struct sigaction mmap_old_sigact;
-
-extern "C" {
-   static void mmap_sigbus_handler(int)
-   {
-      siglongjmp (mmap_jmpbuf, 1);
-   }
+void KConfigBackEnd::setLocaleString(const QCString &_localeString)
+{
+	if ( mParser )
+		mParser->setLocaleString(_localeString);
 }
-#endif
-#endif
 
-extern bool kde_kiosk_exception;
 
-void KConfigINIBackEnd::parseSingleConfigFile(QFile &rFile,
-					      KEntryMap *pWriteBackMap,
-					      bool bGlobal, bool bDefault)
-{
-   const char *s; // May get clobbered by sigsetjump, but we don't use them afterwards.
-   const char *eof; // May get clobbered by sigsetjump, but we don't use them afterwards.
-   QByteArray data;
-
-   if (!rFile.isOpen()) // come back, if you have real work for us ;->
-      return;
-
-   //using kdDebug() here leads to an infinite loop
-   //remove this for the release, aleXXX
-   //qWarning("Parsing %s, global = %s default = %s",
-   //           rFile.name().latin1(), bGlobal ? "true" : "false", bDefault ? "true" : "false");
-
-   QCString aCurrentGroup("<default>");
-
-   unsigned int ll = localeString.length();
-
-#ifdef HAVE_MMAP
-   static volatile const char *map;
-   map = ( const char* ) mmap(0, rFile.size(), PROT_READ, MAP_PRIVATE,
-                                          rFile.handle(), 0);
-
-   if ( map != MAP_FAILED )
-   {
-      s = (const char*) map;
-      eof = s + rFile.size();
-
-#ifdef SIGBUS
-      struct sigaction act;
-      act.sa_handler = mmap_sigbus_handler;
-      sigemptyset( &act.sa_mask );
-#ifdef SA_ONESHOT
-      act.sa_flags = SA_ONESHOT;
-#else
-      act.sa_flags = SA_RESETHAND;
-#endif      
-      sigaction( SIGBUS, &act, &mmap_old_sigact );
-
-      if (sigsetjmp (mmap_jmpbuf, 1))
-      {
-qWarning("SIGBUS while reading %s", rFile.name().latin1());
-         munmap(( char* )map, rFile.size());
-         sigaction (SIGBUS, &mmap_old_sigact, 0);
-         return;
-      }
-#endif
-   }
-   else
-#endif
-   {
-      rFile.at(0);
-      data = rFile.readAll();
-      s = data.data();
-      eof = s + data.size();
-   }
 
-   bool fileOptionImmutable = false;
-   bool groupOptionImmutable = false;
-   bool groupSkip = false;
-
-   int line = 0;
-   for(; s < eof; s++)
-   {
-      line++;
-
-      while((s < eof) && isspace(*s) && (*s != '\n'))
-         s++; //skip leading whitespace, shouldn't happen too often
-
-      //skip empty lines, lines starting with #
-      if ((s < eof) && ((*s == '\n') || (*s == '#')))
-      {
-    sktoeol:	//skip till end-of-line
-         while ((s < eof) && (*s != '\n'))
-            s++;
-         continue; // Empty or comment or no keyword
-      }
-      const char *startLine = s;
-
-      if (*s == '[')  //group
-      {
-         // In a group [[ and ]] have a special meaning
-         while ((s < eof) && (*s != '\n')) 
-         {
-            if (*s == ']')
-            {
-               if ((s+1 < eof) && (*(s+1) == ']'))
-                  s++; // Skip "]]"
-               else
-                  break;
-            }
-
-            s++; // Search till end of group
-         }
-         const char *e = s;
-         while ((s < eof) && (*s != '\n')) s++; // Search till end of line / end of file
-         if ((e >= eof) || (*e != ']'))
-         {
-            fprintf(stderr, "Invalid group header at %s:%d\n", rFile.name().latin1(), line);
-            continue;
-         }
-         // group found; get the group name by taking everything in
-         // between the brackets
-         if ((e-startLine == 3) &&
-             (startLine[1] == '$') &&
-             (startLine[2] == 'i'))
-         {
-            if (!kde_kiosk_exception)
-               fileOptionImmutable = true;
-            continue;
-         }
-
-         aCurrentGroup = decodeGroup(startLine + 1, e - startLine);
-         //cout<<"found group ["<<aCurrentGroup<<"]"<<endl;
-
-         // Backwards compatibility
-         if (aCurrentGroup == "KDE Desktop Entry")
-            aCurrentGroup = "Desktop Entry";
-
-         groupOptionImmutable = fileOptionImmutable;
-
-         e++;
-         if ((e+2 < eof) && (*e++ == '[') && (*e++ == '$')) // Option follows
-         {
-            if ((*e == 'i') && !kde_kiosk_exception)
-            {
-               groupOptionImmutable = true;
-            }
-         }
-
-         KEntryKey groupKey(aCurrentGroup, 0);
-         KEntry entry = pConfig->lookupData(groupKey);
-         groupSkip = entry.bImmutable;
-
-         if (groupSkip && !bDefault)
-            continue;
-
-         entry.bImmutable |= groupOptionImmutable;
-         pConfig->putData(groupKey, entry, false);
-
-         if (pWriteBackMap)
-         {
-            // add the special group key indicator
-            (*pWriteBackMap)[groupKey] = entry;
-         }
-
-         continue;
-      }
-      if (groupSkip && !bDefault)
-        goto sktoeol; // Skip entry
-
-      bool optionImmutable = groupOptionImmutable;
-      bool optionDeleted = false;
-      bool optionExpand = false;
-      const char *endOfKey = 0, *locale = 0, *elocale = 0;
-      for (; (s < eof) && (*s != '\n'); s++)
-      {
-         if (*s == '=') //find the equal sign
-         {
-	    if (!endOfKey)
-        	endOfKey = s;
-            goto haveeq;
-	 }
-	 if (*s == '[') //find the locale or options.
-	 {
-            const char *option;
-            const char *eoption;
-	    endOfKey = s;
-	    option = ++s;
-	    for (;; s++)
-	    {
-		if ((s >= eof) || (*s == '\n') || (*s == '=')) {
-		    fprintf(stderr, "Invalid entry (missing ']') at %s:%d\n", rFile.name().latin1(), line);
-		    goto sktoeol;
-		}
-		if (*s == ']')
-		    break;
-	    }
-	    eoption = s;
-            if (*option != '$')
-            {
-              // Locale
-              if (locale) {
-		fprintf(stderr, "Invalid entry (second locale!?) at %s:%d\n", rFile.name().latin1(), line);
-		goto sktoeol;
-              }
-              locale = option;
-              elocale = eoption;
-            }
-            else
-            {
-              // Option
-              while (option < eoption)
-              {
-                 option++;
-                 if ((*option == 'i') && !kde_kiosk_exception)
-                    optionImmutable = true;
-                 else if (*option == 'e')
-                    optionExpand = true;
-                 else if (*option == 'd')
-                 {
-                    optionDeleted = true;
-                    goto haveeq;
-                 }
-		 else if (*option == ']')
-		    break;
-              }
-            }
-         }
-      }
-      fprintf(stderr, "Invalid entry (missing '=') at %s:%d\n", rFile.name().latin1(), line);
-      continue;
-
-   haveeq:
-      for (endOfKey--; ; endOfKey--)
-      {
-	 if (endOfKey < startLine)
-	 {
-	   fprintf(stderr, "Invalid entry (empty key) at %s:%d\n", rFile.name().latin1(), line);
-	   goto sktoeol;
-	 }
-	 if (!isspace(*endOfKey))
-	    break;
-      }
-
-      const char *st = ++s;
-      while ((s < eof) && (*s != '\n')) s++; // Search till end of line / end of file
-
-      if (locale) {
-          unsigned int cl = static_cast<unsigned int>(elocale - locale);
-          if ((ll != cl) || memcmp(locale, localeString.data(), ll))
-          {
-              // backward compatibility. C == en_US
-              if ( cl != 1 || ll != 5 || *locale != 'C' || memcmp(localeString.data(), "en_US", 5)) {
-                  //cout<<"mismatched locale '"<<QCString(locale, elocale-locale +1)<<"'"<<endl;
-                  // We can ignore this one
-                  if (!pWriteBackMap)
-                      continue; // We just ignore it
-                  // We just store it as is to be able to write it back later.
-                  endOfKey = elocale;
-                  locale = 0;
-              }
-          }
-      }
-
-      // insert the key/value line
-      QCString key(startLine, endOfKey - startLine + 2);
-      QCString val = printableToString(st, s - st);
-      //qDebug("found key '%s' with value '%s'", key.data(), val.data());
-
-      KEntryKey aEntryKey(aCurrentGroup, key);
-      aEntryKey.bLocal = (locale != 0);
-      aEntryKey.bDefault = bDefault;
-
-      KEntry aEntry;
-      aEntry.mValue = val;
-      aEntry.bGlobal = bGlobal;
-      aEntry.bImmutable = optionImmutable;
-      aEntry.bDeleted = optionDeleted;
-      aEntry.bExpand = optionExpand;
-      aEntry.bNLS = (locale != 0);
-
-      if (pWriteBackMap) {
-         // don't insert into the config object but into the temporary
-         // scratchpad map
-         pWriteBackMap->insert(aEntryKey, aEntry);
-      } else {
-         // directly insert value into config object
-         // no need to specify localization; if the key we just
-         // retrieved was localized already, no need to localize it again.
-         pConfig->putData(aEntryKey, aEntry, false);
-      }
-   }
-   if (fileOptionImmutable)
-      bFileImmutable = true;
+bool KConfigBackEnd::parseConfigFiles()
+{
+	if ( mParser )
+		return mParser->parseConfigFiles();
 
-#ifdef HAVE_MMAP
-   if (map)
-   {
-      munmap(( char* )map, rFile.size());
-#ifdef SIGBUS
-      sigaction (SIGBUS, &mmap_old_sigact, 0);
-#endif
-   }
-#endif
+	return false;
 }
 
-
-void KConfigINIBackEnd::sync(bool bMerge)
+void KConfigBackEnd::sync(bool bMerge)
 {
-  // write-sync is only necessary if there are dirty entries
-  if (!pConfig->isDirty())
-    return;
-
-  bool bEntriesLeft = true;
-
-  // find out the file to write to (most specific writable file)
-  // try local app-specific file first
-
-  if (!mfileName.isEmpty()) {
-    // Create the containing dir if needed
-    if ((resType!="config") && !QDir::isRelativePath(mLocalFileName))
-    {
-       KURL path;
-       path.setPath(mLocalFileName);
-       QString dir=path.directory();
-       KStandardDirs::makeDir(dir);
-    }
-
-    // Can we allow the write? We can, if the program
-    // doesn't run SUID. But if it runs SUID, we must
-    // check if the user would be allowed to write if
-    // it wasn't SUID.
-    if (checkAccess(mLocalFileName, W_OK)) {
-      // File is writable
-      KLockFile::Ptr lf;
-
-      bool mergeLocalFile = bMerge;
-      // Check if the file has been updated since.
-      if (mergeLocalFile)
-      {
-         lf = lockFile(false); // Lock file for local file
-         if (lf && lf->isLocked())
-            lf = 0; // Already locked, we don't need to lock/unlock again
-
-         if (lf) 
-         {
-            lf->lock( KLockFile::LockForce );
-            // But what if the locking failed? Ignore it for now...
-         }
-         
-         QFileInfo info(mLocalFileName);
-         if ((d->localLastSize == info.size()) &&
-             (d->localLastModified == info.lastModified()))
-         {
-            // Not changed, don't merge.
-            mergeLocalFile = false;
-         }
-         else
-         {
-            // Changed...
-            d->localLastModified = QDateTime();
-            d->localLastSize = 0;
-         }
-      }
-
-      bEntriesLeft = writeConfigFile( mLocalFileName, false, mergeLocalFile );
-      
-      // Only if we didn't have to merge anything can we use our in-memory state
-      // the next time around. Otherwise the config-file may contain entries
-      // that are different from our in-memory state which means we will have to 
-      // do a merge from then on. 
-      // We do not automatically update the in-memory state with the on-disk 
-      // state when writing the config to disk. We only do so when 
-      // KCOnfig::reparseConfiguration() is called.
-      // For KDE 4.0 we may wish to reconsider that.
-      if (!mergeLocalFile)
-      {
-         QFileInfo info(mLocalFileName);
-         d->localLastModified = info.lastModified();
-         d->localLastSize = info.size();
-      }
-      if (lf) lf->unlock();
-    }
-  }
-
-  // only write out entries to the kdeglobals file if there are any
-  // entries marked global (indicated by bEntriesLeft) and
-  // the useKDEGlobals flag is set.
-  if (bEntriesLeft && useKDEGlobals) {
-
-    // can we allow the write? (see above)
-    if (checkAccess ( mGlobalFileName, W_OK )) {
-      KLockFile::Ptr lf = lockFile(true); // Lock file for global file
-      if (lf && lf->isLocked())
-         lf = 0; // Already locked, we don't need to lock/unlock again
-
-      if (lf) 
-      {
-         lf->lock( KLockFile::LockForce );
-         // But what if the locking failed? Ignore it for now...
-      }
-      writeConfigFile( mGlobalFileName, true, bMerge ); // Always merge
-      if (lf) lf->unlock();
-    }
-  }
-
+	if ( mParser )
+		mParser->sync(bMerge);
 }
 
-static void writeEntries(FILE *pStream, const KEntryMap& entryMap, bool defaultGroup, bool &firstEntry, const QCString &localeString)
+void KConfigBackEnd::setFileWriteMode(int mode)
 {
-  // now write out all other groups.
-  QCString currentGroup;
-  for (KEntryMapConstIterator aIt = entryMap.begin();
-       aIt != entryMap.end(); ++aIt)
-  {
-     const KEntryKey &key = aIt.key();
-
-     // Either proces the default group or all others
-     if ((key.mGroup != "<default>") == defaultGroup)
-        continue; // Skip
-
-     // Skip default values and group headers.
-     if ((key.bDefault) || key.mKey.isEmpty())
-        continue; // Skip
-
-     const KEntry &currentEntry = *aIt;
-
-     KEntryMapConstIterator aTestIt = aIt;
-     ++aTestIt;
-     bool hasDefault = (aTestIt != entryMap.end());
-     if (hasDefault)
-     {
-        const KEntryKey &defaultKey = aTestIt.key();
-        if ((!defaultKey.bDefault) ||
-            (defaultKey.mKey != key.mKey) ||
-            (defaultKey.mGroup != key.mGroup) ||
-            (defaultKey.bLocal != key.bLocal))
-           hasDefault = false;
-     }
-
-
-     if (hasDefault)
-     {
-        // Entry had a default value
-        if ((currentEntry.mValue == (*aTestIt).mValue) &&
-            (currentEntry.bDeleted == (*aTestIt).bDeleted))
-           continue; // Same as default, don't write.
-     }
-     else
-     {
-        // Entry had no default value.
-        if (currentEntry.bDeleted)
-           continue; // Don't write deleted entries if there is no default.
-     }
-
-     if (!defaultGroup && (currentGroup != key.mGroup)) {
-	if (!firstEntry)
-	    fprintf(pStream, "\n");
-	currentGroup = key.mGroup;
-	fprintf(pStream, "[%s]\n", encodeGroup(currentGroup).data());
-     }
-
-     firstEntry = false;
-     // it is data for a group
-     fputs(key.mKey.data(), pStream); // Key
-
-     if ( currentEntry.bNLS )
-     {
-        fputc('[', pStream);
-        fputs(localeString.data(), pStream);
-        fputc(']', pStream);
-     }
-
-     if (currentEntry.bDeleted)
-     {
-        fputs("[$d]\n", pStream); // Deleted
-     }
-     else
-     {
-        if (currentEntry.bImmutable || currentEntry.bExpand)
-        {
-           fputc('[', pStream);
-           fputc('$', pStream);
-           if (currentEntry.bImmutable)
-              fputc('i', pStream);
-           if (currentEntry.bExpand)
-              fputc('e', pStream);
-
-           fputc(']', pStream);
-        }
-        fputc('=', pStream);
-        fputs(stringToPrintable(currentEntry.mValue).data(), pStream);
-        fputc('\n', pStream);
-     }
-  } // for loop
+  mFileMode = mode;
 }
 
-bool KConfigINIBackEnd::getEntryMap(KEntryMap &aTempMap, bool bGlobal,
-                                    QFile *mergeFile)
-{
-  bool bEntriesLeft = false;
-  bFileImmutable = false;
+void KConfigBackEnd::virtual_hook( int, void* )
+{ /*BASE::virtual_hook( id, data );*/ }
 
-  // Read entries from disk
-  if (mergeFile && mergeFile->open(IO_ReadOnly))
-  {
-     // fill the temporary structure with entries from the file
-     parseSingleConfigFile(*mergeFile, &aTempMap, bGlobal, false );
-
-     if (bFileImmutable) // File has become immutable on disk
-        return bEntriesLeft;
-  }
-
-  KEntryMap aMap = pConfig->internalEntryMap();
-
-  // augment this structure with the dirty entries from the config object
-  for (KEntryMapIterator aIt = aMap.begin();
-       aIt != aMap.end(); ++aIt)
-  {
-    const KEntry &currentEntry = *aIt;
-    if(aIt.key().bDefault)
-    {
-       aTempMap.replace(aIt.key(), currentEntry);
-       continue;
-    }
-
-    if (mergeFile && !currentEntry.bDirty)
-       continue;
-
-    // only write back entries that have the same
-    // "globality" as the file
-    if (currentEntry.bGlobal != bGlobal)
-    {
-       // wrong "globality" - might have to be saved later
-       bEntriesLeft = true;
-       continue;
-    }
-
-    // put this entry from the config object into the
-    // temporary map, possibly replacing an existing entry
-    KEntryMapIterator aIt2 = aTempMap.find(aIt.key());
-    if (aIt2 != aTempMap.end() && (*aIt2).bImmutable)
-       continue; // Bail out if the on-disk entry is immutable
+bool KConfigBackEnd::checkConfigFilesWritable(bool warnUser)
+{
 
-    aTempMap.insert(aIt.key(), currentEntry, true);
-  } // loop
+	if ( mParser )
+		return mParser->checkConfigFilesWritable(warnUser);
 
-  return bEntriesLeft;
+	return false;
 }
 
-/* antlarr: KDE 4.0:  make the first parameter "const QString &" */
-bool KConfigINIBackEnd::writeConfigFile(QString filename, bool bGlobal,
-					bool bMerge)
+const char* KConfigBackEnd::resource()
 {
-  // is the config object read-only?
-  if (pConfig->isReadOnly())
-    return true; // pretend we wrote it
-
-  KEntryMap aTempMap;
-  QFile *mergeFile = (bMerge ? new QFile(filename) : 0);
-  bool bEntriesLeft = getEntryMap(aTempMap, bGlobal, mergeFile);
-  delete mergeFile;
-  if (bFileImmutable)
-    return true; // pretend we wrote it
-
-  // OK now the temporary map should be full of ALL entries.
-  // write it out to disk.
-
-  // Check if file exists:
-  int fileMode = -1;
-  bool createNew = true;
-
-  KDE_struct_stat buf;
-  if (KDE_stat(QFile::encodeName(filename), &buf) == 0)
-  {
-     if (buf.st_uid == getuid())
-     {
-        // Preserve file mode if file exists and is owned by user.
-        fileMode = buf.st_mode & 0777;
-     }
-     else
-     {
-        // File is not owned by user:
-        // Don't create new file but write to existing file instead.
-        createNew = false;
-     }
-  }
-
-  KSaveFile *pConfigFile = 0;
-  FILE *pStream = 0;
-
-  if (createNew)
-  {
-     pConfigFile = new KSaveFile( filename, 0600 );
-
-     if (pConfigFile->status() != 0)
-     {
-        delete pConfigFile;
-        return bEntriesLeft;
-     }
-
-     if (!bGlobal && (fileMode == -1))
-        fileMode = mFileMode;
-
-     if (fileMode != -1)
-     {
-        fchmod(pConfigFile->handle(), fileMode);
-     }
-
-     pStream = pConfigFile->fstream();
-  }
-  else
-  {
-     // Open existing file.
-     // We use open() to ensure that we call without O_CREAT.
-     int fd = KDE_open( QFile::encodeName(filename), O_WRONLY | O_TRUNC );
-     if (fd < 0)
-     {
-        return bEntriesLeft;
-     }
-     pStream = KDE_fdopen( fd, "w");
-     if (!pStream)
-     {
-        close(fd);
-        return bEntriesLeft;
-     }
-  }
-
-  writeEntries(pStream, aTempMap);
-
-  if (pConfigFile)
-  {
-     bool bEmptyFile = (ftell(pStream) == 0);
-     if ( bEmptyFile && ((fileMode == -1) || (fileMode == 0600)) )
-     {
-        // File is empty and doesn't have special permissions: delete it.
-        ::unlink(QFile::encodeName(filename));
-        pConfigFile->abort();
-     }
-     else
-     {
-        // Normal case: Close the file
-        pConfigFile->close();
-     }
-     delete pConfigFile;
-  }
-  else
-  {
-     fclose(pStream);
-  }
+	if ( mParser )
+		return mParser->resource();
 
-  return bEntriesLeft;
+	return NULL;
 }
 
-void KConfigINIBackEnd::writeEntries(FILE *pStream, const KEntryMap &aTempMap)
+bool KConfigBackEnd::isFileImmutable()
 {
-  bool firstEntry = true;
+	if ( mParser )
+		return mParser->isFileImmutable();
 
-  // Write default group
-  ::writeEntries(pStream, aTempMap, true, firstEntry, localeString);
-
-  // Write all other groups
-  ::writeEntries(pStream, aTempMap, false, firstEntry, localeString);
+	return false;
 }
 
-void KConfigBackEnd::virtual_hook( int, void* )
-{ /*BASE::virtual_hook( id, data );*/ }
+bool KConfigBackEnd::isUseKDEGlobals()
+{
+	if ( mParser )
+		return mParser->isUseKDEGlobals();
 
-void KConfigINIBackEnd::virtual_hook( int id, void* data )
-{ KConfigBackEnd::virtual_hook( id, data ); }
+	return false;
+}
 
-bool KConfigBackEnd::checkConfigFilesWritable(bool warnUser)
+KConfigBackEnd::~KConfigBackEnd()
 {
-  // WARNING: Do NOT use the event loop as it may not exist at this time.
-  bool allWritable = true;
-  QString errorMsg;
-  if ( !mLocalFileName.isEmpty() && !bFileImmutable && !checkAccess(mLocalFileName,W_OK) )
-  {
-    errorMsg = i18n("Will not save configuration.\n");
-    allWritable = false;
-    errorMsg += i18n("Configuration file \"%1\" not writable.\n").arg(mLocalFileName);
-  }
-  // We do not have an immutability flag for kdeglobals. However, making kdeglobals mutable while making
-  // the local config file immutable is senseless.
-  if ( !mGlobalFileName.isEmpty() && useKDEGlobals && !bFileImmutable && !checkAccess(mGlobalFileName,W_OK) )
-  {
-    if ( errorMsg.isEmpty() )
-      errorMsg = i18n("Will not save configuration.\n");
-    errorMsg += i18n("Configuration file \"%1\" not writable.\n").arg(mGlobalFileName);
-    allWritable = false;
-  }
-
-  if (warnUser && !allWritable)
-  {
-    // Note: We don't ask the user if we should not ask this question again because we can't save the answer.
-    errorMsg += i18n("Please contact your system administrator.");
-    QString cmdToExec = KStandardDirs::findExe(QString("kdialog"));
-    KApplication *app = kapp;
-    if (!cmdToExec.isEmpty() && app)
-    {
-      KProcess lprocess;
-      lprocess << cmdToExec << "--title" << app->instanceName() << "--msgbox" << errorMsg.local8Bit();
-      lprocess.start( KProcess::Block );
-    }
-  }
-  return allWritable;
+   if ( mParser ) {
+	delete mParser;
+	mParser = NULL;
+   }
 }
+
diff -Naur kdelibs-3.5.2.orig/kdecore/kconfigbackend.h kdelibs-3.5.2/kdecore/kconfigbackend.h
--- kdelibs-3.5.2.orig/kdecore/kconfigbackend.h	2005-10-10 17:06:03.000000000 +0200
+++ kdelibs-3.5.2/kdecore/kconfigbackend.h	2006-05-08 19:37:46.000000000 +0200
@@ -15,20 +15,22 @@
 
    You should have received a copy of the GNU Library General Public License
    along with this library; see the file COPYING.LIB.  If not, write to
-   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
-   Boston, MA 02110-1301, USA.
+   the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
 */
 
 #ifndef _KCONFIGBACKEND_H
 #define _KCONFIGBACKEND_H
 
+#include "kconfig.h"
 #include "kconfigdata.h"
 #include <kconfigbase.h>
 #include <klockfile.h>
+#include "kconfigparser.h"
 #include "kdelibs_export.h"
 
-class QFile;
-class KConfigBackEndPrivate;
+// class QFile;
+// class KConfigBackEndPrivate;
 
 /**
  * Abstract base class for KDE configuration file loading/saving.
@@ -48,6 +50,8 @@
 {
   friend class KConfig;
   friend class KSharedConfig;
+  friend class KConfigParser;
+
 public:
   /**
    * Constructs a configuration back end.
@@ -78,7 +82,7 @@
    *
    * @returns Whether or not parsing was successful.
    */
-  virtual bool parseConfigFiles() = 0;
+  bool parseConfigFiles();
 
   /**
    * Writes configuration data to file(s).  This method must be
@@ -89,7 +93,7 @@
    *        data is read off the disk and merged.  If false, the on-disk
    *        file is removed and only in-memory data is written out.
    */
-  virtual void sync(bool bMerge = true) = 0;
+  void sync(bool bMerge = true);
 
   /**
    * Changes the filenames associated with this back end.  You should
@@ -103,33 +107,28 @@
    */
   void changeFileName(const QString &_fileName, const char * _resType,
 		      bool _useKDEGlobals);
+  QString fileName();
 
   /**
    * Returns the state of the app-config object.
    *
    * @see KConfig::getConfigState
    */
-  virtual KConfigBase::ConfigState getConfigState() const
-    { return mConfigState; }
-
-  /**
-   * Returns the filename as passed to the constructor.
-   * @return the filename as passed to the constructor.
-   */
-  QString fileName() const { return mfileName; }
+   KConfigBase::ConfigState getConfigState();
+   void setConfigState(KConfigBase::ConfigState state);
 
   /**
    * Returns the resource type as passed to the constructor.
    * @return the resource type as passed to the constructor.
    */
-  const char * resource() const { return resType; }
+  const char * resource();
 
   /**
    * Set the locale string that defines the current language.
    * @param _localeString the identifier of the language
    * @see KLocale
    */
-  void setLocaleString(const QCString &_localeString) { localeString = _localeString; }
+  void setLocaleString(const QCString &_localeString);
 
   /**
    * Set the file mode for newly created files.
@@ -137,6 +136,9 @@
    */
   void setFileWriteMode(int mode);
 
+  bool isFileImmutable();
+  bool isUseKDEGlobals();
+
   /**
    * Check whether the config files are writable.
    * @param warnUser Warn the user if the configuration files are not writable.
@@ -153,141 +155,22 @@
   KLockFile::Ptr lockFile( bool bGlobal = false );
 
 #ifdef KDE_NO_COMPAT
-private:
+// private:
 #endif
   /**
-   * @deprecated Use fileName() instead
+   * @deprecated Use @see fileName() instead
    */
-  KDE_DEPRECATED QString filename() const { return mfileName; }
+  // KDE_DEPRECATED QString filename() const { return mfileName; }
 
 protected:
   KConfigBase *pConfig;
-
-  QString mfileName;
-  QCString resType;
-  bool useKDEGlobals : 1;
-  bool bFileImmutable : 1;
-  QCString localeString;
-  QString mLocalFileName;
-  QString mGlobalFileName;
-  KConfigBase::ConfigState mConfigState;
+  KConfigParser *mParser;
   int mFileMode;
 
 protected:
   virtual void virtual_hook( int id, void* data );
-protected:
-  class KConfigBackEndPrivate;
-  KConfigBackEndPrivate *d;
-};
-
-
-/**
- * Class for KDE INI-style configuration file loading/saving.
- *
- * @author Preston Brown <pbrown@kde.org>,
- *         Matthias Kalle Dalheimer <kalle@kde.org>
- */
-class KDECORE_EXPORT KConfigINIBackEnd : public KConfigBackEnd
-{
-
-public:
-  /**
-   * Constructs an ini-style configuration back end.
-   *
-   * @param _config Specifies the configuration object which values
-   *        will be passed to as they are read, or from where values
-   *        to be written to will be obtained from.
-   * @param _fileName The name of the file in which config
-   *        data is stored.  All registered configuration directories
-   *        will be looked in in order of decreasing relevance.
-   * @param _resType the resource type of the fileName specified, _if_
-   *        it is not an absolute path (otherwise this parameter is ignored).
-   * @param _useKDEGlobals If true, the user's system-wide kdeglobals file
-   *        will be imported into the config object.  If false, only
-   *        the filename specified will be dealt with.
-   */
-  KConfigINIBackEnd(KConfigBase *_config, const QString &_fileName,
-		    const char * _resType, bool _useKDEGlobals = true)
-    : KConfigBackEnd(_config, _fileName, _resType, _useKDEGlobals) {}
 
-  /**
-   * Destructs the configuration backend.
-   */
-  virtual ~KConfigINIBackEnd() {};
-
-  /**
-   * Parses all INI-style configuration files for a config object.
-   *
-   * @returns Whether or not parsing was successful.
-   */
-  bool parseConfigFiles();
-
-  /**
-   * Writes configuration data to file(s).
-   * @param bMerge Specifies whether the old config file already
-   *        on disk should be merged in with the data in memory.  If true,
-   *        data is read off the disk and merged.  If false, the on-disk
-   *        file is removed and only in-memory data is written out.
-   */
-  virtual void sync(bool bMerge = true);
-
-protected:
-  /**
-   * Parses one configuration file.
-   *
-   * @param rFile The configuration file to parse
-   * @param pWriteBackMap If specified, points to a KEntryMap where
-   *        the data read from the file should be stored, instead of
-   *        inserting them directly into the configuration object.
-   *        Use this area as a "scratchpad" when you need to know what is
-   *        on disk but don't want to effect the configuration object.
-   * @param bGlobal Specifies whether entries should be marked as
-   *        belonging to the global KDE configuration file rather
-   *        than the application-specific KDE configuration file(s).
-   * @param bDefault Specifies whether entries should be marked as
-   *        being default values.
-   */
-  void parseSingleConfigFile(QFile& rFile, KEntryMap *pWriteBackMap = 0L,
-			     bool bGlobal = false, bool bDefault = false);
-
-  /**
-   * Writes configuration file back.
-   *
-   * @param filename The name of the file to write.
-   * @param bGlobal Specifies whether to write only entries which
-   *        are marked as belonging to the global KDE config file.
-   *        If this is false, it skips those entries.
-   * @param bMerge Specifies whether the old config file already
-   *        on disk should be merged in with the data in memory.  If true,
-   *        data is read off the disk and merged.  If false, the on-disk
-   *        file is removed and only in-memory data is written out.
-   * @return Whether some entries are left to be written to other
-   *         files.
-   */
-  bool writeConfigFile(QString filename, bool bGlobal = false, bool bMerge = true);
-
-  /** Get the entry map.
-   *
-   * @param map the entries will be stored in this object.
-   * @param bGlobal Specifies whether to get only entries which
-   *        are marked as belonging to the global KDE config file.
-   *        If this is false, it skips those entries.
-   * @param mergeFile if not null, the dirty entries for this file will
-   * be merged.
-   *
-   * @return Whether there will be some entries left for writing to other
-   * files.
-   */
-  bool getEntryMap(KEntryMap &map, bool bGlobal, QFile *mergeFile);
-
-  /** Write the entries in @e aTempMap to the file stream.*/
-  void writeEntries(FILE *pStream, const KEntryMap &aTempMap);
-
-protected:
-  virtual void virtual_hook( int id, void* data );
-private:
-  class KConfigINIBackEndPrivate;
-  KConfigINIBackEndPrivate *not_d;
 };
 
+
 #endif
diff -Naur kdelibs-3.5.2.orig/kdecore/kconfigbase.h kdelibs-3.5.2/kdecore/kconfigbase.h
--- kdelibs-3.5.2.orig/kdecore/kconfigbase.h	2006-03-17 11:19:05.000000000 +0100
+++ kdelibs-3.5.2/kdecore/kconfigbase.h	2006-05-08 19:39:05.000000000 +0200
@@ -72,7 +72,9 @@
   Q_OBJECT
 
   friend class KConfigBackEnd;
-  friend class KConfigINIBackEnd;
+  friend class KConfigParser;
+  friend class KConfigINIParser;
+  friend class KConfigElektraParser;
   friend class KConfigGroup;
 
 public:
diff -Naur kdelibs-3.5.2.orig/kdecore/kconfig.cpp kdelibs-3.5.2/kdecore/kconfig.cpp
--- kdelibs-3.5.2.orig/kdecore/kconfig.cpp	2005-10-10 17:06:02.000000000 +0200
+++ kdelibs-3.5.2/kdecore/kconfig.cpp	2006-05-08 23:12:54.000000000 +0200
@@ -17,6 +17,8 @@
   along with this library; see the file COPYING.LIB.  If not, write to
   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.
+
+  Patch for elektra by Yannick Lecaillez - <sizon5@gmail.com>
 */
 
 // $Id$
@@ -49,16 +51,8 @@
   // set the object's read-only status.
   setReadOnly(bReadOnly);
 
-  // for right now we will hardcode that we are using the INI
-  // back end driver.  In the future this should be converted over to
-  // a object factory of some sorts.
-  KConfigINIBackEnd *aBackEnd = new KConfigINIBackEnd(this,
-						      fileName,
-                                                      resType,
-						      bUseKderc);
 
-  // set the object's back end pointer to this new backend
-  backEnd = aBackEnd;
+  backEnd = new KConfigBackEnd(this, fileName, resType, bUseKderc);
 
   // read initial information off disk
   reparseConfiguration();
@@ -279,7 +273,7 @@
 
 KLockFile::Ptr KConfig::lockFile(bool bGlobal)
 {
-  KConfigINIBackEnd *aBackEnd = dynamic_cast<KConfigINIBackEnd*>(backEnd);
+  KConfigBackEnd *aBackEnd = dynamic_cast<KConfigBackEnd*>(backEnd);
   if (!aBackEnd) return 0;
   return aBackEnd->lockFile(bGlobal);
 }
@@ -307,7 +301,7 @@
   config->backEnd->changeFileName(file, "config", false);
   config->setReadOnly(false);
   config->bFileImmutable = false;
-  config->backEnd->mConfigState = ReadWrite;
+  config->backEnd->setConfigState(ReadWrite);
 
   QStringList groups = groupList();
   for(QStringList::ConstIterator it = groups.begin();
@@ -339,8 +333,8 @@
          it != s_list->end(); ++it)
      {
         if ((*it)->backEnd->fileName() == fileName &&
-                (*it)->backEnd->bFileImmutable == immutable &&
-                (*it)->backEnd->useKDEGlobals == useKDEGlobals )
+                (*it)->backEnd->isFileImmutable() == immutable &&
+                (*it)->backEnd->isUseKDEGlobals() == useKDEGlobals )
            return (*it);
      }
   }
diff -Naur kdelibs-3.5.2.orig/kdecore/kconfigelektraparser.cpp kdelibs-3.5.2/kdecore/kconfigelektraparser.cpp
--- kdelibs-3.5.2.orig/kdecore/kconfigelektraparser.cpp	1970-01-01 01:00:00.000000000 +0100
+++ kdelibs-3.5.2/kdecore/kconfigelektraparser.cpp	2006-05-08 23:04:27.000000000 +0200
@@ -0,0 +1,756 @@
+/*
+	KConfigElektraParser
+	Yannick Lecaillez - <sizon5@gmail.com>
+
+	KConfig configuration parser using elektra as backend.
+*/
+
+#include <config.h>
+
+#include <stdlib.h>
+#include <unistd.h>
+#include <kdb.h>
+#include <sys/types.h>
+#ifdef HAVE_SYS_STAT_H
+#include <sys/stat.h>
+#endif
+
+#include <kapplication.h>
+#include <kglobal.h>
+#include <klocale.h>
+#include <kstandarddirs.h>
+#include <kprocess.h>
+
+// #include "kconfigdata.h"
+// #include "kconfigbase.h"
+#include "kconfigparser.h"
+#include "kconfigelektraparser.h"
+
+bool checkKeyAccess(const QString &keyName, int mode);
+
+KConfigElektraParser::KConfigElektraParser(KConfigBase *config, const QString &fileName, const char *resType, bool useKDEGlobals) : KConfigParser(config, fileName, "config-elektra", useKDEGlobals)
+{
+	if (fileName.isEmpty())
+		mLocalKeyRoot = QString::null;
+	else if ( isAbsoluteKeyName(fileName) )
+		mLocalKeyRoot = fileName;
+	else {
+		mLocalKeyRoot = KGlobal::dirs()->saveLocation(resType) + mfileName;
+	}
+
+	if (useKDEGlobals)
+		mGlobalKeyRoot = KGlobal::dirs()->saveLocation("config-elektra") + QString::fromLatin1("kdeglobals");
+	else
+		mGlobalKeyRoot = QString::null;
+}
+
+bool KConfigElektraParser::isAbsoluteKeyName(const QString &keyName)
+{
+	return ( keyName.startsWith("user/") ||
+			keyName.startsWith("user:") ||
+			keyName.startsWith("system/") );
+}
+
+bool KConfigElektraParser::parseConfigFiles()
+{
+	// Check if we can write to the local file.
+	mConfigState = KConfigBase::ReadOnly;
+	if (!mfileName.isEmpty() && !pConfig->isReadOnly()) {
+		if (checkKeyAccess(mLocalKeyRoot, W_OK)) {
+			mConfigState = KConfigBase::ReadWrite;
+		/*} else {
+			// Create the containing dir, maybe it wasn't there
+			KURL path;
+			path.setPath(mLocalFileName);
+			QString dir=path.directory();
+			KStandardDirs::makeDir(dir);
+
+			if (checkAccess(mLocalFileName, W_OK)) {
+				mConfigState = KConfigBase::ReadWrite;
+			} */
+		}
+	}
+
+	bFileImmutable = false;
+
+	// Parse the general config files
+	if (useKDEGlobals) {
+		QStringList kdercs = KGlobal::dirs()-> findAllResources("config-elektra", QString::fromLatin1("kdeglobals"));		
+		QString etc_kderc = QString::fromLatin1("system/sw/kde/kderc");
+		
+		if (checkKeyAccess(etc_kderc, R_OK))
+			kdercs += etc_kderc;
+
+		kdercs += KGlobal::dirs()-> findAllResources("config-elektra", QString::fromLatin1("system.kdeglobals"));
+
+		QStringList::ConstIterator it;
+		for (it = kdercs.fromLast(); it != kdercs.end(); --it) {
+			QString keyName(*it);
+			parseKeysFrom(keyName, 0L, true, (keyName != mGlobalKeyRoot));
+			if (bFileImmutable)
+				break;
+		}
+	}
+	
+	// Parse specific configuration file
+	bool bReadFile = !mfileName.isEmpty();
+	while(bReadFile) {
+		QString keyName;		
+		QString bootLanguage;
+
+		bReadFile = false;
+
+		if (useKDEGlobals && localeString.isEmpty() && !KGlobal::_locale) {
+			// Boot strap language
+			bootLanguage = KLocale::_initLanguage(pConfig);
+			setLocaleString(bootLanguage.utf8());
+		}
+			
+		bFileImmutable = false;
+		QStringList list;
+		if ( isAbsoluteKeyName(mfileName) )
+			list << mfileName;
+		else
+			list = KGlobal::dirs()->findAllResources(resType, mfileName);
+
+
+		QStringList::ConstIterator it;
+		for (it = list.fromLast(); it != list.end(); --it) {
+			QString keyName(*it);
+			
+			// we can already be sure that this file exists
+			bool bIsLocal = (keyName == mLocalKeyRoot);
+			parseKeysFrom(keyName, 0L, false, !bIsLocal );
+			if (bFileImmutable)
+				break;
+		}
+		if (KGlobal::dirs()->isRestrictedResource(resType, mfileName))
+			bFileImmutable = true;
+		
+		QString currentLanguage;
+		if (!bootLanguage.isEmpty()) {
+			currentLanguage = KLocale::_initLanguage(pConfig);
+			// If the file changed the language, we need to read the file again
+			// with the new language setting.
+			if (bootLanguage != currentLanguage) {
+				bReadFile = true;
+				setLocaleString(currentLanguage.utf8());
+			}
+		}
+	}
+
+	if (bFileImmutable)
+		mConfigState = KConfigBase::ReadOnly;
+		
+	return true;
+
+
+	return true;
+}
+
+extern bool kde_kiosk_exception;
+	
+void KConfigElektraParser::parseKeysFrom(QString keyName, KEntryMap *pWriteBackMap, bool bGlobal, bool bDefault)
+{
+	KDBHandle	kdbHandle;
+	KeySet		*groups;
+	Key		*key;
+	bool		mainImmutable = false;
+	
+	if ( keyName.endsWith("[$i]") || keyName.endsWith("[$i]/") )
+		mainImmutable = true;
+		
+	kdbOpen(&kdbHandle);
+	groups = ksNew();
+	if ( kdbGetChildKeys(kdbHandle, keyName.latin1(), groups, KDB_O_RECURSIVE | KDB_O_INACTIVE ) <= 0 ) {
+		ksDel(groups);
+		kdbClose(&kdbHandle);
+		return;
+ 	}
+	
+	ksRewind(groups);
+	while ( (key = ksNext(groups)) )  {
+		QString groupName;
+		bool groupSkip;
+		bool groupImmutable = mainImmutable;
+		QString tmp(keyStealName(key));
+		char *parentName;
+		ssize_t nameSize;
+
+		//
+		// Manage group
+		// 
+
+		if ( (nameSize = keyGetParentNameSize(key)) <= 0 )
+			continue;
+		
+		parentName = (char *) malloc(nameSize);
+		keyGetParentName(key, parentName, nameSize);
+		groupName = parentName;
+		free(parentName);
+			
+		groupName.remove(0, keyName.length()+1);		// Remove keyRoot
+		if (groupName.length() == 0 ) {
+			groupName = "<default>";
+
+		} else {
+			groupName.replace(QString("\\/"), QString("/"));	// Unescape
+					
+			if ( groupName.endsWith("[$i]") && !kde_kiosk_exception ) {
+				groupName.truncate(groupName.length() - 4);	// Remove [$i] from group name
+				groupImmutable = true;
+			}
+			
+			if (groupName == "KDE Desktop Entry")
+				groupName = "Desktop Entry";
+		}
+	
+		// Look if this group was previously defined
+		// by a previous search path
+		KEntryKey groupKey(groupName.latin1(), 0);
+		KEntry entry = pConfig->lookupData(groupKey);
+		groupSkip = entry.bImmutable;
+		if ( groupSkip && !bDefault ) {
+			// Ignore this group, a previously defined
+			// as immutable exist yet
+			continue;
+		}
+			
+		// Add this group
+		entry.bImmutable |= groupImmutable;
+		pConfig->putData(groupKey, entry, false);
+	
+		if (pWriteBackMap) {
+			// add the special group key indicator
+			(*pWriteBackMap)[groupKey] = entry;
+		}
+	
+		//
+		// Manage key for this group
+		//
+		int optStartPos, optEndPos;
+		bool keyImmutable = false;
+		bool keyExpand = false, keyDeleted = false;
+		QString locale("");
+		QString keyName(keyStealBaseName(key));
+		keyName.replace(QString("\\/"), QString("/"));	// Unescape
+	
+		// Parse key options
+		optStartPos = keyName.find(QChar('['), 0);
+		optEndPos = keyName.find(QChar(']'), 0);
+			
+		if ( optStartPos != -1 && optEndPos != -1 ) {
+			if ( keyName.at(optStartPos+1) == QChar('$') ) {
+				// Options
+				int optPos = optStartPos + 2;  // Skip [ and $
+					
+				QChar opt = keyName.at(optPos++);
+				while ( optPos != optEndPos ) {
+					switch ((char) opt) {
+						case 'i':
+							keyImmutable = true;
+							break;
+						case 'e':
+							keyExpand = true;
+							break;
+						case 'd':
+							keyDeleted = true;
+							break;
+						default:
+							fprintf(stderr, "Unknown option '%c'\n", (char) opt);
+					}
+					opt = keyName.at(optPos++);
+				}
+						
+			} else {
+				// Localized Key
+				if ( !locale.isEmpty() )
+					fprintf(stderr, "Invalid entry (second locale!?) at %s\n", keyStealBaseName(key));
+				locale = keyName.mid(optStartPos+1, (optEndPos - (optStartPos+1)));
+			}
+			keyName.truncate(keyName.length() - (optEndPos - (optStartPos)));
+		} else if ( optStartPos != -1 ) {
+			// ] is missing
+			fprintf(stderr, "Invalid entry (missing ']') at %s\n", keyStealBaseName(key));
+			continue;
+
+		} else if ( optEndPos != -1 ) {
+			// [ is missing
+			fprintf(stderr, "Invalid entry (missing '[') at %s\n", keyStealBaseName(key));
+			continue;
+		}
+		// End key option parsing
+
+		// insert the key/value		
+		KEntryKey aEntryKey(groupName.latin1(), keyName.latin1());
+		aEntryKey.bLocal = !locale.isEmpty();
+		aEntryKey.bDefault = bDefault;
+	
+		KEntry aEntry;	
+		aEntry.mValue = QCString((const char*)keyStealValue(key));
+		aEntry.bGlobal = bGlobal;
+		aEntry.bImmutable = keyImmutable;
+		aEntry.bDeleted = keyDeleted;
+		aEntry.bExpand = keyExpand;
+		aEntry.bNLS = !locale.isEmpty();
+	
+		if ( pWriteBackMap ) {
+			// don't insert into the config object but into the temporary
+			// scratchpad map
+			pWriteBackMap->insert(aEntryKey, aEntry);
+		} else {
+			// directly insert value into config object
+			// no need to specify localization; if the key we just
+			// retrieved was localized already, no need to localize it again.
+			pConfig->putData(aEntryKey, aEntry, false);
+		}
+	}
+	ksDel(groups);
+	
+	kdbClose(&kdbHandle);
+	
+	if (mainImmutable)
+		bFileImmutable = true;
+}
+
+void KConfigElektraParser::sync(bool bMerge)
+{
+	bool bEntriesLeft = false;
+
+	/* bMerge true if data have to be merged with data
+	   already present on disk. */
+
+	// Try to save into the most specific first
+	if ( !mfileName.isEmpty() ) {
+		// Can we allow the write? We can, if the program
+		// doesn't run SUID. But if it runs SUID, we must
+		// check if the user would be allowed to write if
+		// it wasn't SUID.
+		bEntriesLeft = writeConfigKeys(mLocalKeyRoot, false, bMerge);
+	}
+	
+	// only write out entries to the kdeglobals file if there are any
+	// entries marked global (indicated by bEntriesLeft) and
+	// the useKDEGlobals flag is set.
+	if (bEntriesLeft && useKDEGlobals) {
+		writeConfigKeys(mGlobalKeyRoot, true, true); // Always merge
+	}
+
+}
+	
+static void writeKeyEntries(QString underKeyRoot, const KEntryMap& entryMap, bool defaultGroup, bool &firstEntry, const QCString &localeString)
+{
+	KeySet	*keysToStore;
+	
+	keysToStore = ksNew();
+
+	// now write out all other groups.
+	QCString currentGroup;
+	for (KEntryMapConstIterator aIt = entryMap.begin(); aIt != entryMap.end(); ++aIt) {
+		const KEntryKey &key = aIt.key();
+		const KEntry &currentEntry = *aIt;
+		QString keyName;
+			
+		keyName  = underKeyRoot;
+		keyName += "/";
+		
+		// Either proces the default group or all others
+		if ((key.mGroup != "<default>") == defaultGroup)
+			continue; // Skip
+	
+		// Skip default values and group headers.
+		if ((key.bDefault) || key.mKey.isEmpty())
+			continue; // Skip
+	
+		KEntryMapConstIterator aTestIt = aIt;
+		++aTestIt;
+		bool hasDefault = (aTestIt != entryMap.end());
+		if (hasDefault) {
+			const KEntryKey &defaultKey = aTestIt.key();
+			if ((!defaultKey.bDefault) ||
+				(defaultKey.mKey != key.mKey) ||
+				(defaultKey.mGroup != key.mGroup) ||
+				(defaultKey.bLocal != key.bLocal))
+				hasDefault = false;
+		}
+	
+		if (hasDefault) {
+			// Entry had a default value
+			if ((currentEntry.mValue == (*aTestIt).mValue) &&
+				(currentEntry.bDeleted == (*aTestIt).bDeleted))
+				continue; // Same as default, don't write.
+		} else {
+			// Entry had no default value.
+			if (currentEntry.bDeleted)
+				continue; // Don't write deleted entries if there is no default.
+		}
+	
+		if (!defaultGroup && (currentGroup != key.mGroup)) {
+			currentGroup = key.mGroup;
+		}
+		keyName += currentGroup.replace("/", "\\/");
+		keyName += "/";
+	
+		firstEntry = false;
+		// it is data for a group
+		keyName += key.mKey;	// key;
+	
+		if ( currentEntry.bNLS ) {
+			keyName += "[";
+			keyName += localeString;
+			keyName += "]";
+		}
+	
+		if (currentEntry.bDeleted) {
+			keyName += "[$d]";
+		}
+
+		Key *toStore;
+	
+		if (currentEntry.bImmutable || currentEntry.bExpand) {
+			keyName += "[$";
+			if (currentEntry.bImmutable)
+				keyName += "i";
+			if (currentEntry.bExpand)
+				keyName += "e";
+			keyName += "]";
+		}
+		toStore = keyNew(keyName.latin1(),
+				KEY_SWITCH_VALUE, (const char *) currentEntry.mValue,
+				KEY_SWITCH_END);
+
+		ksAppend(keysToStore, toStore);
+	} // for loop
+	
+	if ( ksGetSize(keysToStore) ) {
+		KDBHandle handle;
+
+		kdbOpen(&handle);
+		kdbSetKeys(handle, keysToStore);
+		kdbClose(&handle);
+	}
+	ksDel(keysToStore);
+}
+	
+bool KConfigElektraParser::getEntryMap(KEntryMap &aTempMap, bool bGlobal, QString mergeKeys)
+{
+	KDBHandle handle;
+	bool bEntriesLeft = false;
+	bFileImmutable = false;
+
+	// Read entries from disk
+	Key *mergeKey;
+
+	kdbOpen(&handle);
+
+	mergeKey = keyNew(mergeKeys.latin1(), KEY_SWITCH_END);
+	if ( !mergeKeys.isEmpty() && (kdbStatKey(handle, mergeKey) == 0) ) {
+		// fill the temporary structure with entries from the file
+		kdbClose(&handle);
+		parseKeysFrom(mergeKeys, &aTempMap, bGlobal, false);
+
+		if (bFileImmutable) { // File has become immutable on disk
+			keyDel(mergeKey);
+			return bEntriesLeft;
+		}
+	}
+	keyDel(mergeKey);
+	kdbClose(&handle);
+	
+	KEntryMap aMap = pConfig->internalEntryMap();
+
+	// augment this structure with the dirty entries from the config object
+	for (KEntryMapIterator aIt = aMap.begin();aIt != aMap.end(); ++aIt) {
+		const KEntry &currentEntry = *aIt;
+
+		if(aIt.key().bDefault) {
+			aTempMap.replace(aIt.key(), currentEntry);
+			continue;
+		}
+
+		if (!mergeKeys.isEmpty() && !currentEntry.bDirty)
+			continue;
+
+		// only write back entries that have the same
+		// "globality" as the file
+		if (currentEntry.bGlobal != bGlobal) {
+			// wrong "globality" - might have to be saved later
+			bEntriesLeft = true;
+			continue;
+		}
+	
+		// put this entry from the config object into the
+		// temporary map, possibly replacing an existing entry
+		KEntryMapIterator aIt2 = aTempMap.find(aIt.key());
+		if (aIt2 != aTempMap.end() && (*aIt2).bImmutable)
+			continue; // Bail out if the on-disk entry is immutable
+	
+		aTempMap.insert(aIt.key(), currentEntry, true);
+	} // loop
+		
+
+	return bEntriesLeft; 
+}
+
+QString KConfigElektraParser::escapeGroupName(const QString &groupName)
+{
+	QString ret;
+
+	ret = groupName;
+	
+	// Replace the first '/' only
+	if ( ret[0] == QChar('/') ) {
+		ret = "\\/";
+		ret += groupName.mid(1, groupName.length());
+	}
+	ret.replace("//", "\\/\\/");
+
+	return ret;
+}
+
+/* antlarr: KDE 4.0:  make the first parameter "const QString &" */
+bool KConfigElektraParser::writeConfigKeys(QString &keyRoot, bool bGlobal, bool bMerge)
+{
+	KDBHandle handle;
+	
+	// is the config object read-only?
+	if (pConfig->isReadOnly()) {
+		return true; // pretend we wrote it
+	}
+
+	KEntryMap aTempMap;
+	bool bEntriesLeft = getEntryMap(aTempMap, bGlobal,(bMerge ? keyRoot : QString("")));
+
+	//if (bFileImmutable)
+	//	return true; // pretend we wrote it
+
+	// OK now the temporary map should be full of ALL entries.
+	// write it out to disk.
+
+	// Check if file exists:
+	int fileMode = -1;
+	bool createNew = true;
+
+	kdbOpen(&handle);
+
+	Key *kRoot;
+	kRoot = keyNew(keyRoot.latin1(), KEY_SWITCH_END);
+	if ( kdbStatKey(handle, kRoot) == 0 ) {
+		if ( keyGetUID(kRoot) == getuid()) {
+			// Preserve file mode if file exists and is owned by user.
+			fileMode = keyGetAccess(kRoot) & 0777;
+		}
+		createNew = false;
+	}
+	keyDel(kRoot);
+
+	if (createNew) {
+		Key *kRoot;
+
+		kRoot = keyNew(keyRoot.latin1(),
+				KEY_SWITCH_TYPE, KEY_TYPE_DIR,
+				KEY_SWITCH_MODE, 0700,
+				KEY_SWITCH_END);
+
+		if ( kdbSetKey(handle, kRoot) != 0 ) {
+			kdbRemoveKey(handle, kRoot);
+			keyDel(kRoot);
+			kdbClose(&handle);
+			fprintf(stderr, "\tDidn't succeed to create \"%s\"\n", keyRoot.latin1());
+			return bEntriesLeft;
+		}
+		
+		if (!bGlobal && (fileMode == -1))
+			fileMode = mFileMode;
+
+		if (fileMode != -1) {
+			keySetAccess(kRoot, fileMode);
+			kdbSetKey(handle, kRoot);
+		}
+		keyDel(kRoot);
+
+	}
+
+	writeEntries(keyRoot, aTempMap);
+	
+	// Check if configuration is empty
+	KeySet *ks;
+
+	ks = ksNew();
+	kdbGetChildKeys(handle, keyRoot.latin1(), ks, KDB_O_DIR | KDB_O_STATONLY | KDB_O_INACTIVE | KDB_O_NUMBERS);
+	if ( (ksGetSize(ks) == 0)  && (fileMode == -1) || (fileMode == 0600) ) {
+		// File is empty and doesn't have special permissions: delete it.
+		Key *kRoot;
+
+		kRoot = keyNew(keyRoot.latin1(), KEY_SWITCH_END);
+		kdbRemoveKey(handle, kRoot);
+		keyDel(kRoot);
+	}
+	ksDel(ks);
+
+	kdbClose(&handle);
+
+	return bEntriesLeft;
+}
+	
+void KConfigElektraParser::writeEntries(QString &keyRoot, const KEntryMap &aTempMap)
+{
+	bool firstEntry = true;
+	
+	// Write default group
+	::writeKeyEntries(keyRoot, aTempMap, true, firstEntry, localeString);
+	
+	// Write all other groups
+	::writeKeyEntries(keyRoot, aTempMap, false, firstEntry, localeString);
+}
+
+
+KLockFile::Ptr KConfigElektraParser::lockFile(bool bGlobal)
+{
+	/* if (bGlobal) {
+		if (mGlobalLockFile)
+			return mGlobalLockFile;
+      
+		if (!mGlobalFileName.isEmpty()) {
+			mGlobalLockFile = new KLockFile(mGlobalFileName+".lock");
+			return mGlobalLockFile;
+		}
+	} else {
+		if (mLocalLockFile)
+			return mLocalLockFile;
+
+		if (!mLocalFileName.isEmpty()) {
+			mLocalLockFile = new KLockFile(mLocalFileName+".lock");
+			return mLocalLockFile;
+		}
+	} */
+
+	return 0;
+}
+
+
+bool keyAccess(const QString &keyName, int mode)
+{
+	KDBHandle	handle;
+	Key		*key;
+	mode_t		keyMode;
+	uid_t		euid, keyUid;
+	gid_t		egid, keyGid;
+	bool		uAllowed, gAllowed, oAllowed;
+	
+	key = keyNew(keyName.latin1(), KEY_SWITCH_END);
+	kdbOpen(&handle);
+	if ( kdbStatKey(handle, key) ) {
+		// Key doesn't exist
+		keyDel(key);
+		kdbClose(&handle);
+		return false;
+	}
+	kdbClose(&handle);
+	keyUid = keyGetUID(key);
+	keyGid = keyGetGID(key);
+	keyMode = keyGetAccess(key);
+	keyDel(key);
+
+	// Get effective uid/gid
+	euid = geteuid();
+	egid = getegid();
+
+	if ( euid == 0 ) {
+		return 0;
+	}
+	
+	if ( (mode & R_OK) ) {
+		// Is allowed to read ?
+		uAllowed = (keyMode & S_IRUSR) && (keyUid == euid);
+		gAllowed = (keyMode & S_IRGRP) && (keyGid == egid);
+		oAllowed = (keyMode & S_IROTH);
+
+		if ( !(uAllowed || gAllowed || oAllowed) ) {
+			return 0; // -1
+		}
+	}
+
+	if ( (mode & W_OK) ) {
+		// Is allowed to write ?
+		uAllowed = (keyMode & S_IWUSR) && (keyUid == euid);
+		gAllowed = (keyMode & S_IWGRP) && (keyGid == egid);
+		oAllowed = (keyMode & S_IWOTH);
+
+		if ( !(uAllowed || gAllowed || oAllowed) ) {
+			return 0; // -1
+		}
+	}
+
+	if ( (mode & X_OK) ) {
+		// Is allowed to write ?
+		uAllowed = (keyMode & S_IXUSR) && (keyUid == euid);
+		gAllowed = (keyMode & S_IXGRP) && (keyGid == egid);
+		oAllowed = (keyMode & S_IXOTH);
+
+		if ( !(uAllowed || gAllowed || oAllowed) ) {
+			return 0; // -1
+		}
+	}
+
+	return 0;
+}
+
+bool checkKeyAccess(const QString &keyName, int mode)
+{
+	int accessOK = keyAccess(keyName, mode);
+	if ( accessOK == 0 )
+		return true;  // OK, I can really access the file
+
+	// else
+	// if we want to write the key would be created. Check, if the
+	// user may write to the directory to create the file.
+	if ( (mode & W_OK) == 0 )
+		return false;   // Check for write access is not part of mode => bail out
+
+	if (!keyAccess( keyName, F_OK)) // if it already exists
+		return false;
+
+	//strip the filename (everything until '/' from the end
+	Key *key;
+	key = keyNew(keyName.latin1(), KEY_SWITCH_END);
+	accessOK = keyAccess( QString(keyStealBaseName(key)), W_OK );
+	// -?- Can I write to the accessed diretory
+	if ( accessOK == 0 )
+		return true;  // Yes
+	else
+		return false; // No
+}
+
+bool KConfigElektraParser::checkConfigFilesWritable(bool warnUser)
+{	
+	// WARNING: Do NOT use the event loop as it may not exist at this time.
+	bool allWritable = true;
+
+	QString errorMsg( i18n("Will not save configuration.\n") );
+	if ( !mfileName.isEmpty() && !bFileImmutable && !checkKeyAccess(mLocalKeyRoot, W_OK) ) {
+		allWritable = false;
+		errorMsg += i18n("Configuration key \"%1\" not writable.\n").arg(mLocalKeyRoot);
+	}
+
+	// We do not have an immutability flag for kdeglobals. However, making kdeglobals mutable while making
+	// the local config file immutable is senseless.
+	if ( useKDEGlobals && !bFileImmutable && !checkKeyAccess(mGlobalKeyRoot, W_OK) ) {
+		errorMsg += i18n("Configuration key \"%1\" not writable.\n").arg(mGlobalKeyRoot);
+		allWritable = false;
+	}
+
+	if (warnUser && !allWritable) {
+		// Note: We don't ask the user if we should not ask this question again because we can't save the answer.
+		errorMsg += i18n("Please contact your system administrator.");
+		QString cmdToExec = KStandardDirs::findExe(QString("kdialog"));
+		KApplication *app = kapp;
+		if (!cmdToExec.isEmpty() && app) {
+			KProcess lprocess;
+			lprocess << cmdToExec << "--title" << app->instanceName() << "--msgbox" << errorMsg.local8Bit();
+			lprocess.start( KProcess::Block );
+		}
+	} 
+
+	return allWritable;
+}	
diff -Naur kdelibs-3.5.2.orig/kdecore/kconfigelektraparser.h kdelibs-3.5.2/kdecore/kconfigelektraparser.h
--- kdelibs-3.5.2.orig/kdecore/kconfigelektraparser.h	1970-01-01 01:00:00.000000000 +0100
+++ kdelibs-3.5.2/kdecore/kconfigelektraparser.h	2006-05-08 22:53:42.000000000 +0200
@@ -0,0 +1,48 @@
+/*
+	KConfigElektraParser
+	Yannick Lecaillez - <sizon5@gmail.com>
+
+	KConfig configuration parser using elektra as backend.
+*/
+
+#ifndef _KCONFIGELEKTRAPARSER_H
+#define _KCONFIGELEKTRAPARSER_H
+
+#include "kconfigdata.h"
+#include <kconfigbase.h>
+#include "kconfigparser.h"
+#include <klockfile.h>
+#include "kdelibs_export.h"
+
+class QFileInfo;
+
+class KDECORE_EXPORT KConfigElektraParser : public KConfigParser
+{
+	public:
+		KConfigElektraParser(KConfigBase *config, const QString &fileName, const char *resType, bool useKDEGlobals);
+
+   		static bool KConfigElektraParser::keyExists(QString keyName);
+   		static void writeKeys(QString keyRoot, const KEntryMap &map, QString localeString,  QFileInfo fileInfo);
+   		static QString fileNameToKeyRoot(QString absFileName);
+
+		virtual bool parseConfigFiles();
+		virtual void sync(bool bMerge);
+		virtual bool checkConfigFilesWritable(bool warnUser);
+		virtual KLockFile::Ptr lockFile(bool bGlobal);
+	
+	protected:
+		bool isAbsoluteKeyName(const QString &keyName);
+		static QString escapeGroupName(const QString &groupName);
+		void parseKeysFrom(QString keyRoot, KEntryMap *pWriteBackMap = 0L,
+			     bool bGlobal = false, bool bDefault = false);
+		bool writeConfigKeys(QString &keyRoot, bool bGlobal = false, bool bMerge = true);
+		bool getEntryMap(KEntryMap &map, bool bGlobal, QString mergeKey);
+		void writeEntries(QString &keyRoot, const KEntryMap &aTempMap);
+
+	private:
+		QString	mLocalKeyRoot;
+		QString mGlobalKeyRoot;
+
+};
+
+#endif
diff -Naur kdelibs-3.5.2.orig/kdecore/kconfiginiparser.cpp kdelibs-3.5.2/kdecore/kconfiginiparser.cpp
--- kdelibs-3.5.2.orig/kdecore/kconfiginiparser.cpp	1970-01-01 01:00:00.000000000 +0100
+++ kdelibs-3.5.2/kdecore/kconfiginiparser.cpp	2006-05-08 23:01:19.000000000 +0200
@@ -0,0 +1,1057 @@
+/*
+	KConfigINIParser
+	
+	Yannick Lecaillez - <sizon5@gmail.com>
+
+	KConfig configuration parser using INI file.
+	This is a simple restructuration of the original KConfigINIBackEnd
+	written by
+
+	Copyright (c) 1999 Preston Brown <pbrown@kde.org>
+	Copyright (c) 1997-1999 Matthias Kalle Dalheimer <kalle@kde.org>
+*/
+
+
+#include <config.h>
+
+#include <unistd.h>
+#include <ctype.h>
+#ifdef HAVE_SYS_MMAN_H
+#include <sys/mman.h>
+#endif
+#include <sys/types.h>
+#ifdef HAVE_SYS_STAT_H
+#include <sys/stat.h>
+#endif
+#include <fcntl.h>
+#include <signal.h>
+#include <setjmp.h>
+ 
+#include <qdir.h>
+#include <qfileinfo.h>
+#include <qtextcodec.h>
+#include <qtextstream.h>
+ 
+#include "kconfigbase.h"
+#include <kapplication.h>
+#include <kglobal.h>
+#include <kprocess.h>
+#include <klocale.h>
+#include <kstandarddirs.h>
+#include <ksavefile.h>
+#include <kurl.h>
+#include <kde_file.h>
+
+#include "kconfigparser.h"
+#include "kconfiginiparser.h"
+
+extern bool checkAccess(const QString& pathname, int mode);
+/* translate escaped escape sequences to their actual values. */
+static QCString printableToString(const char *str, int l)
+{
+  // Strip leading white-space.
+  while((l>0) &&
+        ((*str == ' ') || (*str == '\t') || (*str == '\r')))
+  {
+     str++; l--;
+  }
+
+  // Strip trailing white-space.
+  while((l>0) &&
+        ((str[l-1] == ' ') || (str[l-1] == '\t') || (str[l-1] == '\r')))
+  {
+     l--;
+  }
+
+  QCString result(l + 1);
+  char *r = result.data();
+
+  for(int i = 0; i < l;i++, str++)
+  {
+     if (*str == '\\')
+     {
+        i++, str++;
+        if (i >= l) // End of line. (Line ends with single slash)
+        {
+           *r++ = '\\';
+           break;
+        }
+        switch(*str)
+        {
+           case 's':
+              *r++ = ' ';
+              break;
+           case 't':
+              *r++ = '\t';
+              break;
+           case 'n':
+              *r++ = '\n';
+              break;
+           case 'r':
+              *r++ = '\r';
+              break;
+           case '\\':
+              *r++ = '\\';
+              break;
+           default:
+              *r++ = '\\';
+              *r++ = *str;
+        }
+     }
+     else
+     {
+        *r++ = *str;
+     }
+  }
+  result.truncate(r-result.data());
+  return result;
+}
+
+static QCString stringToPrintable(const QCString& str){
+  QCString result(str.length()*2); // Maximum 2x as long as source string
+  register char *r = result.data();
+  register char *s = str.data();
+
+  if (!s) return QCString("");
+
+  // Escape leading space
+  if (*s == ' ')
+  {
+     *r++ = '\\'; *r++ = 's';
+     s++;
+  }
+
+  if (*s)
+  {
+   while(*s)
+   {
+    if (*s == '\n')
+    {
+      *r++ = '\\'; *r++ = 'n';
+    }
+    else if (*s == '\t')
+    {
+      *r++ = '\\'; *r++ = 't';
+    }
+    else if (*s == '\r')
+    {
+      *r++ = '\\'; *r++ = 'r';
+    }
+    else if (*s == '\\')
+    {
+      *r++ = '\\'; *r++ = '\\';
+    }
+    else
+    {
+      *r++ = *s;
+    }
+    s++;
+   }
+   // Escape trailing space
+   if (*(r-1) == ' ')
+   {
+      *(r-1) = '\\'; *r++ = 's';
+   }
+  }
+
+  result.truncate(r - result.data());
+  return result;
+}
+
+static QCString decodeGroup(const char*s, int l)
+{
+  QCString result(l);
+  register char *r = result.data();
+
+  l--; // Correct for trailing \0
+  while(l)
+  {
+    if ((*s == '[') && (l > 1))
+    {
+       if ((*(s+1) == '['))
+       {
+          l--;
+          s++;
+       }
+    }
+    if ((*s == ']') && (l > 1))
+    {
+       if ((*(s+1) == ']'))
+       {
+          l--;
+          s++;
+       }
+    }
+    *r++ = *s++;
+    l--;
+  }
+  result.truncate(r - result.data());
+  return result;
+}
+
+static QCString encodeGroup(const QCString &str)
+{
+  int l = str.length();
+  QCString result(l*2+1);
+  register char *r = result.data();
+  register char *s = str.data();
+  while(l)
+  {
+    if ((*s == '[') || (*s == ']'))
+       *r++ = *s;
+    *r++ = *s++;
+    l--;
+  }
+  result.truncate(r - result.data());
+  return result;
+}
+
+
+KConfigINIParser::KConfigINIParser(KConfigBase *config, const QString &fileName, const char *resType, bool useKDEGlobals) : KConfigParser(config, fileName, resType, useKDEGlobals)
+{
+	if (fileName.isEmpty())
+		mLocalFileName = QString::null;
+	else if (!QDir::isRelativePath(mfileName))
+		mLocalFileName = mfileName;
+	else
+		mLocalFileName = KGlobal::dirs()->saveLocation(resType) + mfileName;
+
+	if (useKDEGlobals)
+		mGlobalFileName = KGlobal::dirs()->saveLocation("config") + QString::fromLatin1("kdeglobals");
+	else
+		mGlobalFileName = QString::null;
+
+	mLocalLastModified = QDateTime();
+	mLocalLastSize = 0;
+	mLocalLockFile = 0;
+	mGlobalLockFile = 0;
+}
+
+bool KConfigINIParser::parseConfigFiles()
+{
+	// Check if we can write to the local file.
+	mConfigState = KConfigBase::ReadOnly;
+	if (!mLocalFileName.isEmpty() && !pConfig->isReadOnly()) {
+		if (checkAccess(mLocalFileName, W_OK)) {
+			mConfigState = KConfigBase::ReadWrite;
+		} else {
+        		// Create the containing dir, maybe it wasn't there
+		        KURL path;
+		        path.setPath(mLocalFileName);
+		        QString dir=path.directory();
+		        KStandardDirs::makeDir(dir);
+
+		        if (checkAccess(mLocalFileName, W_OK)) {
+				mConfigState = KConfigBase::ReadWrite;
+			}
+		}
+		QFileInfo info(mLocalFileName);
+		mLocalLastModified = info.lastModified();
+		mLocalLastSize = info.size();
+	}
+
+	// Parse all desired files from the least to the most specific.
+	bFileImmutable = false;
+
+	// Parse the general config files
+	if (useKDEGlobals) {
+		QStringList kdercs = KGlobal::dirs()-> findAllResources("config", QString::fromLatin1("kdeglobals"));
+
+#ifdef Q_WS_WIN
+		QString etc_kderc = QFile::decodeName( QCString(getenv("WINDIR")) + "\\kderc" );
+#else
+		QString etc_kderc = QString::fromLatin1("/etc/kderc");
+#endif
+
+		if (checkAccess(etc_kderc, R_OK))
+			kdercs += etc_kderc;
+
+		kdercs += KGlobal::dirs()-> findAllResources("config", QString::fromLatin1("system.kdeglobals"));
+
+		QStringList::ConstIterator it;
+
+		for (it = kdercs.fromLast(); it != kdercs.end(); --it) {
+			QFile aConfigFile( *it );
+			if (!aConfigFile.open( IO_ReadOnly ))
+				continue;
+			parseSingleConfigFile( aConfigFile, 0L, true, (*it != mGlobalFileName) );
+			aConfigFile.close();
+			if (bFileImmutable)
+				break;
+		}
+	}
+
+	bool bReadFile = !mfileName.isEmpty();
+	while(bReadFile) {
+		bReadFile = false;
+		QString bootLanguage;
+		if (useKDEGlobals && localeString.isEmpty() && !KGlobal::_locale) {
+			// Boot strap language
+			bootLanguage = KLocale::_initLanguage(pConfig);
+			setLocaleString(bootLanguage.utf8());
+		}
+
+		bFileImmutable = false;
+		QStringList list;
+		if ( !QDir::isRelativePath(mfileName) )
+			list << mfileName;
+		else
+			list = KGlobal::dirs()->findAllResources(resType, mfileName);
+
+		QStringList::ConstIterator it;
+
+		for (it = list.fromLast(); it != list.end(); --it) {
+			QFile aConfigFile( *it );
+			// we can already be sure that this file exists
+			bool bIsLocal = (*it == mLocalFileName);
+			if (aConfigFile.open( IO_ReadOnly )) {
+				parseSingleConfigFile( aConfigFile, 0L, false, !bIsLocal );
+				aConfigFile.close();
+				if (bFileImmutable)
+					break;
+			}
+		}
+		if (KGlobal::dirs()->isRestrictedResource(resType, mfileName))
+			bFileImmutable = true;
+		
+		QString currentLanguage;
+		if (!bootLanguage.isEmpty()) {
+			currentLanguage = KLocale::_initLanguage(pConfig);
+			// If the file changed the language, we need to read the file again
+			// with the new language setting.
+			if (bootLanguage != currentLanguage) {
+				bReadFile = true;
+				setLocaleString(currentLanguage.utf8());
+			}
+		}
+	}
+	if (bFileImmutable)
+		mConfigState = KConfigBase::ReadOnly;
+
+	return true;
+}
+
+#ifdef HAVE_MMAP
+#ifdef SIGBUS
+static sigjmp_buf mmap_jmpbuf;
+struct sigaction mmap_old_sigact;
+
+extern "C" {
+   static void mmap_sigbus_handler(int)
+   {
+      siglongjmp (mmap_jmpbuf, 1);
+   }
+}
+#endif
+#endif
+
+extern bool kde_kiosk_exception;
+
+void KConfigINIParser::parseSingleConfigFile(QFile &rFile,
+					      KEntryMap *pWriteBackMap,
+					      bool bGlobal, bool bDefault)
+{
+   const char *s; // May get clobbered by sigsetjump, but we don't use them afterwards.
+   const char *eof; // May get clobbered by sigsetjump, but we don't use them afterwards.
+   QByteArray data;
+
+   if (!rFile.isOpen()) // come back, if you have real work for us ;->
+      return;
+
+
+   //using kdDebug() here leads to an infinite loop
+   //remove this for the release, aleXXX
+   //qWarning("Parsing %s, global = %s default = %s",
+   //           rFile.name().latin1(), bGlobal ? "true" : "false", bDefault ? "true" : "false");
+
+   QCString aCurrentGroup("<default>");
+
+   unsigned int ll = localeString.length();
+
+#ifdef HAVE_MMAP
+   static volatile const char *map;
+   map = ( const char* ) mmap(0, rFile.size(), PROT_READ, MAP_PRIVATE,
+                                          rFile.handle(), 0);
+
+   if ( map != MAP_FAILED )
+   {
+      s = (const char*) map;
+      eof = s + rFile.size();
+
+#ifdef SIGBUS
+      struct sigaction act;
+      act.sa_handler = mmap_sigbus_handler;
+      sigemptyset( &act.sa_mask );
+#ifdef SA_ONESHOT
+      act.sa_flags = SA_ONESHOT;
+#else
+      act.sa_flags = SA_RESETHAND;
+#endif      
+      sigaction( SIGBUS, &act, &mmap_old_sigact );
+
+      if (sigsetjmp (mmap_jmpbuf, 1))
+      {
+qWarning("SIGBUS while reading %s", rFile.name().latin1());
+         munmap(( char* )map, rFile.size());
+         sigaction (SIGBUS, &mmap_old_sigact, 0);
+         return;
+      }
+#endif
+   }
+   else
+#endif
+   {
+      rFile.at(0);
+      data = rFile.readAll();
+      s = data.data();
+      eof = s + data.size();
+   }
+
+   bool fileOptionImmutable = false;
+   bool groupOptionImmutable = false;
+   bool groupSkip = false;
+
+   int line = 0;
+      
+   for(; s < eof; s++)
+   {
+      line++;
+
+      while((s < eof) && isspace(*s) && (*s != '\n'))
+         s++; //skip leading whitespace, shouldn't happen too often
+
+      //skip empty lines, lines starting with #
+      if ((s < eof) && ((*s == '\n') || (*s == '#')))
+      {
+    sktoeol:	//skip till end-of-line
+         while ((s < eof) && (*s != '\n'))
+            s++;
+         continue; // Empty or comment or no keyword
+      }
+      const char *startLine = s;
+
+      if (*s == '[')  //group
+      {
+         // In a group [[ and ]] have a special meaning
+         while ((s < eof) && (*s != '\n')) 
+         {
+            if (*s == ']')
+            {
+               if ((s+1 < eof) && (*(s+1) == ']'))
+                  s++; // Skip "]]"
+               else
+                  break;
+            }
+
+            s++; // Search till end of group
+         }
+         const char *e = s;
+         while ((s < eof) && (*s != '\n')) s++; // Search till end of line / end of file
+         if ((e >= eof) || (*e != ']'))
+         {
+            fprintf(stderr, "Invalid group header at %s:%d\n", rFile.name().latin1(), line);
+            continue;
+         }
+         // group found; get the group name by taking everything in
+         // between the brackets
+         if ((e-startLine == 3) &&
+             (startLine[1] == '$') &&
+             (startLine[2] == 'i'))
+         {
+            if (!kde_kiosk_exception)
+               fileOptionImmutable = true;
+            continue;
+         }
+
+         aCurrentGroup = decodeGroup(startLine + 1, e - startLine);
+         //cout<<"found group ["<<aCurrentGroup<<"]"<<endl;
+
+         // Backwards compatibility
+         if (aCurrentGroup == "KDE Desktop Entry")
+            aCurrentGroup = "Desktop Entry";
+
+         groupOptionImmutable = fileOptionImmutable;
+
+         e++;
+         if ((e+2 < eof) && (*e++ == '[') && (*e++ == '$')) // Option follows
+         {
+            if ((*e == 'i') && !kde_kiosk_exception)
+            {
+               groupOptionImmutable = true;
+            }
+         }
+
+         KEntryKey groupKey(aCurrentGroup, 0);
+         KEntry entry = pConfig->lookupData(groupKey);
+         groupSkip = entry.bImmutable;
+
+         if (groupSkip && !bDefault)
+            continue;
+
+	 entry.bImmutable |= groupOptionImmutable;
+         pConfig->putData(groupKey, entry, false);
+
+         if (pWriteBackMap)
+         {
+            // add the special group key indicator
+            (*pWriteBackMap)[groupKey] = entry;
+         }
+
+         continue;
+      }
+      if (groupSkip && !bDefault)
+        goto sktoeol; // Skip entry
+
+      bool optionImmutable = groupOptionImmutable;
+      bool optionDeleted = false;
+      bool optionExpand = false;
+      const char *endOfKey = 0, *locale = 0, *elocale = 0;
+      for (; (s < eof) && (*s != '\n'); s++)
+      {
+         if (*s == '=') //find the equal sign
+         {
+	    if (!endOfKey)
+        	endOfKey = s;
+            goto haveeq;
+	 }
+	 if (*s == '[') //find the locale or options.
+	 {
+            const char *option;
+            const char *eoption;
+	    endOfKey = s;
+	    option = ++s;
+	    for (;; s++)
+	    {
+		if ((s >= eof) || (*s == '\n') || (*s == '=')) {
+		    fprintf(stderr, "Invalid entry (missing ']') at %s:%d\n", rFile.name().latin1(), line);
+		    goto sktoeol;
+		}
+		if (*s == ']')
+		    break;
+	    }
+	    eoption = s;
+            if (*option != '$')
+            {
+              // Locale
+              if (locale) {
+		fprintf(stderr, "Invalid entry (second locale!?) at %s:%d\n", rFile.name().latin1(), line);
+		goto sktoeol;
+              }
+              locale = option;
+              elocale = eoption;
+            }
+            else
+            {
+              // Option
+              while (option < eoption)
+              {
+                 option++;
+                 if ((*option == 'i') && !kde_kiosk_exception)
+                    optionImmutable = true;
+                 else if (*option == 'e')
+                    optionExpand = true;
+                 else if (*option == 'd')
+                 {
+                    optionDeleted = true;
+                    goto haveeq;
+                 }
+		 else if (*option == ']')
+		    break;
+              }
+            }
+         }
+      }
+      fprintf(stderr, "Invalid entry (missing '=') at %s:%d\n", rFile.name().latin1(), line);
+      continue;
+
+   haveeq:
+      for (endOfKey--; ; endOfKey--)
+      {
+	 if (endOfKey < startLine)
+	 {
+	   fprintf(stderr, "Invalid entry (empty key) at %s:%d\n", rFile.name().latin1(), line);
+	   goto sktoeol;
+	 }
+	 if (!isspace(*endOfKey))
+	    break;
+      }
+
+      const char *st = ++s;
+      while ((s < eof) && (*s != '\n')) s++; // Search till end of line / end of file
+
+      if (locale) {
+          unsigned int cl = static_cast<unsigned int>(elocale - locale);
+          if ((ll != cl) || memcmp(locale, localeString.data(), ll))
+          {
+              // backward compatibility. C == en_US
+              if ( cl != 1 || ll != 5 || *locale != 'C' || memcmp(localeString.data(), "en_US", 5)) {
+                  //cout<<"mismatched locale '"<<QCString(locale, elocale-locale +1)<<"'"<<endl;
+                  // We can ignore this one
+                  if (!pWriteBackMap)
+                      continue; // We just ignore it
+                  // We just store it as is to be able to write it back later.
+                  endOfKey = elocale;
+                  locale = 0;
+              }
+          }
+      }
+
+      // insert the key/value line
+      QCString key(startLine, endOfKey - startLine + 2);
+      QCString val = printableToString(st, s - st);
+      //qDebug("found key '%s' with value '%s'", key.data(), val.data());
+
+      KEntryKey aEntryKey(aCurrentGroup, key);
+      aEntryKey.bLocal = (locale != 0);
+      aEntryKey.bDefault = bDefault;
+
+      KEntry aEntry;
+      aEntry.mValue = val;
+      aEntry.bGlobal = bGlobal;
+      aEntry.bImmutable = optionImmutable;
+      aEntry.bDeleted = optionDeleted;
+      aEntry.bExpand = optionExpand;
+      aEntry.bNLS = (locale != 0);
+
+      if (pWriteBackMap) {
+         // don't insert into the config object but into the temporary
+         // scratchpad map
+         pWriteBackMap->insert(aEntryKey, aEntry);
+      } else {
+         // directly insert value into config object
+         // no need to specify localization; if the key we just
+         // retrieved was localized already, no need to localize it again.
+         pConfig->putData(aEntryKey, aEntry, false);
+      }
+   }
+
+   if (fileOptionImmutable)
+      bFileImmutable = true;
+
+#ifdef HAVE_MMAP
+   if (map)
+   {
+      munmap(( char* )map, rFile.size());
+#ifdef SIGBUS
+      sigaction (SIGBUS, &mmap_old_sigact, 0);
+#endif
+   }
+#endif
+}
+
+
+void KConfigINIParser::sync(bool bMerge)
+{
+
+  // write-sync is only necessary if there are dirty entries
+  if (!pConfig->isDirty())
+    return;
+
+  bool bEntriesLeft = true;
+
+  // find out the file to write to (most specific writable file)
+  // try local app-specific file first
+
+  if (!mfileName.isEmpty()) {
+    // Create the containing dir if needed
+    if ((resType!="config") && !QDir::isRelativePath(mLocalFileName))
+    {
+       KURL path;
+       path.setPath(mLocalFileName);
+       QString dir=path.directory();
+       KStandardDirs::makeDir(dir);
+    }
+
+    // Can we allow the write? We can, if the program
+    // doesn't run SUID. But if it runs SUID, we must
+    // check if the user would be allowed to write if
+    // it wasn't SUID.
+    if (checkAccess(mLocalFileName, W_OK)) {
+      // File is writable
+      KLockFile::Ptr lf;
+
+      bool mergeLocalFile = bMerge;
+      // Check if the file has been updated since.
+      if (mergeLocalFile)
+      {
+         lf = lockFile(false); // Lock file for local file
+         if (lf && lf->isLocked())
+            lf = 0; // Already locked, we don't need to lock/unlock again
+
+         if (lf) 
+         {
+            lf->lock( KLockFile::LockForce );
+            // But what if the locking failed? Ignore it for now...
+         }
+         
+         QFileInfo info(mLocalFileName);
+         if ((mLocalLastSize == info.size()) &&
+             (mLocalLastModified == info.lastModified()))
+         {
+            // Not changed, don't merge.
+            mergeLocalFile = false;
+         }
+         else
+         {
+            // Changed...
+            mLocalLastModified = QDateTime();
+            mLocalLastSize = 0;
+         }
+      }
+
+      bEntriesLeft = writeConfigFile( mLocalFileName, false, mergeLocalFile );
+      
+      // Only if we didn't have to merge anything can we use our in-memory state
+      // the next time around. Otherwise the config-file may contain entries
+      // that are different from our in-memory state which means we will have to 
+      // do a merge from then on. 
+      // We do not automatically update the in-memory state with the on-disk 
+      // state when writing the config to disk. We only do so when 
+      // KCOnfig::reparseConfiguration() is called.
+      // For KDE 4.0 we may wish to reconsider that.
+      if (!mergeLocalFile)
+      {
+         QFileInfo info(mLocalFileName);
+         mLocalLastModified = info.lastModified();
+         mLocalLastSize = info.size();
+      }
+      if (lf) lf->unlock();
+    }
+  }
+
+  // only write out entries to the kdeglobals file if there are any
+  // entries marked global (indicated by bEntriesLeft) and
+  // the useKDEGlobals flag is set.
+  if (bEntriesLeft && useKDEGlobals) {
+
+    // can we allow the write? (see above)
+    if (checkAccess ( mGlobalFileName, W_OK )) {
+      KLockFile::Ptr lf = lockFile(true); // Lock file for global file
+      if (lf && lf->isLocked())
+         lf = 0; // Already locked, we don't need to lock/unlock again
+
+      if (lf) 
+      {
+         lf->lock( KLockFile::LockForce );
+         // But what if the locking failed? Ignore it for now...
+      }
+      writeConfigFile( mGlobalFileName, true, bMerge ); // Always merge
+      if (lf) lf->unlock();
+    }
+  }
+
+}
+
+static void writeEntries(FILE *pStream, const KEntryMap& entryMap, bool defaultGroup, bool &firstEntry, const QCString &localeString)
+{
+  // now write out all other groups.
+  QCString currentGroup;
+  for (KEntryMapConstIterator aIt = entryMap.begin();
+       aIt != entryMap.end(); ++aIt)
+  {
+     const KEntryKey &key = aIt.key();
+
+     // Either proces the default group or all others
+     if ((key.mGroup != "<default>") == defaultGroup)
+        continue; // Skip
+
+     // Skip default values and group headers.
+     if ((key.bDefault) || key.mKey.isEmpty())
+        continue; // Skip
+
+     const KEntry &currentEntry = *aIt;
+
+     KEntryMapConstIterator aTestIt = aIt;
+     ++aTestIt;
+     bool hasDefault = (aTestIt != entryMap.end());
+     if (hasDefault)
+     {
+        const KEntryKey &defaultKey = aTestIt.key();
+        if ((!defaultKey.bDefault) ||
+            (defaultKey.mKey != key.mKey) ||
+            (defaultKey.mGroup != key.mGroup) ||
+            (defaultKey.bLocal != key.bLocal))
+           hasDefault = false;
+     }
+
+
+     if (hasDefault)
+     {
+        // Entry had a default value
+        if ((currentEntry.mValue == (*aTestIt).mValue) &&
+            (currentEntry.bDeleted == (*aTestIt).bDeleted))
+           continue; // Same as default, don't write.
+     }
+     else
+     {
+        // Entry had no default value.
+        if (currentEntry.bDeleted)
+           continue; // Don't write deleted entries if there is no default.
+     }
+
+     if (!defaultGroup && (currentGroup != key.mGroup)) {
+	if (!firstEntry)
+	    fprintf(pStream, "\n");
+	currentGroup = key.mGroup;
+	fprintf(pStream, "[%s]\n", encodeGroup(currentGroup).data());
+     }
+
+     firstEntry = false;
+     // it is data for a group
+     fputs(key.mKey.data(), pStream); // Key
+
+     if ( currentEntry.bNLS )
+     {
+        fputc('[', pStream);
+        fputs(localeString.data(), pStream);
+        fputc(']', pStream);
+     }
+
+     if (currentEntry.bDeleted)
+     {
+        fputs("[$d]\n", pStream); // Deleted
+     }
+     else
+     {
+        if (currentEntry.bImmutable || currentEntry.bExpand)
+        {
+           fputc('[', pStream);
+           fputc('$', pStream);
+           if (currentEntry.bImmutable)
+              fputc('i', pStream);
+           if (currentEntry.bExpand)
+              fputc('e', pStream);
+
+           fputc(']', pStream);
+        }
+        fputc('=', pStream);
+        fputs(stringToPrintable(currentEntry.mValue).data(), pStream);
+        fputc('\n', pStream);
+     }
+  } // for loop
+}
+
+bool KConfigINIParser::getEntryMap(KEntryMap &aTempMap, bool bGlobal,
+                                    QFile *mergeFile)
+{
+  bool bEntriesLeft = false;
+  bFileImmutable = false;
+
+  // Read entries from disk
+  if (mergeFile && mergeFile->open(IO_ReadOnly))
+  {
+     // fill the temporary structure with entries from the file
+     parseSingleConfigFile(*mergeFile, &aTempMap, bGlobal, false );
+
+     if (bFileImmutable) // File has become immutable on disk
+        return bEntriesLeft;
+  }
+
+  KEntryMap aMap = pConfig->internalEntryMap();
+
+  // augment this structure with the dirty entries from the config object
+  for (KEntryMapIterator aIt = aMap.begin();
+       aIt != aMap.end(); ++aIt)
+  {
+    const KEntry &currentEntry = *aIt;
+    if(aIt.key().bDefault)
+    {
+       aTempMap.replace(aIt.key(), currentEntry);
+       continue;
+    }
+
+    if (mergeFile && !currentEntry.bDirty)
+       continue;
+
+    // only write back entries that have the same
+    // "globality" as the file
+    if (currentEntry.bGlobal != bGlobal)
+    {
+       // wrong "globality" - might have to be saved later
+       bEntriesLeft = true;
+       continue;
+    }
+
+    // put this entry from the config object into the
+    // temporary map, possibly replacing an existing entry
+    KEntryMapIterator aIt2 = aTempMap.find(aIt.key());
+    if (aIt2 != aTempMap.end() && (*aIt2).bImmutable)
+       continue; // Bail out if the on-disk entry is immutable
+
+    aTempMap.insert(aIt.key(), currentEntry, true);
+  } // loop
+
+  return bEntriesLeft;
+}
+
+/* antlarr: KDE 4.0:  make the first parameter "const QString &" */
+bool KConfigINIParser::writeConfigFile(QString filename, bool bGlobal,
+					bool bMerge)
+{
+  // is the config object read-only?
+  if (pConfig->isReadOnly())
+    return true; // pretend we wrote it
+
+  KEntryMap aTempMap;
+  QFile *mergeFile = (bMerge ? new QFile(filename) : 0);
+  bool bEntriesLeft = getEntryMap(aTempMap, bGlobal, mergeFile);
+  delete mergeFile;
+  if (bFileImmutable)
+    return true; // pretend we wrote it
+
+  // OK now the temporary map should be full of ALL entries.
+  // write it out to disk.
+
+  // Check if file exists:
+  int fileMode = -1;
+  bool createNew = true;
+
+  KDE_struct_stat buf;
+  if (KDE_stat(QFile::encodeName(filename), &buf) == 0)
+  {
+     if (buf.st_uid == getuid())
+     {
+        // Preserve file mode if file exists and is owned by user.
+        fileMode = buf.st_mode & 0777;
+     }
+     else
+     {
+        // File is not owned by user:
+        // Don't create new file but write to existing file instead.
+        createNew = false;
+     }
+  }
+
+  KSaveFile *pConfigFile = 0;
+  FILE *pStream = 0;
+
+  if (createNew)
+  {
+     pConfigFile = new KSaveFile( filename, 0600 );
+
+     if (pConfigFile->status() != 0)
+     {
+        delete pConfigFile;
+        return bEntriesLeft;
+     }
+
+     if (!bGlobal && (fileMode == -1))
+        fileMode = mFileMode;
+
+     if (fileMode != -1)
+     {
+        fchmod(pConfigFile->handle(), fileMode);
+     }
+
+     pStream = pConfigFile->fstream();
+  }
+  else
+  {
+     // Open existing file.
+     // We use open() to ensure that we call without O_CREAT.
+     int fd = KDE_open( QFile::encodeName(filename), O_WRONLY | O_TRUNC );
+     if (fd < 0)
+     {
+        return bEntriesLeft;
+     }
+     pStream = KDE_fdopen( fd, "w");
+     if (!pStream)
+     {
+        close(fd);
+        return bEntriesLeft;
+     }
+  }
+
+  writeEntries(pStream, aTempMap);
+
+  if (pConfigFile)
+  {
+     bool bEmptyFile = (ftell(pStream) == 0);
+     if ( bEmptyFile && ((fileMode == -1) || (fileMode == 0600)) )
+     {
+        // File is empty and doesn't have special permissions: delete it.
+        ::unlink(QFile::encodeName(filename));
+        pConfigFile->abort();
+     }
+     else
+     {
+        // Normal case: Close the file
+        pConfigFile->close();
+     }
+     delete pConfigFile;
+  }
+  else
+  {
+     fclose(pStream);
+  }
+
+  return bEntriesLeft;
+}
+
+void KConfigINIParser::writeEntries(FILE *pStream, const KEntryMap &aTempMap)
+{
+  bool firstEntry = true;
+
+  // Write default group
+  ::writeEntries(pStream, aTempMap, true, firstEntry, localeString);
+
+  // Write all other groups
+  ::writeEntries(pStream, aTempMap, false, firstEntry, localeString);
+}
+
+KLockFile::Ptr KConfigINIParser::lockFile(bool bGlobal)
+{
+	if (bGlobal) {
+		if (mGlobalLockFile)
+			return mGlobalLockFile;
+      
+		if (!mGlobalFileName.isEmpty()) {
+			mGlobalLockFile = new KLockFile(mGlobalFileName+".lock");
+			return mGlobalLockFile;
+		}
+	} else {
+		if (mLocalLockFile)
+			return mLocalLockFile;
+
+		if (!mLocalFileName.isEmpty()) {
+			mLocalLockFile = new KLockFile(mLocalFileName+".lock");
+			return mLocalLockFile;
+		}
+	}
+
+	return 0;
+}
+
+bool KConfigINIParser::checkConfigFilesWritable(bool warnUser)
+{
+  // WARNING: Do NOT use the event loop as it may not exist at this time.
+  bool allWritable = true;
+  QString errorMsg( i18n("Will not save configuration.\n") );
+  if ( !mLocalFileName.isEmpty() && !bFileImmutable && !checkAccess(mLocalFileName,W_OK) )
+  {
+    allWritable = false;
+    errorMsg += i18n("Configuration file \"%1\" not writable.\n").arg(mLocalFileName);
+  }
+  // We do not have an immutability flag for kdeglobals. However, making kdeglobals mutable while making
+  // the local config file immutable is senseless.
+  if ( !mGlobalFileName.isEmpty() && useKDEGlobals && !bFileImmutable && !checkAccess(mGlobalFileName,W_OK) )
+  {
+    errorMsg += i18n("Configuration file \"%1\" not writable.\n").arg(mGlobalFileName);
+    allWritable = false;
+  }
+
+  if (warnUser && !allWritable)
+  {
+    // Note: We don't ask the user if we should not ask this question again because we can't save the answer.
+    errorMsg += i18n("Please contact your system administrator.");
+    QString cmdToExec = KStandardDirs::findExe(QString("kdialog"));
+    KApplication *app = kapp;
+    if (!cmdToExec.isEmpty() && app)
+    {
+      KProcess lprocess;
+      lprocess << cmdToExec << "--title" << app->instanceName() << "--msgbox" << errorMsg.local8Bit();
+      lprocess.start( KProcess::Block );
+    }
+  }
+  return allWritable;
+}	
diff -Naur kdelibs-3.5.2.orig/kdecore/kconfiginiparser.h kdelibs-3.5.2/kdecore/kconfiginiparser.h
--- kdelibs-3.5.2.orig/kdecore/kconfiginiparser.h	1970-01-01 01:00:00.000000000 +0100
+++ kdelibs-3.5.2/kdecore/kconfiginiparser.h	2006-05-08 22:55:50.000000000 +0200
@@ -0,0 +1,53 @@
+/*
+	KConfigINIParser
+	
+	Yannick Lecaillez - <sizon5@gmail.com>
+
+	KConfig configuration parser using INI file.
+	This is a simple restruction of the original KConfigINIBackEnd
+	written by
+
+	Copyright (c) 1999 Preston Brown <pbrown@kde.org>
+	Copyright (c) 1997-1999 Matthias Kalle Dalheimer <kalle@kde.org>
+*/
+
+#ifndef _KCONFIGINIPARSER_H
+#define _KCONFIGINIPARSER_H
+
+#include "kconfigdata.h"
+#include <kconfigbase.h>
+#include "kconfigparser.h"
+#include <klockfile.h>
+#include "kdelibs_export.h"
+
+class QFile;
+class QDir;
+
+class KDECORE_EXPORT KConfigINIParser : public KConfigParser
+{
+	public:
+		KConfigINIParser(KConfigBase *config, const QString &fileName, const char *resType, bool useKDEGlobals);
+
+		virtual bool parseConfigFiles();
+		virtual void sync(bool bMerge);
+		virtual bool checkConfigFilesWritable(bool warnUser);
+		virtual KLockFile::Ptr lockFile(bool bGlobal);
+	
+	protected:
+		void parseSingleConfigFile(QFile &rFile, KEntryMap *pWriteBackMap,
+					      bool bGlobal, bool bDefault);
+		bool writeConfigFile(QString filename, bool bGlobal = false, bool bMerge = true);
+		bool getEntryMap(KEntryMap &map, bool bGlobal, QFile *mergeFile);
+		void writeEntries(FILE *pStream, const KEntryMap &aTempMap);
+
+	private:
+		QString mLocalFileName;
+		QString mGlobalFileName;
+
+		QDateTime	mLocalLastModified;
+		uint		mLocalLastSize;
+		KLockFile::Ptr	mLocalLockFile;
+		KLockFile::Ptr	mGlobalLockFile;
+};
+
+#endif
diff -Naur kdelibs-3.5.2.orig/kdecore/kconfigparser.cpp kdelibs-3.5.2/kdecore/kconfigparser.cpp
--- kdelibs-3.5.2.orig/kdecore/kconfigparser.cpp	1970-01-01 01:00:00.000000000 +0100
+++ kdelibs-3.5.2/kdecore/kconfigparser.cpp	2006-05-08 19:09:03.000000000 +0200
@@ -0,0 +1,54 @@
+/*
+	KConfigParser
+	Yannick Lecaillez - <sizon5@gmail.com>
+
+	Abstract class for configuration parser.
+*/
+
+#include <config.h>
+
+#include <unistd.h>
+#include <ctype.h>
+#ifdef HAVE_SYS_MMAN_H
+#include <sys/mman.h>
+#endif
+#include <sys/types.h>
+#ifdef HAVE_SYS_STAT_H
+#include <sys/stat.h>
+#endif
+#include <fcntl.h>
+#include <signal.h>
+#include <setjmp.h>
+
+#include <qdir.h>
+#include <qfileinfo.h>
+#include <qtextcodec.h>
+#include <qtextstream.h>
+
+#include "kconfigbackend.h"
+#include "kconfigparser.h"
+#include "kconfigparserfactory.h"
+#include "kconfigbase.h"
+#include <kapplication.h>
+#include <kglobal.h>
+#include <kprocess.h>
+#include <klocale.h>
+#include <kstandarddirs.h>
+#include <ksavefile.h>
+#include <kurl.h>
+#include <kde_file.h>
+
+KConfigParser::KConfigParser(KConfigBase *_config, 
+				const QString &_fileName,
+				const char *_resType,
+				bool _useKDEGlobals)
+	: pConfig(_config), mfileName(_fileName), resType(_resType), mConfigState(KConfig::NoAccess), mFileMode(-1), useKDEGlobals(_useKDEGlobals) { }
+
+void KConfigParser::setConfigState (KConfigBase::ConfigState state) { mConfigState = state; }
+
+QString KConfigParser::fileName() { return mfileName; }
+const char *KConfigParser::resource() { return resType; }
+void KConfigParser::setFileImmutable(bool immutable) { bFileImmutable = immutable; }
+bool KConfigParser::isFileImmutable() { return bFileImmutable; }
+bool KConfigParser::isUseKDEGlobals() { return useKDEGlobals; }
+void KConfigParser::setLocaleString(const QCString locale) { localeString = locale; }
diff -Naur kdelibs-3.5.2.orig/kdecore/kconfigparserfactory.cpp kdelibs-3.5.2/kdecore/kconfigparserfactory.cpp
--- kdelibs-3.5.2.orig/kdecore/kconfigparserfactory.cpp	1970-01-01 01:00:00.000000000 +0100
+++ kdelibs-3.5.2/kdecore/kconfigparserfactory.cpp	2006-05-08 22:54:52.000000000 +0200
@@ -0,0 +1,29 @@
+/*
+	KConfigParserFactory
+	
+	Yannick Lecaillez - <sizon5@gmail.com>
+
+	Return a newly created parser depending of
+	file to parse and resource type.
+*/
+
+#include <config.h>
+#include <qdir.h>
+
+#include "kconfigparser.h"
+#include "kconfiginiparser.h"
+#include "kconfigelektraparser.h"
+#include "kconfigparserfactory.h"
+#include "kconfigbase.h"
+
+
+KConfigParser *KConfigParserFactory::create(KConfigBase *_config, const QString &_fileName, const char * _resType, bool _useKDEGlobals)
+{
+	if ( (strcmp(_resType, "config-elektra") == 0) ||
+		(strcmp(_resType, "config") == 0) && (_fileName.isEmpty() || QDir::isRelativePath(_fileName))) {
+		return new KConfigElektraParser(_config, _fileName, "config-elektra", _useKDEGlobals);
+	} else { 
+		return new KConfigINIParser(_config, _fileName, _resType, _useKDEGlobals);
+	}
+}
+
diff -Naur kdelibs-3.5.2.orig/kdecore/kconfigparserfactory.h kdelibs-3.5.2/kdecore/kconfigparserfactory.h
--- kdelibs-3.5.2.orig/kdecore/kconfigparserfactory.h	1970-01-01 01:00:00.000000000 +0100
+++ kdelibs-3.5.2/kdecore/kconfigparserfactory.h	2006-05-08 22:54:18.000000000 +0200
@@ -0,0 +1,27 @@
+/*
+	KConfigParserFactory
+	
+	Yannick Lecaillez - <sizon5@gmail.com>
+
+	Return a newly created parser depending of
+	file to parse.
+*/
+
+#ifndef _KCONFIGPARSERFACTORY_H
+#define _KCONFIGPARSERFACTORY_H
+
+#include "kconfigparser.h"
+#include "kconfigelektraparser.h"
+#include "kconfiginiparser.h"
+#include "kconfigparserfactory.h"
+#include "kconfigbase.h"
+
+class QDir;
+
+class KDECORE_EXPORT KConfigParserFactory {
+	public:
+
+		static KConfigParser *KConfigParserFactory::create(KConfigBase *_config, const QString &_fileName, const char * _resType, bool _useKDEGlobals);
+};
+
+#endif
diff -Naur kdelibs-3.5.2.orig/kdecore/kconfigparser.h kdelibs-3.5.2/kdecore/kconfigparser.h
--- kdelibs-3.5.2.orig/kdecore/kconfigparser.h	1970-01-01 01:00:00.000000000 +0100
+++ kdelibs-3.5.2/kdecore/kconfigparser.h	2006-05-08 19:09:03.000000000 +0200
@@ -0,0 +1,59 @@
+/*
+	KConfigParser
+	Yannick Lecaillez - <sizon5@gmail.com>
+
+	Abstract class for configuration parser.
+*/
+
+#ifndef _KCONFIGPARSER_H
+#define _KCONFIGPARSER_H
+
+#include "kconfig.h"
+#include "kconfigdata.h"
+#include <kconfigbase.h>
+#include <klockfile.h>
+#include "kdelibs_export.h"
+
+
+class KDECORE_EXPORT KConfigParser {
+	public:
+		KConfigParser(KConfigBase *_config, 
+				const QString &_fileName,
+				const char *_resType,
+				bool _useKDEGlobals);
+
+		void setLocateString(const QCString &_localeString) { localeString = _localeString; }
+		
+		KConfigBase::ConfigState getConfigState() const
+		 { return mConfigState; }
+		void setConfigState (KConfigBase::ConfigState state);
+
+
+		QString fileName();
+		const char *resource();
+		void setFileImmutable(bool immutable);
+		bool isFileImmutable();
+
+		bool isUseKDEGlobals();
+		
+		void setLocaleString(const QCString locale);
+
+
+		virtual bool parseConfigFiles() = 0;
+		virtual void sync(bool bMerge) = 0;
+		virtual KLockFile::Ptr lockFile(bool bGlobal) = 0;
+		virtual bool checkConfigFilesWritable(bool warnUser) = 0;
+
+
+	protected:
+		KConfigBase *pConfig;
+		QCString localeString;
+		QString mfileName;
+		QCString resType;
+		KConfigBase::ConfigState mConfigState;
+		int mFileMode;
+		bool useKDEGlobals : 1;
+		bool bFileImmutable : 1;
+};
+
+#endif
diff -Naur kdelibs-3.5.2.orig/kdecore/kstandarddirs.cpp kdelibs-3.5.2/kdecore/kstandarddirs.cpp
--- kdelibs-3.5.2.orig/kdecore/kstandarddirs.cpp	2005-10-10 17:06:02.000000000 +0200
+++ kdelibs-3.5.2/kdecore/kstandarddirs.cpp	2006-05-08 23:12:41.000000000 +0200
@@ -24,6 +24,10 @@
  * Generated:	Thu Mar  5 16:05:28 EST 1998
  */
 
+/*
+ * Patch for elektra by Yannick Lecaillez - <sizon5@gmail.com>
+ */
+
 #include "config.h"
 
 #include <stdlib.h>
@@ -46,6 +50,8 @@
 #include <qstring.h>
 #include <qstringlist.h>
 
+#include <kdb.h>
+
 #include "kstandarddirs.h"
 #include "kconfig.h"
 #include "kdebug.h"
@@ -73,6 +79,7 @@
    QAsciiDict<bool> restrictions;
    QStringList xdgdata_prefixes;
    QStringList xdgconf_prefixes;
+   QStringList elektraconf_prefixes;
 };
 
 // Singleton, with data shared by all kstandarddirs instances.
@@ -100,7 +107,9 @@
 			      "wallpaper", "lib", "pixmap", "templates",
 			      "module", "qtplugins",
 			      "xdgdata-apps", "xdgdata-dirs", "xdgconf-menu",
-			      "kcfg", "emoticons", 0 };
+			      "kcfg", "emoticons",
+			      "config-elektra",
+				0 };
 
 static int tokenize( QStringList& token, const QString& str,
 		const QString& delim );
@@ -237,6 +246,26 @@
     }
 }
 
+void KStandardDirs::addElektraConfigPrefix(const QString& _dir)
+{
+    addElektraConfigPrefix(_dir, false);
+}
+
+void KStandardDirs::addElektraConfigPrefix(const QString& _dir, bool priority)
+{
+    if (_dir.isEmpty())
+	return;
+
+    QString dir = _dir;
+    if (dir.at(dir.length() - 1) != '/')
+	dir += '/';
+
+    if (!d->elektraconf_prefixes.contains(dir)) {
+	priorityAdd(d->elektraconf_prefixes, dir, priority);
+	dircache.clear();
+    }
+}
+
 QString KStandardDirs::kfsstnd_prefixes()
 {
    return prefixes.join(QChar(KPATH_SEPARATOR));
@@ -539,6 +568,82 @@
   }
 }
 
+static void lookupKeyDirectory(const QString& path, const QString &relPart,
+			    const QRegExp &regexp,
+			    QStringList& list,
+			    QStringList& relList,
+			    bool recursive, bool unique)
+{
+  QString pattern = regexp.pattern();
+  KDBHandle handle;
+  KeySet *ks;
+  Key *cur;
+
+  if (recursive || pattern.contains('?') || pattern.contains('*'))
+  {
+    if (path.isEmpty()) //for sanity
+      return;
+    // We look for a set of files.
+    ks = ksNew();
+    kdbOpen(&handle);
+    if ( kdbGetChildKeys(handle, path.latin1(), ks, KDB_O_STATONLY | KDB_O_INACTIVE | KDB_O_DIR ) ) {
+	kdbClose(&handle);
+	ksDel(ks);
+	return;
+    }
+
+	
+    ksRewind(ks);
+    while( ( cur = ksNext(ks) ) != 0L ) {
+      QString fn(keyStealBaseName(cur));
+
+      if (!recursive && !regexp.exactMatch(fn))
+	continue; // No match
+
+      QString pathfn = path + fn;
+      if ( recursive ) {
+	if ( keyIsDir(cur) ) {
+	  lookupKeyDirectory(pathfn + '/', relPart + fn + '/', regexp, list, relList, recursive, unique);
+	}
+        if (!regexp.exactMatch(fn))
+	  continue; // No match
+      }
+      if ( keyIsString(cur) || keyIsBin(cur) )
+      {
+        if (!unique || !relList.contains(relPart + fn))
+        {
+	    list.append( pathfn );
+	    relList.append( relPart + fn );
+        }
+      }
+    }
+    ksDel(ks);
+    kdbClose(&handle);
+
+  } else {
+     // We look for a single file.
+     QString fn = pattern;
+     QString pathfn = path + fn;
+
+     cur = keyNew(pathfn.latin1(), KEY_SWITCH_END);
+     kdbOpen(&handle);
+     if ( kdbStatKey(handle, cur) ) {
+	// Key not found
+	kdbClose(&handle);
+	keyDel(cur);
+	return;
+     }
+
+     if ( keyIsDir(cur) || keyIsBin(cur) ) {
+       if (!unique || !relList.contains(relPart + fn))
+       {
+         list.append( pathfn );
+         relList.append( relPart + fn );
+       }
+     }
+  }
+}
+
 static void lookupPrefix(const QString& prefix, const QString& relpath,
                          const QString& relPart,
 			 const QRegExp &regexp,
@@ -615,6 +720,74 @@
     }
 }
 
+static void lookupKeyPrefix(const QString& prefix, const QString& relpath,
+                         const QString& relPart,
+			 const QRegExp &regexp,
+			 QStringList& list,
+			 QStringList& relList,
+			 bool recursive, bool unique)
+{
+
+    if (relpath.isEmpty()) {
+       lookupKeyDirectory(prefix, relPart, regexp, list,
+		       relList, recursive, unique);
+       return;
+    }
+    QString path;
+    QString rest;
+
+    if (relpath.length())
+    {
+       int slash = relpath.find('/');
+       if (slash < 0)
+	   rest = relpath.left(relpath.length() - 1);
+       else {
+	   path = relpath.left(slash);
+	   rest = relpath.mid(slash + 1);
+       }
+    }
+
+    if (prefix.isEmpty()) //for sanity
+      return;
+
+    if (path.contains('*') || path.contains('?')) {
+	KDBHandle handle;
+	KeySet	*ks;
+	Key *cur;
+
+	QRegExp pathExp(path, true, true);
+	
+	ks = ksNew();
+	kdbOpen(&handle);
+	if ( kdbGetChildKeys(handle, prefix.latin1(), ks, KDB_O_STATONLY | KDB_O_INACTIVE | KDB_O_DIR) ) {
+		kdbClose(&handle);
+		ksDel(ks);
+		return;
+	}
+	ksRewind(ks);
+	while( (cur = ksNext(ks) ) != 0L )
+	    {
+		QString fn(keyStealBaseName(cur));
+
+		if ( !pathExp.exactMatch(fn) )
+		    continue; // No match
+		QString rfn = relPart+fn;
+		fn = prefix + fn;
+		if ( keyIsDir(cur) )
+		    lookupKeyPrefix(fn + '/', rest, rfn + '/', regexp, list, relList, recursive, unique);
+	    }
+
+	kdbClose(&handle);
+	ksDel(ks);
+    } else {
+        // Don't stat, if the dir doesn't exist we will find out
+        // when we try to open it.
+        lookupKeyPrefix(prefix + path + '/', rest,
+                     relPart + path + '/', regexp, list,
+                     relList, recursive, unique);
+    }
+}
+
 QStringList
 KStandardDirs::findAllResources( const char *type,
 			         const QString& filter,
@@ -661,11 +834,21 @@
 
     QRegExp regExp(filterFile, true, true);
 
-    for (QStringList::ConstIterator it = candidates.begin();
+    if ( strcmp(type, "config-elektra") == 0 ) {
+	for (QStringList::ConstIterator it = candidates.begin();
+        	 it != candidates.end(); it++)
+    	{
+        	lookupKeyPrefix(*it, filterPath, "", regExp, list,
+                	     relList, recursive, unique);
+    	}
+	
+    } else {
+	for (QStringList::ConstIterator it = candidates.begin();
          it != candidates.end(); ++it)
-    {
-        lookupPrefix(*it, filterPath, "", regExp, list,
-                     relList, recursive, unique);
+	{
+        	lookupPrefix(*it, filterPath, "", regExp, list,
+                	     relList, recursive, unique);
+    	}
     }
 
     return list;
@@ -817,39 +1000,86 @@
                 prefixList = &(d->xdgdata_prefixes);
             else if (strncmp(type, "xdgconf-", 8) == 0)
                 prefixList = &(d->xdgconf_prefixes);
+            else if ( strcmp(type, "config-elektra") == 0 )
+                prefixList = &(d->elektraconf_prefixes);
             else
                 prefixList = &prefixes;
 
-            for (QStringList::ConstIterator pit = prefixList->begin();
-                 pit != prefixList->end();
-                 ++pit)
-            {
-                for (QStringList::ConstIterator it = dirs->begin();
-                     it != dirs->end(); ++it) {
-                    QString path = realPath(*pit + *it);
-                    testdir.setPath(path);
-                    if (local && restrictionActive)
-                       continue;
-                    if ((local || testdir.exists()) && !candidates->contains(path))
-                        candidates->append(path);
+            if ( strcmp(type, "config-elektra") == 0 ) {
+		KDBHandle handle;
+		Key *key;
+		int rc;
+		kdbOpen(&handle);
+
+		for (QStringList::ConstIterator pit = prefixList->begin();
+                	 pit != prefixList->end(); pit++) {
+                	for (QStringList::ConstIterator it = dirs->begin(); it != dirs->end(); ++it) {
+                    		QString path = (*pit) + (*it);
+
+                    		if (local && restrictionActive)
+                    	   		continue;
+
+				key = keyNew(path.latin1(), KEY_SWITCH_END);
+				rc = kdbStatKey(handle, key);
+				if ((local || rc == 0) && !candidates->contains(path))
+                        		candidates->append(path);
+				keyDel(key);
+                	}
+                	local = false;
+		}
+
+		kdbClose(&handle);
+ 	    } else {
+                for (QStringList::ConstIterator pit = prefixList->begin();
+                     pit != prefixList->end();
+                     ++pit)
+                {
+                    for (QStringList::ConstIterator it = dirs->begin();
+                         it != dirs->end(); ++it) {
+                        QString path = realPath(*pit + *it);
+                        testdir.setPath(path);
+                        if (local && restrictionActive)
+                           continue;
+                        if ((local || testdir.exists()) && !candidates->contains(path))
+                            candidates->append(path);
+                    }
+                    local = false;
                 }
-                local = false;
             }
         }
         dirs = absolutes.find(type);
         if (dirs)
-            for (QStringList::ConstIterator it = dirs->begin();
-                 it != dirs->end(); ++it)
-            {
-                testdir.setPath(*it);
-                if (testdir.exists())
+            if ( strcmp(type, "config-elektra") == 0 ) {
+		KDBHandle handle;
+		Key *key;
+		kdbOpen(&handle);		
+
+		for (QStringList::ConstIterator it = dirs->begin();
+                	 it != dirs->end(); ++it)
+            	{
+			key = keyNew((*it).latin1(), KEY_SWITCH_END);
+			if ( kdbStatKey(handle, key) == 0 ) {
+                    		if (!candidates->contains(*it))
+                        		candidates->append(*it);
+                	}
+			keyDel(key);
+	        }
+
+		kdbClose(&handle);
+	    } else {
+                for (QStringList::ConstIterator it = dirs->begin();
+                     it != dirs->end(); ++it)
                 {
-                    QString filename = realPath(*it);
-                    if (!candidates->contains(filename))
-                        candidates->append(filename);
+                    testdir.setPath(*it);
+                    if (testdir.exists())
+                    {
+                        QString filename = realPath(*it);
+                        if (!candidates->contains(filename))
+                            candidates->append(filename);
+                    }
                 }
             }
-        dircache.insert(type, candidates);
+            dircache.insert(type, candidates);
     }
 
 #if 0
@@ -1025,6 +1255,8 @@
 	return "share/icons/";
     if (!strcmp(type, "config"))
 	return "share/config/";
+    if (!strcmp(type, "config-elektra"))
+	return "kde/";
     if (!strcmp(type, "pixmap"))
 	return "share/pixmaps/";
     if (!strcmp(type, "apps"))
@@ -1094,6 +1326,8 @@
              pPath = new QString(realPath(localxdgdatadir() + dirs->last()));
           else if (strncmp(type, "xdgconf-", 8) == 0)
              pPath = new QString(realPath(localxdgconfdir() + dirs->last()));
+          else if (strcmp(type, "config-elektra") == 0)
+	     return QString(localelektraconfdir() + dirs->last());
           else
              pPath = new QString(realPath(localkdedir() + dirs->last()));
        }
@@ -1411,6 +1645,32 @@
     }
     // end XDG_DATA_XXX
 
+    // begin ELEKTRA_CONFIG
+    QStringList elektrakeyList;
+    QString elektrakeys = readEnvPath("ELEKTRA_CONFIG_DIRS");
+    if (!elektrakeys.isEmpty()) {
+	tokenize(elektrakeyList, elektrakeys, QChar(KPATH_SEPARATOR));
+    } else {
+	elektrakeyList.clear();
+	elektrakeyList.append("system/sw/");
+    }
+	
+    QString localElektraDir = readEnvPath("ELEKTRA_CONFIG_HOME");
+    if (!localElektraDir.isEmpty()) {
+	// TODO: add escaping support !
+	if (localElektraDir[localElektraDir.length()-1] != '/') {
+		localElektraDir += '/';
+	}
+    } else {
+	localElektraDir = "user/sw/";
+    }
+	
+    addElektraConfigPrefix(localElektraDir);
+    for (QStringList::ConstIterator it = elektrakeyList.begin(); it != elektrakeyList.end(); it++) {
+	QString dir = *it;
+	addElektraConfigPrefix(dir);	
+    }
+    // end ELEKTRA_CONFIG
 
     uint index = 0;
     while (types[index] != 0) {
@@ -1504,6 +1764,7 @@
     // save the numbers of config directories. If this changes,
     // we will return true to give KConfig a chance to reparse
     uint configdirs = resourceDirs("config").count();
+    uint elektrakeys = resourceDirs("config-elektra").count();
 
     // Remember original group
     QString oldGroup = config->group();
@@ -1573,6 +1834,20 @@
                 addXdgDataPrefix(dir+"/share", priority);
             }
 
+            // Check elektra specific prefixes
+            QStringList keyList =  config->readListEntry("key_prefixes");
+	    for (QStringList::ConstIterator kit = keyList.begin(); kit != keyList.end(); kit++) {
+                addElektraConfigPrefix(*kit+"/kde", priority);
+            }
+
+            // Get entry for additional elektra key directories
+            QString addKeyRoots = config->readEntry("key_config-elektra");
+            QStringList keys = QStringList::split(',', addKeyRoots);
+            QStringList::Iterator kIt(keys.begin());
+            for (; kIt != keys.end(); ++kIt) {
+		addResourceDir("config-elektra", *kIt, priority);
+            }
+
             // iterating over all entries in the group Directories
             // to find entries that start with dir_$type
             QMap<QString, QString> entries = config->entryMap(group);
@@ -1621,7 +1896,7 @@
     config->setGroup(oldGroup);
 
     // check if the number of config dirs changed
-    bool configDirsChanged = (resourceDirs("config").count() != configdirs);
+    bool configDirsChanged = ( (resourceDirs("config").count() != configdirs) || (resourceDirs("config-elektra").count() != elektrakeys) );
     // If the config dirs changed, we check kiosk restrictions again.
     d->checkRestrictions = configDirsChanged;
     // return true if the number of config dirs changed: reparse config file
@@ -1646,6 +1921,11 @@
     return d->xdgconf_prefixes.first();
 }
 
+QString KStandardDirs::localelektraconfdir() const
+{
+    // Return the prefix to use for saving
+    return d->elektraconf_prefixes.first();
+}
 
 // just to make code more readable without macros
 QString locate( const char *type,
diff -Naur kdelibs-3.5.2.orig/kdecore/kstandarddirs.h kdelibs-3.5.2/kdecore/kstandarddirs.h
--- kdelibs-3.5.2.orig/kdecore/kstandarddirs.h	2005-10-10 17:06:03.000000000 +0200
+++ kdelibs-3.5.2/kdecore/kstandarddirs.h	2006-05-08 19:17:00.000000000 +0200
@@ -165,6 +165,15 @@
 	void addXdgDataPrefix( const QString& dir );
 
 	/**
+	 * Adds another search keys root to front of the ELEKTRA_CONFIG_XXX list
+	 * of prefixes.
+	 * This prefix is only used for "config-elektra" resource.
+	 *
+	 * @param dir The key root directory to append relative paths to
+	 */
+	void addElektraConfigPrefix( const QString& dir );
+
+	/**
 	 * Adds suffixes for types.
 	 *
 	 * You may add as many as you need, but it is advised that there
@@ -577,6 +586,12 @@
 	QString localxdgconfdir() const;
 
 	/**
+	 * @return $ELEKTRA_CONFIG_HOME
+	 * See also http://www.freedesktop.org/standards/basedir/draft/basedir-spec/basedir-spec.html
+	 */
+	QString localelektraconfdir() const;
+
+	/**
 	 * Checks for existence and accessability of a file or directory.
 	 * Faster than creating a QFileInfo first.
 	 * @param fullPath the path to check. IMPORTANT: must end with a slash if expected to be a directory
@@ -635,6 +650,7 @@
 	void addPrefix( const QString& dir, bool priority );
 	void addXdgConfigPrefix( const QString& dir, bool priority );
 	void addXdgDataPrefix( const QString& dir, bool priority );
+	void addElektraConfigPrefix( const QString& dir, bool priority );
 
 	// If priority is true, the directory is added before any other,
 	// otherwise after
diff -Naur kdelibs-3.5.2.orig/kdecore/Makefile.am kdelibs-3.5.2/kdecore/Makefile.am
--- kdelibs-3.5.2.orig/kdecore/Makefile.am	2005-10-10 17:06:02.000000000 +0200
+++ kdelibs-3.5.2/kdecore/Makefile.am	2006-05-08 19:37:21.000000000 +0200
@@ -37,6 +37,8 @@
 lib_LIBRARIES = libkdefakes_nonpic.a
 
 include_HEADERS = kconfig.h kconfigskeleton.h \
+	kconfigparser.h kconfigparserfactory.h \
+	kconfiginiparser.h kconfigelektraparser.h \
 	kconfigdata.h ksimpleconfig.h kconfigdialogmanager.h \
 	kconfigbase.h kdesktopfile.h kurl.h ksock.h kaboutdata.h \
 	kcmdlineargs.h kconfigbackend.h kapp.h kapplication.h kuniqueapp.h \
@@ -85,6 +87,8 @@
 
 libkdecore_la_SOURCES = libintl.cpp kapplication.cpp \
 	kdebug.cpp netwm.cpp kconfigbase.cpp kconfig.cpp  ksimpleconfig.cpp \
+	kconfigparser.cpp kconfigparserfactory.cpp \
+	kconfiginiparser.cpp kconfigelektraparser.cpp \
 	kconfigbackend.cpp kmanagerselection.cpp kdesktopfile.cpp \
 	kstandarddirs.cpp ksock.cpp kpty.cpp kprocess.cpp kprocctrl.cpp \
 	klocale.cpp krfcdate.cpp kiconeffect.cpp kicontheme.cpp \
@@ -116,7 +120,7 @@
 	kqiodevicegzip_p.cpp ktimezones.cpp
 
 libkdecore_la_LDFLAGS = $(QT_LDFLAGS) $(KDE_RPATH) $(KDE_MT_LDFLAGS) $(X_LDFLAGS) $(USER_LDFLAGS) -version-info 6:0:2 -no-undefined
-libkdecore_la_LIBADD = malloc/libklmalloc.la network/libkdecorenetwork.la $(SVGICON_LIB) ../dcop/libDCOP.la ../libltdl/libltdlc.la $(LIB_XEXT) $(LIBRESOLV) $(LIBUTIL) $(LIBART_LIBS) $(LIB_IDN) ../kdefx/libkdefx.la
+libkdecore_la_LIBADD = malloc/libklmalloc.la network/libkdecorenetwork.la $(SVGICON_LIB) ../dcop/libDCOP.la ../libltdl/libltdlc.la $(LIB_XEXT) $(LIBRESOLV) $(LIBUTIL) $(LIBART_LIBS) $(LIB_IDN) ../kdefx/libkdefx.la -lelektra
 libkdecore_la_NMCHECK = $(srcdir)/libkdecore.nmcheck
 libkdecore_la_NMCHECKWEAK = $(srcdir)/libkdecore_weak.nmcheck $(srcdir)/libqt-mt_weak.nmcheck \
 	$(top_srcdir)/dcop/libDCOP_weak.nmcheck $(top_srcdir)/kdecore/standard_weak.nmcheck
