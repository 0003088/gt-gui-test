diff -Naur kdelibs-3.5.2.orig/kdecore/elektra.h kdelibs-3.5.2/kdecore/elektra.h
--- kdelibs-3.5.2.orig/kdecore/elektra.h	1970-01-01 01:00:00.000000000 +0100
+++ kdelibs-3.5.2/kdecore/elektra.h	2006-05-21 12:52:27.000000000 +0200
@@ -0,0 +1,8 @@
+#ifndef _ELEKTRA_DEFAULT_
+
+// Define elektra defaults prefix
+
+#define ELEKTRA_ROOT_PATH "system/sw"
+#define ELEKTRA_USER_PATH "user/sw"
+
+#endif
diff -Naur kdelibs-3.5.2.orig/kdecore/kconfigbackend_wrapper.cpp kdelibs-3.5.2/kdecore/kconfigbackend_wrapper.cpp
--- kdelibs-3.5.2.orig/kdecore/kconfigbackend_wrapper.cpp	1970-01-01 01:00:00.000000000 +0100
+++ kdelibs-3.5.2/kdecore/kconfigbackend_wrapper.cpp	2006-05-21 12:49:30.000000000 +0200
@@ -0,0 +1,185 @@
+/*
+  This file is part of the KDE libraries
+  Copyright (c) 1999 Preston Brown <pbrown@kde.org>
+  Copyright (c) 1997-1999 Matthias Kalle Dalheimer <kalle@kde.org>
+
+  This library is free software; you can redistribute it and/or
+  modify it under the terms of the GNU Library General Public
+  License as published by the Free Software Foundation; either
+  version 2 of the License, or (at your option) any later version.
+
+  This library is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+  Library General Public License for more details.
+
+  You should have received a copy of the GNU Library General Public License
+  along with this library; see the file COPYING.LIB.  If not, write to
+  the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+  Boston, MA 02111-1307, USA.
+
+  Elektra patch by Yannick Lecaillez <sizon5@gmail.com>
+*/
+
+#include "kdbconfig.h"
+
+#include <unistd.h>
+#include <ctype.h>
+#ifdef HAVE_SYS_MMAN_H
+#include <sys/mman.h>
+#endif
+#include <sys/types.h>
+#ifdef HAVE_SYS_STAT_H
+#include <sys/stat.h>
+#endif
+#include <fcntl.h>
+#include <signal.h>
+#include <setjmp.h>
+
+#include <qdir.h>
+#include <qfileinfo.h>
+#include <qtextcodec.h>
+#include <qtextstream.h>
+
+#include "kconfigbackend_wrapper.h"
+#include "kconfigparser.h"
+#include "kconfigparserfactory.h"
+#include "kconfigbase.h"
+#include <kapplication.h>
+#include <kglobal.h>
+#include <kprocess.h>
+#include <klocale.h>
+#include <kstandarddirs.h>
+#include <ksavefile.h>
+#include <kurl.h>
+#include <kde_file.h>
+
+#include <kdb.h>
+
+class KConfigParser;
+
+KConfigBackEnd::KConfigBackEnd(KConfigBase *_config,
+			       const QString &_fileName,
+			       const char * _resType,
+			       bool _useKDEGlobals)
+  : pConfig(_config), mFileMode(-1)
+{
+   mParser = NULL;
+   changeFileName(_fileName, _resType, _useKDEGlobals);
+}
+
+void KConfigBackEnd::changeFileName(const QString &_fileName,
+                                    const char * _resType,
+                                    bool _useKDEGlobals)
+{
+	if ( mParser ) {
+		delete mParser;
+		mParser = NULL;
+	}
+
+	mParser = KConfigParserFactory::create(pConfig, _fileName, _resType, _useKDEGlobals);
+	mParser->setFileImmutable(false);
+	mParser->setConfigState(KConfigBase::NoAccess);
+}
+
+KConfigBase::ConfigState KConfigBackEnd::getConfigState()
+{
+	if ( mParser )
+		return mParser->getConfigState();
+
+	return KConfigBase::NoAccess;
+}
+
+void KConfigBackEnd::setConfigState(KConfigBase::ConfigState state)
+{
+	if ( mParser )
+		return mParser->setConfigState(state);
+}
+
+QString KConfigBackEnd::fileName()
+{
+	if ( mParser )
+		return mParser->fileName();
+
+	return "";
+}
+
+KLockFile::Ptr KConfigBackEnd::lockFile(bool bGlobal)
+{
+	if ( mParser )
+		return mParser->lockFile(bGlobal);
+
+	return 0;
+}
+
+void KConfigBackEnd::setLocaleString(const QCString &_localeString)
+{
+	if ( mParser )
+		mParser->setLocaleString(_localeString);
+}
+
+
+
+bool KConfigBackEnd::parseConfigFiles()
+{
+	if ( mParser )
+		return mParser->parseConfigFiles();
+
+	return false;
+}
+
+void KConfigBackEnd::sync(bool bMerge)
+{
+	if ( mParser )
+		mParser->sync(bMerge);
+}
+
+void KConfigBackEnd::setFileWriteMode(int mode)
+{
+  mFileMode = mode;
+}
+
+void KConfigBackEnd::virtual_hook( int, void* )
+{ /*BASE::virtual_hook( id, data );*/ }
+
+bool KConfigBackEnd::checkConfigFilesWritable(bool warnUser)
+{
+
+	if ( mParser )
+		return mParser->checkConfigFilesWritable(warnUser);
+
+	return false;
+}
+
+const char* KConfigBackEnd::resource()
+{
+	if ( mParser )
+		return mParser->resource();
+
+	return NULL;
+}
+
+bool KConfigBackEnd::isFileImmutable()
+{
+	if ( mParser )
+		return mParser->isFileImmutable();
+
+	return false;
+}
+
+bool KConfigBackEnd::isUseKDEGlobals()
+{
+	if ( mParser )
+		return mParser->isUseKDEGlobals();
+
+	return false;
+}
+
+KConfigBackEnd::~KConfigBackEnd()
+{
+   if ( mParser ) {
+	delete mParser;
+	mParser = NULL;
+   }
+}
+
diff -Naur kdelibs-3.5.2.orig/kdecore/kconfigbackend_wrapper.h kdelibs-3.5.2/kdecore/kconfigbackend_wrapper.h
--- kdelibs-3.5.2.orig/kdecore/kconfigbackend_wrapper.h	1970-01-01 01:00:00.000000000 +0100
+++ kdelibs-3.5.2/kdecore/kconfigbackend_wrapper.h	2006-05-21 12:43:20.000000000 +0200
@@ -0,0 +1,176 @@
+/*
+   This file is part of the KDE libraries
+   Copyright (c) 1999 Preston Brown <pbrown@kde.org>
+   Portions copyright (c) 1997 Matthias Kalle Dalheimer <kalle@kde.org>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public License
+   along with this library; see the file COPYING.LIB.  If not, write to
+   the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+
+   Elektra patch by Yannick Lecaillez <sizon5@gmail.com>
+*/
+
+#ifndef _KCONFIGBACKEND_H
+#define _KCONFIGBACKEND_H
+
+#include "kconfig.h"
+#include "kconfigdata.h"
+#include <kconfigbase.h>
+#include <klockfile.h>
+#include "kconfigparser.h"
+#include "kdelibs_export.h"
+
+// class QFile;
+// class KConfigBackEndPrivate;
+
+/**
+ * "New" KConfigBackEnd class.
+ * This class is no more an abstract but a wrapper. Its call
+ * KConfigParserFactory for get the KConfigParser object responsible
+ * of configuration loading/saving for a specific couple of filename
+ * and resource type.
+ * The only "usefull" method is changeFileName(), other are wrapper
+ * to the associated KConfigParser.
+ *
+ * @author Yannick Lecaillez <sizon5@gmail.com>
+ *
+ * @short KDE Configuration file loading/saving abstract base class
+ */
+class KDECORE_EXPORT KConfigBackEnd
+{
+  friend class KConfig;
+  friend class KSharedConfig;
+  friend class KConfigParser;
+public:
+  /**
+   * Constructs a configuration back end.
+   *
+   * @param _config Specifies the configuration object which values
+   *        will be passed to as they are read, or from where values
+   *        to be written to will be obtained from.
+   * @param _fileName The name of the file in which config
+   *        data is stored.  All registered configuration directories
+   *        will be looked in in order of decreasing relevance.
+   * @param _resType the resource type of the fileName specified, _if_
+   *        it is not an absolute path (otherwise this parameter is ignored).
+   * @param _useKDEGlobals If true, the user's system-wide kdeglobals file
+   *        will be imported into the config object.  If false, only
+   *        the filename specified will be dealt with.
+   */
+  KConfigBackEnd(KConfigBase *_config, const QString &_fileName,
+		 const char * _resType, bool _useKDEGlobals);
+
+  /**
+   * Destructs the configuration backend.
+   */
+  virtual ~KConfigBackEnd();
+
+  /**
+   * Parses all configuration files for a configuration object.  This
+   * method must be reimplemented by the derived classes.
+   *
+   * @returns Whether or not parsing was successful.
+   */
+  bool parseConfigFiles();
+
+  /**
+   * Writes configuration data to file(s).  This method must be
+   * reimplemented by the derived classes.
+   *
+   * @param bMerge Specifies whether the old config file already
+   *        on disk should be merged in with the data in memory.  If true,
+   *        data is read off the disk and merged.  If false, the on-disk
+   *        file is removed and only in-memory data is written out.
+   */
+  void sync(bool bMerge = true);
+
+  /**
+   * Changes the filenames associated with this back end.  You should
+   * probably reparse your config info after doing this.
+   *
+   * @param _fileName the new filename to use
+   * @param _resType the resource type of the fileName specified, _if_
+   *        it is not an absolute path (otherwise this parameter is ignored).
+   * @param _useKDEGlobals specifies whether or not to also parse the
+   *        global KDE configuration files.
+   */
+  void changeFileName(const QString &_fileName, const char * _resType,
+		      bool _useKDEGlobals);
+  QString fileName();
+
+  /**
+   * Returns the state of the app-config object.
+   *
+   * @see KConfig::getConfigState
+   */
+   KConfigBase::ConfigState getConfigState();
+   void setConfigState(KConfigBase::ConfigState state);
+
+  /**
+   * Returns the resource type as passed to the constructor.
+   * @return the resource type as passed to the constructor.
+   */
+  const char * resource();
+
+  /**
+   * Set the locale string that defines the current language.
+   * @param _localeString the identifier of the language
+   * @see KLocale
+   */
+  void setLocaleString(const QCString &_localeString);
+
+  /**
+   * Set the file mode for newly created files.
+   * @param mode the filemode (as in chmod)
+   */
+  void setFileWriteMode(int mode);
+
+  bool isFileImmutable();
+  bool isUseKDEGlobals();
+
+  /**
+   * Check whether the config files are writable.
+   * @param warnUser Warn the user if the configuration files are not writable.
+   * @return Indicates that all of the configuration files used are writable.
+   * @since 3.2
+   */
+  bool checkConfigFilesWritable(bool warnUser);
+
+  /**
+   * Returns a lock file object for the configuration file
+   * @param bGlobal If true, returns a lock file object for kdeglobals
+   * @since 3.3
+   */
+  KLockFile::Ptr lockFile( bool bGlobal = false );
+
+#ifdef KDE_NO_COMPAT
+// private:
+#endif
+  /**
+   * @deprecated Use @see fileName() instead
+   */
+  // KDE_DEPRECATED QString filename() const { return mfileName; }
+
+protected:
+  KConfigBase *pConfig;
+  KConfigParser *mParser;
+  int mFileMode;
+
+protected:
+  virtual void virtual_hook( int id, void* data );
+
+};
+
+
+#endif
diff -Naur kdelibs-3.5.2.orig/kdecore/kconfigbase.cpp kdelibs-3.5.2/kdecore/kconfigbase.cpp
--- kdelibs-3.5.2.orig/kdecore/kconfigbase.cpp	2005-11-08 23:39:22.000000000 +0100
+++ kdelibs-3.5.2/kdecore/kconfigbase.cpp	2006-05-21 13:00:23.000000000 +0200
@@ -33,7 +33,7 @@
 #include <kcharsets.h>
 
 #include "kconfigbase.h"
-#include "kconfigbackend.h"
+#include "kconfigbackend_wrapper.h"
 #include "kdebug.h"
 #include "kstandarddirs.h"
 #include "kstringhandler.h"
diff -Naur kdelibs-3.5.2.orig/kdecore/kconfigbase.h kdelibs-3.5.2/kdecore/kconfigbase.h
--- kdelibs-3.5.2.orig/kdecore/kconfigbase.h	2006-03-17 11:19:05.000000000 +0100
+++ kdelibs-3.5.2/kdecore/kconfigbase.h	2006-05-21 13:07:40.000000000 +0200
@@ -72,7 +72,8 @@
   Q_OBJECT
 
   friend class KConfigBackEnd;
-  friend class KConfigINIBackEnd;
+  friend class KConfigElektraParser;
+  friend class KConfigINIParser;
   friend class KConfigGroup;
 
 public:
diff -Naur kdelibs-3.5.2.orig/kdecore/kconfig.cpp kdelibs-3.5.2/kdecore/kconfig.cpp
--- kdelibs-3.5.2.orig/kdecore/kconfig.cpp	2005-10-10 17:06:02.000000000 +0200
+++ kdelibs-3.5.2/kdecore/kconfig.cpp	2006-05-21 12:52:40.000000000 +0200
@@ -17,6 +17,8 @@
   along with this library; see the file COPYING.LIB.  If not, write to
   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.
+
+  Elektra patch by Yannick Lecaillez <sizon5@gmail.com>
 */
 
 // $Id$
@@ -33,7 +35,7 @@
 #include <qfileinfo.h>
 
 #include <kapplication.h>
-#include "kconfigbackend.h"
+#include "kconfigbackend_wrapper.h"
 
 #include "kconfig.h"
 #include "kglobal.h"
@@ -49,16 +51,12 @@
   // set the object's read-only status.
   setReadOnly(bReadOnly);
 
-  // for right now we will hardcode that we are using the INI
-  // back end driver.  In the future this should be converted over to
-  // a object factory of some sorts.
-  KConfigINIBackEnd *aBackEnd = new KConfigINIBackEnd(this,
-						      fileName,
-                                                      resType,
-						      bUseKderc);
-
-  // set the object's back end pointer to this new backend
-  backEnd = aBackEnd;
+  // elektra patch:
+  // KConfigBackEnd act now as a wrapper for configuration
+  // parser (KConfigParser). This allow to change parser dynamicly
+  // in function of the filename/resource.
+  // see KConfigBackend changeFileName for more details.
+  backEnd = new KConfigBackEnd(this, fileName, resType, bUseKderc);
 
   // read initial information off disk
   reparseConfiguration();
@@ -279,9 +277,8 @@
 
 KLockFile::Ptr KConfig::lockFile(bool bGlobal)
 {
-  KConfigINIBackEnd *aBackEnd = dynamic_cast<KConfigINIBackEnd*>(backEnd);
-  if (!aBackEnd) return 0;
-  return aBackEnd->lockFile(bGlobal);
+  if (backEnd) return 0;
+  return backEnd->lockFile(bGlobal);
 }
 
 void KConfig::checkUpdate(const QString &id, const QString &updateFile)
@@ -307,7 +304,7 @@
   config->backEnd->changeFileName(file, "config", false);
   config->setReadOnly(false);
   config->bFileImmutable = false;
-  config->backEnd->mConfigState = ReadWrite;
+  config->backEnd->setConfigState(ReadWrite);
 
   QStringList groups = groupList();
   for(QStringList::ConstIterator it = groups.begin();
@@ -339,8 +336,8 @@
          it != s_list->end(); ++it)
      {
         if ((*it)->backEnd->fileName() == fileName &&
-                (*it)->backEnd->bFileImmutable == immutable &&
-                (*it)->backEnd->useKDEGlobals == useKDEGlobals )
+                (*it)->backEnd->isFileImmutable() == immutable &&
+                (*it)->backEnd->isUseKDEGlobals() == useKDEGlobals )
            return (*it);
      }
   }
diff -Naur kdelibs-3.5.2.orig/kdecore/kconfigelektraparser.cpp kdelibs-3.5.2/kdecore/kconfigelektraparser.cpp
--- kdelibs-3.5.2.orig/kdecore/kconfigelektraparser.cpp	1970-01-01 01:00:00.000000000 +0100
+++ kdelibs-3.5.2/kdecore/kconfigelektraparser.cpp	2006-05-21 15:34:55.000000000 +0200
@@ -0,0 +1,772 @@
+/*
+	KConfigElektraParser
+	Yannick Lecaillez - <sizon5@gmail.com>
+
+	KConfig configuration parser using elektra as backend.
+*/
+
+#include "kdbconfig.h"
+
+#include <stdlib.h>
+#include <unistd.h>
+#include <ctype.h>
+#ifdef HAVE_SYS_MMAN_H
+#include <sys/mman.h>
+#endif
+#include <sys/types.h>
+#ifdef HAVE_SYS_STAT_H
+#include <sys/stat.h>
+#endif
+#include <fcntl.h>
+#include <signal.h>
+#include <setjmp.h>
+
+#include <qdir.h>
+#include <qfileinfo.h>
+#include <qtextcodec.h>
+#include <qtextstream.h>
+
+#include "kconfigparser.h"
+#include "kconfigelektraparser.h"
+#include "kconfigbase.h"
+#include <kapplication.h>
+#include <kglobal.h>
+#include <kprocess.h>
+#include <klocale.h>
+#include <kstandarddirs.h>
+#include <ksavefile.h>
+#include <kurl.h>
+#include <kde_file.h>
+
+#include <kdb.h>
+
+bool checkKeyAccess(const QString &keyName, int mode);
+
+KConfigElektraParser::KConfigElektraParser(KConfigBase *_config, const QString &_fileName, const char *_resType, bool _useKDEGlobals) 
+	: KConfigParser(_config, _fileName, _resType, _useKDEGlobals)
+{
+	if (_fileName.isEmpty())
+		mLocalKeyRoot = QString::null;
+	else if ( isAbsoluteKeyName(_fileName) )
+		mLocalKeyRoot = _fileName;
+	else {
+		mLocalKeyRoot = KGlobal::dirs()->saveLocation(_resType) + mfileName;
+	}
+
+	if (useKDEGlobals)
+		mGlobalKeyRoot = KGlobal::dirs()->saveLocation(_resType) + QString::fromLatin1("kdeglobals");
+	else
+		mGlobalKeyRoot = QString::null;
+}
+
+bool KConfigElektraParser::isAbsoluteKeyName(const QString &keyName)
+{
+	return ( keyName.startsWith("user/") ||
+			keyName.startsWith("user:") ||
+			keyName.startsWith("system/") );
+}
+
+bool KConfigElektraParser::parseConfigFiles()
+{
+	// Check if we can write to the local file.
+	mConfigState = KConfigBase::ReadOnly;
+	if (!mfileName.isEmpty() && !pConfig->isReadOnly()) {
+		if (checkKeyAccess(mLocalKeyRoot, W_OK)) {
+			mConfigState = KConfigBase::ReadWrite;
+		/*} else {
+			// Create the containing dir, maybe it wasn't there
+			KURL path;
+			path.setPath(mLocalFileName);
+			QString dir=path.directory();
+			KStandardDirs::makeDir(dir);
+
+			if (checkAccess(mLocalFileName, W_OK)) {
+				mConfigState = KConfigBase::ReadWrite;
+			} */
+		}
+	}
+
+	bFileImmutable = false;
+
+	// Parse the general config files
+	if (useKDEGlobals) {
+		QStringList kdercs = KGlobal::dirs()-> findAllResources(resType, QString::fromLatin1("kdeglobals"));		
+		QString etc_kderc = QString::fromLatin1("system/sw/kde/kderc");
+		
+		if (checkKeyAccess(etc_kderc, R_OK))
+			kdercs += etc_kderc;
+
+		kdercs += KGlobal::dirs()-> findAllResources(resType, QString::fromLatin1("system.kdeglobals"));
+
+		QStringList::ConstIterator it;
+		for (it = kdercs.fromLast(); it != kdercs.end(); --it) {
+			QString keyName(*it);
+			parseKeysFrom(keyName, 0L, true, (keyName != mGlobalKeyRoot));
+			if (bFileImmutable)
+				break;
+		}
+	}
+	
+	// Parse specific configuration file
+	bool bReadFile = !mfileName.isEmpty();
+	while(bReadFile) {
+		QString keyName;		
+		QString bootLanguage;
+
+		bReadFile = false;
+
+		if (useKDEGlobals && localeString.isEmpty() && !KGlobal::_locale) {
+			// Boot strap language
+			bootLanguage = KLocale::_initLanguage(pConfig);
+			setLocaleString(bootLanguage.utf8());
+		}
+			
+		bFileImmutable = false;
+		QStringList list;
+		if ( isAbsoluteKeyName(mfileName) )
+			list << mfileName;
+		else
+			list = KGlobal::dirs()->findAllResources(resType, mfileName);
+
+
+		QStringList::ConstIterator it;
+		for (it = list.fromLast(); it != list.end(); --it) {
+			QString keyName(*it);
+			
+			// we can already be sure that this file exists
+			bool bIsLocal = (keyName == mLocalKeyRoot);
+			parseKeysFrom(keyName, 0L, false, !bIsLocal );
+			if (bFileImmutable)
+				break;
+		}
+		if (KGlobal::dirs()->isRestrictedResource(resType, mfileName))
+			bFileImmutable = true;
+		
+		QString currentLanguage;
+		if (!bootLanguage.isEmpty()) {
+			currentLanguage = KLocale::_initLanguage(pConfig);
+			// If the file changed the language, we need to read the file again
+			// with the new language setting.
+			if (bootLanguage != currentLanguage) {
+				bReadFile = true;
+				setLocaleString(currentLanguage.utf8());
+			}
+		}
+	}
+
+	if (bFileImmutable)
+		mConfigState = KConfigBase::ReadOnly;
+		
+	return true;
+
+
+	return true;
+}
+
+extern bool kde_kiosk_exception;
+	
+void KConfigElektraParser::parseKeysFrom(QString keyName, KEntryMap *pWriteBackMap, bool bGlobal, bool bDefault)
+{
+	KDB	kdbHandle;
+	KeySet		*groups;
+	Key		*key;
+	bool		mainImmutable = false;
+	
+	if ( keyName.endsWith("[$i]") || keyName.endsWith("[$i]/") )
+		mainImmutable = true;
+		
+	kdbOpen(&kdbHandle);
+	groups = ksNew();
+	if ( kdbGetChildKeys(kdbHandle, keyName.latin1(), groups, KDB_O_RECURSIVE | KDB_O_INACTIVE ) <= 0 ) {
+		ksDel(groups);
+		kdbClose(&kdbHandle);
+		return;
+ 	}
+	
+	ksRewind(groups);
+	while ( (key = ksNext(groups)) )  {
+		QString groupName;
+		bool groupSkip;
+		bool groupImmutable = mainImmutable;
+		QString tmp(keyStealName(key));
+		char *parentName;
+		ssize_t nameSize;
+
+		//
+		// Manage group
+		// 
+
+		if ( (nameSize = keyGetParentNameSize(key)) <= 0 )
+			continue;
+		
+		parentName = (char *) malloc(nameSize);
+		keyGetParentName(key, parentName, nameSize);
+		groupName = parentName;
+		free(parentName);
+			
+		groupName.remove(0, keyName.length()+1);		// Remove keyRoot
+		if (groupName.length() == 0 ) {
+			groupName = "<default>";
+
+		} else {
+			groupName.replace(QString("\\/"), QString("/"));	// Unescape
+					
+			if ( groupName.endsWith("[$i]") && !kde_kiosk_exception ) {
+				groupName.truncate(groupName.length() - 4);	// Remove [$i] from group name
+				groupImmutable = true;
+			}
+			
+			if (groupName == "KDE Desktop Entry")
+				groupName = "Desktop Entry";
+		}
+	
+		// Look if this group was previously defined
+		// by a previous search path
+		KEntryKey groupKey(groupName.latin1(), 0);
+		KEntry entry = pConfig->lookupData(groupKey);
+		groupSkip = entry.bImmutable;
+		if ( groupSkip && !bDefault ) {
+			// Ignore this group, a previously defined
+			// as immutable exist yet
+			continue;
+		}
+			
+		// Add this group
+		entry.bImmutable |= groupImmutable;
+		pConfig->putData(groupKey, entry, false);
+	
+		if (pWriteBackMap) {
+			// add the special group key indicator
+			(*pWriteBackMap)[groupKey] = entry;
+		}
+	
+		//
+		// Manage key for this group
+		//
+		int optStartPos, optEndPos;
+		bool keyImmutable = false;
+		bool keyExpand = false, keyDeleted = false;
+		QString locale("");
+		QString keyName(keyStealBaseName(key));
+		keyName.replace(QString("\\/"), QString("/"));	// Unescape
+	
+		// Parse key options
+		optStartPos = keyName.find(QChar('['), 0);
+		optEndPos = keyName.find(QChar(']'), 0);
+			
+		if ( optStartPos != -1 && optEndPos != -1 ) {
+			if ( keyName.at(optStartPos+1) == QChar('$') ) {
+				// Options
+				int optPos = optStartPos + 2;  // Skip [ and $
+					
+				QChar opt = keyName.at(optPos++);
+				while ( optPos != optEndPos ) {
+					switch ((char) opt) {
+						case 'i':
+							keyImmutable = true;
+							break;
+						case 'e':
+							keyExpand = true;
+							break;
+						case 'd':
+							keyDeleted = true;
+							break;
+						default:
+							fprintf(stderr, "Unknown option '%c'\n", (char) opt);
+					}
+					opt = keyName.at(optPos++);
+				}
+						
+			} else {
+				// Localized Key
+				if ( !locale.isEmpty() )
+					fprintf(stderr, "Invalid entry (second locale!?) at %s\n", keyStealBaseName(key));
+				locale = keyName.mid(optStartPos+1, (optEndPos - (optStartPos+1)));
+			}
+			keyName.truncate(keyName.length() - (optEndPos - (optStartPos)));
+		} else if ( optStartPos != -1 ) {
+			// ] is missing
+			fprintf(stderr, "Invalid entry (missing ']') at %s\n", keyStealBaseName(key));
+			continue;
+
+		} else if ( optEndPos != -1 ) {
+			// [ is missing
+			fprintf(stderr, "Invalid entry (missing '[') at %s\n", keyStealBaseName(key));
+			continue;
+		}
+		// End key option parsing
+
+		// insert the key/value		
+		KEntryKey aEntryKey(groupName.latin1(), keyName.latin1());
+		aEntryKey.bLocal = !locale.isEmpty();
+		aEntryKey.bDefault = bDefault;
+	
+		KEntry aEntry;	
+		aEntry.mValue = QCString((const char*)keyStealValue(key));
+		aEntry.bGlobal = bGlobal;
+		aEntry.bImmutable = keyImmutable;
+		aEntry.bDeleted = keyDeleted;
+		aEntry.bExpand = keyExpand;
+		aEntry.bNLS = !locale.isEmpty();
+	
+		if ( pWriteBackMap ) {
+			// don't insert into the config object but into the temporary
+			// scratchpad map
+			pWriteBackMap->insert(aEntryKey, aEntry);
+		} else {
+			// directly insert value into config object
+			// no need to specify localization; if the key we just
+			// retrieved was localized already, no need to localize it again.
+			pConfig->putData(aEntryKey, aEntry, false);
+		}
+	}
+	ksDel(groups);
+	
+	kdbClose(&kdbHandle);
+	
+	if (mainImmutable)
+		bFileImmutable = true;
+}
+
+void KConfigElektraParser::sync(bool bMerge)
+{
+	bool bEntriesLeft = false;
+
+	/* bMerge true if data have to be merged with data
+	   already present on disk. */
+
+	// Try to save into the most specific first
+	if ( !mfileName.isEmpty() ) {
+		// Can we allow the write? We can, if the program
+		// doesn't run SUID. But if it runs SUID, we must
+		// check if the user would be allowed to write if
+		// it wasn't SUID.
+		bEntriesLeft = writeConfigKeys(mLocalKeyRoot, false, bMerge);
+	}
+	
+	// only write out entries to the kdeglobals file if there are any
+	// entries marked global (indicated by bEntriesLeft) and
+	// the useKDEGlobals flag is set.
+	if (bEntriesLeft && useKDEGlobals) {
+		writeConfigKeys(mGlobalKeyRoot, true, true); // Always merge
+	}
+
+}
+	
+static void writeKeyEntries(QString underKeyRoot, const KEntryMap& entryMap, bool defaultGroup, bool &firstEntry, const QCString &localeString)
+{
+	KeySet	*keysToStore;
+	
+	keysToStore = ksNew();
+
+	// now write out all other groups.
+	QCString currentGroup, currentKey;
+	for (KEntryMapConstIterator aIt = entryMap.begin(); aIt != entryMap.end(); ++aIt) {
+		const KEntryKey &key = aIt.key();
+		const KEntry &currentEntry = *aIt;
+		QString keyName;
+			
+		keyName  = underKeyRoot;
+		keyName += "/";
+		
+		// Either proces the default group or all others
+		if ((key.mGroup != "<default>") == defaultGroup)
+			continue; // Skip
+	
+		// Skip default values and group headers.
+		if ((key.bDefault) || key.mKey.isEmpty())
+			continue; // Skip
+	
+		KEntryMapConstIterator aTestIt = aIt;
+		++aTestIt;
+		bool hasDefault = (aTestIt != entryMap.end());
+		if (hasDefault) {
+			const KEntryKey &defaultKey = aTestIt.key();
+			if ((!defaultKey.bDefault) ||
+				(defaultKey.mKey != key.mKey) ||
+				(defaultKey.mGroup != key.mGroup) ||
+				(defaultKey.bLocal != key.bLocal))
+				hasDefault = false;
+		}
+	
+		if (hasDefault) {
+			// Entry had a default value
+			if ((currentEntry.mValue == (*aTestIt).mValue) &&
+				(currentEntry.bDeleted == (*aTestIt).bDeleted))
+				continue; // Same as default, don't write.
+		} else {
+			// Entry had no default value.
+			if (currentEntry.bDeleted)
+				continue; // Don't write deleted entries if there is no default.
+		}
+	
+		if (!defaultGroup && (currentGroup != key.mGroup)) {
+			currentGroup = key.mGroup;
+		}
+		keyName += currentGroup.replace("/", "\\/");
+		keyName += "/";
+	
+		firstEntry = false;
+		// it is data for a group
+		currentKey = key.mKey;
+		keyName += currentKey.replace("/", "\\/");	// key;
+	
+		if ( currentEntry.bNLS ) {
+			keyName += "[";
+			keyName += localeString;
+			keyName += "]";
+		}
+	
+		if (currentEntry.bDeleted) {
+			keyName += "[$d]";
+		}
+
+		Key *toStore;
+	
+		if (currentEntry.bImmutable || currentEntry.bExpand) {
+			keyName += "[$";
+			if (currentEntry.bImmutable)
+				keyName += "i";
+			if (currentEntry.bExpand)
+				keyName += "e";
+			keyName += "]";
+		}
+		toStore = keyNew(keyName.latin1(),
+				KEY_SWITCH_VALUE, (const char*) currentEntry.mValue,
+				KEY_SWITCH_END);
+		
+		ksAppendKey(keysToStore, toStore);
+	} // for loop
+	
+	if ( ksGetSize(keysToStore) ) {
+		KDB handle;
+
+		kdbOpen(&handle);
+		kdbSetKeys(handle, keysToStore);
+		kdbClose(&handle);
+	}
+	ksDel(keysToStore);
+}
+	
+bool KConfigElektraParser::getEntryMap(KEntryMap &aTempMap, bool bGlobal, QString mergeKeys)
+{
+	KDB handle;
+	bool bEntriesLeft = false;
+	bFileImmutable = false;
+
+	// Read entries from disk
+	Key *mergeKey;
+
+	kdbOpen(&handle);
+
+	mergeKey = keyNew(mergeKeys.latin1(), KEY_SWITCH_END);
+	if ( !mergeKeys.isEmpty() && (kdbStatKey(handle, mergeKey) == 0) ) {
+		// fill the temporary structure with entries from the file
+		kdbClose(&handle);
+		parseKeysFrom(mergeKeys, &aTempMap, bGlobal, false);
+
+		if (bFileImmutable) { // File has become immutable on disk
+			keyDel(mergeKey);
+			return bEntriesLeft;
+		}
+	}
+	keyDel(mergeKey);
+	kdbClose(&handle);
+	
+	KEntryMap aMap = pConfig->internalEntryMap();
+
+	// augment this structure with the dirty entries from the config object
+	for (KEntryMapIterator aIt = aMap.begin();aIt != aMap.end(); ++aIt) {
+		const KEntry &currentEntry = *aIt;
+
+		if(aIt.key().bDefault) {
+			aTempMap.replace(aIt.key(), currentEntry);
+			continue;
+		}
+
+		if (!mergeKeys.isEmpty() && !currentEntry.bDirty)
+			continue;
+
+		// only write back entries that have the same
+		// "globality" as the file
+		if (currentEntry.bGlobal != bGlobal) {
+			// wrong "globality" - might have to be saved later
+			bEntriesLeft = true;
+			continue;
+		}
+	
+		// put this entry from the config object into the
+		// temporary map, possibly replacing an existing entry
+		KEntryMapIterator aIt2 = aTempMap.find(aIt.key());
+		if (aIt2 != aTempMap.end() && (*aIt2).bImmutable)
+			continue; // Bail out if the on-disk entry is immutable
+	
+		aTempMap.insert(aIt.key(), currentEntry, true);
+	} // loop
+		
+
+	return bEntriesLeft; 
+}
+
+QString KConfigElektraParser::escapeGroupName(const QString &groupName)
+{
+	QString ret;
+
+	ret = groupName;
+	
+	// Replace the first '/' only
+	if ( ret[0] == QChar('/') ) {
+		ret = "\\/";
+		ret += groupName.mid(1, groupName.length());
+	}
+	ret.replace("//", "\\/\\/");
+
+	return ret;
+}
+
+/* antlarr: KDE 4.0:  make the first parameter "const QString &" */
+bool KConfigElektraParser::writeConfigKeys(QString &keyRoot, bool bGlobal, bool bMerge)
+{
+	KDB handle;
+	
+	// is the config object read-only?
+	if (pConfig->isReadOnly()) {
+		return true; // pretend we wrote it
+	}
+
+	KEntryMap aTempMap;
+	bool bEntriesLeft = getEntryMap(aTempMap, bGlobal,(bMerge ? keyRoot : QString("")));
+
+	//if (bFileImmutable)
+	//	return true; // pretend we wrote it
+
+	// OK now the temporary map should be full of ALL entries.
+	// write it out to disk.
+
+	// Check if file exists:
+	int fileMode = -1;
+	bool createNew = true;
+
+	kdbOpen(&handle);
+
+	Key *kRoot;
+	kRoot = keyNew(keyRoot.latin1(), KEY_SWITCH_END);
+	if ( kdbStatKey(handle, kRoot) == 0 ) {
+		if ( keyGetUID(kRoot) == getuid()) {
+			// Preserve file mode if file exists and is owned by user.
+			fileMode = keyGetAccess(kRoot) & 0777;
+		}
+		createNew = false;
+	}
+	keyDel(kRoot);
+
+	if (createNew) {
+		Key *kRoot;
+
+		kRoot = keyNew(keyRoot.latin1(),
+				KEY_SWITCH_TYPE, KEY_TYPE_DIR,
+				KEY_SWITCH_ACCESS, 0700,
+				KEY_SWITCH_END);
+
+		if ( kdbSetKey(handle, kRoot) != 0 ) {
+			kdbRemoveKey(handle, kRoot);
+			keyDel(kRoot);
+			kdbClose(&handle);
+			fprintf(stderr, "\tDidn't succeed to create \"%s\"\n", keyRoot.latin1());
+			return bEntriesLeft;
+		}
+		
+		if (!bGlobal && (fileMode == -1))
+			fileMode = mFileMode;
+
+		if (fileMode != -1) {
+			keySetAccess(kRoot, fileMode);
+			kdbSetKey(handle, kRoot);
+		}
+		keyDel(kRoot);
+
+	}
+
+	writeEntries(keyRoot, aTempMap);
+	
+	// Check if configuration is empty
+	KeySet *ks;
+
+	ks = ksNew();
+	kdbGetChildKeys(handle, keyRoot.latin1(), ks, KDB_O_DIR | KDB_O_STATONLY | KDB_O_INACTIVE | KDB_O_NUMBERS);
+	if ( (ksGetSize(ks) == 0)  && (fileMode == -1) || (fileMode == 0600) ) {
+		// File is empty and doesn't have special permissions: delete it.
+		Key *kRoot;
+
+		kRoot = keyNew(keyRoot.latin1(), KEY_SWITCH_END);
+		kdbRemoveKey(handle, kRoot);
+		keyDel(kRoot);
+	}
+	ksDel(ks);
+
+	kdbClose(&handle);
+
+	return bEntriesLeft;
+}
+	
+void KConfigElektraParser::writeEntries(QString &keyRoot, const KEntryMap &aTempMap)
+{
+	bool firstEntry = true;
+	
+	// Write default group
+	::writeKeyEntries(keyRoot, aTempMap, true, firstEntry, localeString);
+	
+	// Write all other groups
+	::writeKeyEntries(keyRoot, aTempMap, false, firstEntry, localeString);
+}
+
+
+KLockFile::Ptr KConfigElektraParser::lockFile(bool bGlobal)
+{
+	/* if (bGlobal) {
+		if (mGlobalLockFile)
+			return mGlobalLockFile;
+      
+		if (!mGlobalFileName.isEmpty()) {
+			mGlobalLockFile = new KLockFile(mGlobalFileName+".lock");
+			return mGlobalLockFile;
+		}
+	} else {
+		if (mLocalLockFile)
+			return mLocalLockFile;
+
+		if (!mLocalFileName.isEmpty()) {
+			mLocalLockFile = new KLockFile(mLocalFileName+".lock");
+			return mLocalLockFile;
+		}
+	} */
+
+	return 0;
+}
+
+
+bool keyAccess(const QString &keyName, int mode)
+{
+	KDB	handle;
+	Key		*key;
+	mode_t		keyMode;
+	uid_t		euid, keyUid;
+	gid_t		egid, keyGid;
+	bool		uAllowed, gAllowed, oAllowed;
+	
+	key = keyNew(keyName.latin1(), KEY_SWITCH_END);
+	kdbOpen(&handle);
+	if ( kdbStatKey(handle, key) ) {
+		// Key doesn't exist
+		keyDel(key);
+		kdbClose(&handle);
+		return false;
+	}
+	kdbClose(&handle);
+	keyUid = keyGetUID(key);
+	keyGid = keyGetGID(key);
+	keyMode = keyGetAccess(key);
+	keyDel(key);
+
+	// Get effective uid/gid
+	euid = geteuid();
+	egid = getegid();
+
+	if ( euid == 0 ) {
+		return 0;
+	}
+	
+	if ( (mode & R_OK) ) {
+		// Is allowed to read ?
+		uAllowed = (keyMode & S_IRUSR) && (keyUid == euid);
+		gAllowed = (keyMode & S_IRGRP) && (keyGid == egid);
+		oAllowed = (keyMode & S_IROTH);
+
+		if ( !(uAllowed || gAllowed || oAllowed) ) {
+			return 0; // -1
+		}
+	}
+
+	if ( (mode & W_OK) ) {
+		// Is allowed to write ?
+		uAllowed = (keyMode & S_IWUSR) && (keyUid == euid);
+		gAllowed = (keyMode & S_IWGRP) && (keyGid == egid);
+		oAllowed = (keyMode & S_IWOTH);
+
+		if ( !(uAllowed || gAllowed || oAllowed) ) {
+			return 0; // -1
+		}
+	}
+
+	if ( (mode & X_OK) ) {
+		// Is allowed to write ?
+		uAllowed = (keyMode & S_IXUSR) && (keyUid == euid);
+		gAllowed = (keyMode & S_IXGRP) && (keyGid == egid);
+		oAllowed = (keyMode & S_IXOTH);
+
+		if ( !(uAllowed || gAllowed || oAllowed) ) {
+			return 0; // -1
+		}
+	}
+
+	return 0;
+}
+
+bool checkKeyAccess(const QString &keyName, int mode)
+{
+	int accessOK = keyAccess(keyName, mode);
+	if ( accessOK == 0 )
+		return true;  // OK, I can really access the file
+
+	// else
+	// if we want to write the key would be created. Check, if the
+	// user may write to the directory to create the file.
+	if ( (mode & W_OK) == 0 )
+		return false;   // Check for write access is not part of mode => bail out
+
+	if (!keyAccess( keyName, F_OK)) // if it already exists
+		return false;
+
+	//strip the filename (everything until '/' from the end
+	Key *key;
+	key = keyNew(keyName.latin1(), KEY_SWITCH_END);
+	accessOK = keyAccess( QString(keyStealBaseName(key)), W_OK );
+	// -?- Can I write to the accessed diretory
+	if ( accessOK == 0 )
+		return true;  // Yes
+	else
+		return false; // No
+}
+
+bool KConfigElektraParser::checkConfigFilesWritable(bool warnUser)
+{	
+	// WARNING: Do NOT use the event loop as it may not exist at this time.
+	bool allWritable = true;
+
+	QString errorMsg( i18n("Will not save configuration.\n") );
+	if ( !mfileName.isEmpty() && !bFileImmutable && !checkKeyAccess(mLocalKeyRoot, W_OK) ) {
+		allWritable = false;
+		errorMsg += i18n("Configuration key \"%1\" not writable.\n").arg(mLocalKeyRoot);
+	}
+
+	// We do not have an immutability flag for kdeglobals. However, making kdeglobals mutable while making
+	// the local config file immutable is senseless.
+	if ( useKDEGlobals && !bFileImmutable && !checkKeyAccess(mGlobalKeyRoot, W_OK) ) {
+		errorMsg += i18n("Configuration key \"%1\" not writable.\n").arg(mGlobalKeyRoot);
+		allWritable = false;
+	}
+
+	if (warnUser && !allWritable) {
+		// Note: We don't ask the user if we should not ask this question again because we can't save the answer.
+		errorMsg += i18n("Please contact your system administrator.");
+		QString cmdToExec = KStandardDirs::findExe(QString("kdialog"));
+		KApplication *app = kapp;
+		if (!cmdToExec.isEmpty() && app) {
+			KProcess lprocess;
+			lprocess << cmdToExec << "--title" << app->instanceName() << "--msgbox" << errorMsg.local8Bit();
+			lprocess.start( KProcess::Block );
+		}
+	} 
+
+	return allWritable;
+}	
diff -Naur kdelibs-3.5.2.orig/kdecore/kconfigelektraparser.h kdelibs-3.5.2/kdecore/kconfigelektraparser.h
--- kdelibs-3.5.2.orig/kdecore/kconfigelektraparser.h	1970-01-01 01:00:00.000000000 +0100
+++ kdelibs-3.5.2/kdecore/kconfigelektraparser.h	2006-05-21 13:08:36.000000000 +0200
@@ -0,0 +1,49 @@
+/*
+	KConfigElektraParser
+	Yannick Lecaillez - <sizon5@gmail.com>
+
+	KConfig configuration parser using elektra as backend.
+*/
+
+#ifndef _KCONFIGELEKTRAPARSER_H
+#define _KCONFIGELEKTRAPARSER_H
+
+#include "kconfigdata.h"
+#include <kconfigbase.h>
+#include "kconfigparser.h"
+#include <klockfile.h>
+#include "kdelibs_export.h"
+
+#include <qdir.h>
+#include <qfileinfo.h>
+
+class KDECORE_EXPORT KConfigElektraParser : public KConfigParser
+{
+	public:
+		KConfigElektraParser(KConfigBase *config, const QString &fileName, const char *resType, bool useKDEGlobals);
+
+   		static bool KConfigElektraParser::keyExists(QString keyName);
+   		static void writeKeys(QString keyRoot, const KEntryMap &map, QString localeString,  QFileInfo fileInfo);
+   		static QString fileNameToKeyRoot(QString absFileName);
+
+		virtual bool parseConfigFiles();
+		virtual void sync(bool bMerge);
+		virtual bool checkConfigFilesWritable(bool warnUser);
+		virtual KLockFile::Ptr lockFile(bool bGlobal);
+	
+	protected:
+		bool isAbsoluteKeyName(const QString &keyName);
+		static QString escapeGroupName(const QString &groupName);
+		void parseKeysFrom(QString keyRoot, KEntryMap *pWriteBackMap = 0L,
+			     bool bGlobal = false, bool bDefault = false);
+		bool writeConfigKeys(QString &keyRoot, bool bGlobal = false, bool bMerge = true);
+		bool getEntryMap(KEntryMap &map, bool bGlobal, QString mergeKey);
+		void writeEntries(QString &keyRoot, const KEntryMap &aTempMap);
+
+	private:
+		QString	mLocalKeyRoot;
+		QString mGlobalKeyRoot;
+
+};
+
+#endif
diff -Naur kdelibs-3.5.2.orig/kdecore/kconfiginiparser.cpp kdelibs-3.5.2/kdecore/kconfiginiparser.cpp
--- kdelibs-3.5.2.orig/kdecore/kconfiginiparser.cpp	1970-01-01 01:00:00.000000000 +0100
+++ kdelibs-3.5.2/kdecore/kconfiginiparser.cpp	2006-05-21 13:06:22.000000000 +0200
@@ -0,0 +1,1055 @@
+/*
+	KConfigINIParser
+	
+	Yannick Lecaillez - <sizon5@gmail.com>
+
+	KConfig configuration parser using INI file.
+	This is a simple restructuration of the original KConfigINIBackEnd
+	written by
+
+	Copyright (c) 1999 Preston Brown <pbrown@kde.org>
+	Copyright (c) 1997-1999 Matthias Kalle Dalheimer <kalle@kde.org>
+*/
+
+#include "kdbconfig.h"
+
+#include <unistd.h>
+#include <ctype.h>
+#ifdef HAVE_SYS_MMAN_H
+#include <sys/mman.h>
+#endif
+#include <sys/types.h>
+#ifdef HAVE_SYS_STAT_H
+#include <sys/stat.h>
+#endif
+#include <fcntl.h>
+#include <signal.h>
+#include <setjmp.h>
+
+#include <qdir.h>
+#include <qfileinfo.h>
+#include <qtextcodec.h>
+#include <qtextstream.h>
+
+#include "kconfigparser.h"
+#include "kconfiginiparser.h"
+#include "kconfigbase.h"
+#include <kapplication.h>
+#include <kglobal.h>
+#include <kprocess.h>
+#include <klocale.h>
+#include <kstandarddirs.h>
+#include <ksavefile.h>
+#include <kurl.h>
+#include <kde_file.h>
+
+extern bool checkAccess(const QString& pathname, int mode);
+/* translate escaped escape sequences to their actual values. */
+static QCString printableToString(const char *str, int l)
+{
+  // Strip leading white-space.
+  while((l>0) &&
+        ((*str == ' ') || (*str == '\t') || (*str == '\r')))
+  {
+     str++; l--;
+  }
+
+  // Strip trailing white-space.
+  while((l>0) &&
+        ((str[l-1] == ' ') || (str[l-1] == '\t') || (str[l-1] == '\r')))
+  {
+     l--;
+  }
+
+  QCString result(l + 1);
+  char *r = result.data();
+
+  for(int i = 0; i < l;i++, str++)
+  {
+     if (*str == '\\')
+     {
+        i++, str++;
+        if (i >= l) // End of line. (Line ends with single slash)
+        {
+           *r++ = '\\';
+           break;
+        }
+        switch(*str)
+        {
+           case 's':
+              *r++ = ' ';
+              break;
+           case 't':
+              *r++ = '\t';
+              break;
+           case 'n':
+              *r++ = '\n';
+              break;
+           case 'r':
+              *r++ = '\r';
+              break;
+           case '\\':
+              *r++ = '\\';
+              break;
+           default:
+              *r++ = '\\';
+              *r++ = *str;
+        }
+     }
+     else
+     {
+        *r++ = *str;
+     }
+  }
+  result.truncate(r-result.data());
+  return result;
+}
+
+static QCString stringToPrintable(const QCString& str){
+  QCString result(str.length()*2); // Maximum 2x as long as source string
+  register char *r = result.data();
+  register char *s = str.data();
+
+  if (!s) return QCString("");
+
+  // Escape leading space
+  if (*s == ' ')
+  {
+     *r++ = '\\'; *r++ = 's';
+     s++;
+  }
+
+  if (*s)
+  {
+   while(*s)
+   {
+    if (*s == '\n')
+    {
+      *r++ = '\\'; *r++ = 'n';
+    }
+    else if (*s == '\t')
+    {
+      *r++ = '\\'; *r++ = 't';
+    }
+    else if (*s == '\r')
+    {
+      *r++ = '\\'; *r++ = 'r';
+    }
+    else if (*s == '\\')
+    {
+      *r++ = '\\'; *r++ = '\\';
+    }
+    else
+    {
+      *r++ = *s;
+    }
+    s++;
+   }
+   // Escape trailing space
+   if (*(r-1) == ' ')
+   {
+      *(r-1) = '\\'; *r++ = 's';
+   }
+  }
+
+  result.truncate(r - result.data());
+  return result;
+}
+
+static QCString decodeGroup(const char*s, int l)
+{
+  QCString result(l);
+  register char *r = result.data();
+
+  l--; // Correct for trailing \0
+  while(l)
+  {
+    if ((*s == '[') && (l > 1))
+    {
+       if ((*(s+1) == '['))
+       {
+          l--;
+          s++;
+       }
+    }
+    if ((*s == ']') && (l > 1))
+    {
+       if ((*(s+1) == ']'))
+       {
+          l--;
+          s++;
+       }
+    }
+    *r++ = *s++;
+    l--;
+  }
+  result.truncate(r - result.data());
+  return result;
+}
+
+static QCString encodeGroup(const QCString &str)
+{
+  int l = str.length();
+  QCString result(l*2+1);
+  register char *r = result.data();
+  register char *s = str.data();
+  while(l)
+  {
+    if ((*s == '[') || (*s == ']'))
+       *r++ = *s;
+    *r++ = *s++;
+    l--;
+  }
+  result.truncate(r - result.data());
+  return result;
+}
+
+
+KConfigINIParser::KConfigINIParser(KConfigBase *config, const QString &fileName, const char *resType, bool useKDEGlobals) : KConfigParser(config, fileName, resType, useKDEGlobals)
+{
+	if (fileName.isEmpty())
+		mLocalFileName = QString::null;
+	else if (!QDir::isRelativePath(mfileName))
+		mLocalFileName = mfileName;
+	else
+		mLocalFileName = KGlobal::dirs()->saveLocation(resType) + mfileName;
+
+	if (useKDEGlobals)
+		mGlobalFileName = KGlobal::dirs()->saveLocation("config") + QString::fromLatin1("kdeglobals");
+	else
+		mGlobalFileName = QString::null;
+
+	mLocalLastModified = QDateTime();
+	mLocalLastSize = 0;
+	mLocalLockFile = 0;
+	mGlobalLockFile = 0;
+}
+
+bool KConfigINIParser::parseConfigFiles()
+{
+	// Check if we can write to the local file.
+	mConfigState = KConfigBase::ReadOnly;
+	if (!mLocalFileName.isEmpty() && !pConfig->isReadOnly()) {
+		if (checkAccess(mLocalFileName, W_OK)) {
+			mConfigState = KConfigBase::ReadWrite;
+		} else {
+        		// Create the containing dir, maybe it wasn't there
+		        KURL path;
+		        path.setPath(mLocalFileName);
+		        QString dir=path.directory();
+		        KStandardDirs::makeDir(dir);
+
+		        if (checkAccess(mLocalFileName, W_OK)) {
+				mConfigState = KConfigBase::ReadWrite;
+			}
+		}
+		QFileInfo info(mLocalFileName);
+		mLocalLastModified = info.lastModified();
+		mLocalLastSize = info.size();
+	}
+
+	// Parse all desired files from the least to the most specific.
+	bFileImmutable = false;
+
+	// Parse the general config files
+	if (useKDEGlobals) {
+		QStringList kdercs = KGlobal::dirs()-> findAllResources("config", QString::fromLatin1("kdeglobals"));
+
+#ifdef Q_WS_WIN
+		QString etc_kderc = QFile::decodeName( QCString(getenv("WINDIR")) + "\\kderc" );
+#else
+		QString etc_kderc = QString::fromLatin1("/etc/kderc");
+#endif
+
+		if (checkAccess(etc_kderc, R_OK))
+			kdercs += etc_kderc;
+
+		kdercs += KGlobal::dirs()-> findAllResources("config", QString::fromLatin1("system.kdeglobals"));
+
+		QStringList::ConstIterator it;
+
+		for (it = kdercs.fromLast(); it != kdercs.end(); --it) {
+			QFile aConfigFile( *it );
+			if (!aConfigFile.open( IO_ReadOnly ))
+				continue;
+			parseSingleConfigFile( aConfigFile, 0L, true, (*it != mGlobalFileName) );
+			aConfigFile.close();
+			if (bFileImmutable)
+				break;
+		}
+	}
+
+	bool bReadFile = !mfileName.isEmpty();
+	while(bReadFile) {
+		bReadFile = false;
+		QString bootLanguage;
+		if (useKDEGlobals && localeString.isEmpty() && !KGlobal::_locale) {
+			// Boot strap language
+			bootLanguage = KLocale::_initLanguage(pConfig);
+			setLocaleString(bootLanguage.utf8());
+		}
+
+		bFileImmutable = false;
+		QStringList list;
+		if ( !QDir::isRelativePath(mfileName) )
+			list << mfileName;
+		else
+			list = KGlobal::dirs()->findAllResources(resType, mfileName);
+
+		QStringList::ConstIterator it;
+
+		for (it = list.fromLast(); it != list.end(); --it) {
+			QFile aConfigFile( *it );
+			// we can already be sure that this file exists
+			bool bIsLocal = (*it == mLocalFileName);
+			if (aConfigFile.open( IO_ReadOnly )) {
+				parseSingleConfigFile( aConfigFile, 0L, false, !bIsLocal );
+				aConfigFile.close();
+				if (bFileImmutable)
+					break;
+			}
+		}
+		if (KGlobal::dirs()->isRestrictedResource(resType, mfileName))
+			bFileImmutable = true;
+		
+		QString currentLanguage;
+		if (!bootLanguage.isEmpty()) {
+			currentLanguage = KLocale::_initLanguage(pConfig);
+			// If the file changed the language, we need to read the file again
+			// with the new language setting.
+			if (bootLanguage != currentLanguage) {
+				bReadFile = true;
+				setLocaleString(currentLanguage.utf8());
+			}
+		}
+	}
+	if (bFileImmutable)
+		mConfigState = KConfigBase::ReadOnly;
+
+	return true;
+}
+
+#ifdef HAVE_MMAP
+#ifdef SIGBUS
+static sigjmp_buf mmap_jmpbuf;
+struct sigaction mmap_old_sigact;
+
+extern "C" {
+   static void mmap_sigbus_handler(int)
+   {
+      siglongjmp (mmap_jmpbuf, 1);
+   }
+}
+#endif
+#endif
+
+extern bool kde_kiosk_exception;
+
+void KConfigINIParser::parseSingleConfigFile(QFile &rFile,
+					      KEntryMap *pWriteBackMap,
+					      bool bGlobal, bool bDefault)
+{
+   const char *s; // May get clobbered by sigsetjump, but we don't use them afterwards.
+   const char *eof; // May get clobbered by sigsetjump, but we don't use them afterwards.
+   QByteArray data;
+
+   if (!rFile.isOpen()) // come back, if you have real work for us ;->
+      return;
+
+
+   //using kdDebug() here leads to an infinite loop
+   //remove this for the release, aleXXX
+   //qWarning("Parsing %s, global = %s default = %s",
+   //           rFile.name().latin1(), bGlobal ? "true" : "false", bDefault ? "true" : "false");
+
+   QCString aCurrentGroup("<default>");
+
+   unsigned int ll = localeString.length();
+
+#ifdef HAVE_MMAP
+   static volatile const char *map;
+   map = ( const char* ) mmap(0, rFile.size(), PROT_READ, MAP_PRIVATE,
+                                          rFile.handle(), 0);
+
+   if ( map != MAP_FAILED )
+   {
+      s = (const char*) map;
+      eof = s + rFile.size();
+
+#ifdef SIGBUS
+      struct sigaction act;
+      act.sa_handler = mmap_sigbus_handler;
+      sigemptyset( &act.sa_mask );
+#ifdef SA_ONESHOT
+      act.sa_flags = SA_ONESHOT;
+#else
+      act.sa_flags = SA_RESETHAND;
+#endif      
+      sigaction( SIGBUS, &act, &mmap_old_sigact );
+
+      if (sigsetjmp (mmap_jmpbuf, 1))
+      {
+qWarning("SIGBUS while reading %s", rFile.name().latin1());
+         munmap(( char* )map, rFile.size());
+         sigaction (SIGBUS, &mmap_old_sigact, 0);
+         return;
+      }
+#endif
+   }
+   else
+#endif
+   {
+      rFile.at(0);
+      data = rFile.readAll();
+      s = data.data();
+      eof = s + data.size();
+   }
+
+   bool fileOptionImmutable = false;
+   bool groupOptionImmutable = false;
+   bool groupSkip = false;
+
+   int line = 0;
+      
+   for(; s < eof; s++)
+   {
+      line++;
+
+      while((s < eof) && isspace(*s) && (*s != '\n'))
+         s++; //skip leading whitespace, shouldn't happen too often
+
+      //skip empty lines, lines starting with #
+      if ((s < eof) && ((*s == '\n') || (*s == '#')))
+      {
+    sktoeol:	//skip till end-of-line
+         while ((s < eof) && (*s != '\n'))
+            s++;
+         continue; // Empty or comment or no keyword
+      }
+      const char *startLine = s;
+
+      if (*s == '[')  //group
+      {
+         // In a group [[ and ]] have a special meaning
+         while ((s < eof) && (*s != '\n')) 
+         {
+            if (*s == ']')
+            {
+               if ((s+1 < eof) && (*(s+1) == ']'))
+                  s++; // Skip "]]"
+               else
+                  break;
+            }
+
+            s++; // Search till end of group
+         }
+         const char *e = s;
+         while ((s < eof) && (*s != '\n')) s++; // Search till end of line / end of file
+         if ((e >= eof) || (*e != ']'))
+         {
+            fprintf(stderr, "Invalid group header at %s:%d\n", rFile.name().latin1(), line);
+            continue;
+         }
+         // group found; get the group name by taking everything in
+         // between the brackets
+         if ((e-startLine == 3) &&
+             (startLine[1] == '$') &&
+             (startLine[2] == 'i'))
+         {
+            if (!kde_kiosk_exception)
+               fileOptionImmutable = true;
+            continue;
+         }
+
+         aCurrentGroup = decodeGroup(startLine + 1, e - startLine);
+         //cout<<"found group ["<<aCurrentGroup<<"]"<<endl;
+
+         // Backwards compatibility
+         if (aCurrentGroup == "KDE Desktop Entry")
+            aCurrentGroup = "Desktop Entry";
+
+         groupOptionImmutable = fileOptionImmutable;
+
+         e++;
+         if ((e+2 < eof) && (*e++ == '[') && (*e++ == '$')) // Option follows
+         {
+            if ((*e == 'i') && !kde_kiosk_exception)
+            {
+               groupOptionImmutable = true;
+            }
+         }
+
+         KEntryKey groupKey(aCurrentGroup, 0);
+         KEntry entry = pConfig->lookupData(groupKey);
+         groupSkip = entry.bImmutable;
+
+         if (groupSkip && !bDefault)
+            continue;
+
+	 entry.bImmutable |= groupOptionImmutable;
+         pConfig->putData(groupKey, entry, false);
+
+         if (pWriteBackMap)
+         {
+            // add the special group key indicator
+            (*pWriteBackMap)[groupKey] = entry;
+         }
+
+         continue;
+      }
+      if (groupSkip && !bDefault)
+        goto sktoeol; // Skip entry
+
+      bool optionImmutable = groupOptionImmutable;
+      bool optionDeleted = false;
+      bool optionExpand = false;
+      const char *endOfKey = 0, *locale = 0, *elocale = 0;
+      for (; (s < eof) && (*s != '\n'); s++)
+      {
+         if (*s == '=') //find the equal sign
+         {
+	    if (!endOfKey)
+        	endOfKey = s;
+            goto haveeq;
+	 }
+	 if (*s == '[') //find the locale or options.
+	 {
+            const char *option;
+            const char *eoption;
+	    endOfKey = s;
+	    option = ++s;
+	    for (;; s++)
+	    {
+		if ((s >= eof) || (*s == '\n') || (*s == '=')) {
+		    fprintf(stderr, "Invalid entry (missing ']') at %s:%d\n", rFile.name().latin1(), line);
+		    goto sktoeol;
+		}
+		if (*s == ']')
+		    break;
+	    }
+	    eoption = s;
+            if (*option != '$')
+            {
+              // Locale
+              if (locale) {
+		fprintf(stderr, "Invalid entry (second locale!?) at %s:%d\n", rFile.name().latin1(), line);
+		goto sktoeol;
+              }
+              locale = option;
+              elocale = eoption;
+            }
+            else
+            {
+              // Option
+              while (option < eoption)
+              {
+                 option++;
+                 if ((*option == 'i') && !kde_kiosk_exception)
+                    optionImmutable = true;
+                 else if (*option == 'e')
+                    optionExpand = true;
+                 else if (*option == 'd')
+                 {
+                    optionDeleted = true;
+                    goto haveeq;
+                 }
+		 else if (*option == ']')
+		    break;
+              }
+            }
+         }
+      }
+      fprintf(stderr, "Invalid entry (missing '=') at %s:%d\n", rFile.name().latin1(), line);
+      continue;
+
+   haveeq:
+      for (endOfKey--; ; endOfKey--)
+      {
+	 if (endOfKey < startLine)
+	 {
+	   fprintf(stderr, "Invalid entry (empty key) at %s:%d\n", rFile.name().latin1(), line);
+	   goto sktoeol;
+	 }
+	 if (!isspace(*endOfKey))
+	    break;
+      }
+
+      const char *st = ++s;
+      while ((s < eof) && (*s != '\n')) s++; // Search till end of line / end of file
+
+      if (locale) {
+          unsigned int cl = static_cast<unsigned int>(elocale - locale);
+          if ((ll != cl) || memcmp(locale, localeString.data(), ll))
+          {
+              // backward compatibility. C == en_US
+              if ( cl != 1 || ll != 5 || *locale != 'C' || memcmp(localeString.data(), "en_US", 5)) {
+                  //cout<<"mismatched locale '"<<QCString(locale, elocale-locale +1)<<"'"<<endl;
+                  // We can ignore this one
+                  if (!pWriteBackMap)
+                      continue; // We just ignore it
+                  // We just store it as is to be able to write it back later.
+                  endOfKey = elocale;
+                  locale = 0;
+              }
+          }
+      }
+
+      // insert the key/value line
+      QCString key(startLine, endOfKey - startLine + 2);
+      QCString val = printableToString(st, s - st);
+      //qDebug("found key '%s' with value '%s'", key.data(), val.data());
+
+      KEntryKey aEntryKey(aCurrentGroup, key);
+      aEntryKey.bLocal = (locale != 0);
+      aEntryKey.bDefault = bDefault;
+
+      KEntry aEntry;
+      aEntry.mValue = val;
+      aEntry.bGlobal = bGlobal;
+      aEntry.bImmutable = optionImmutable;
+      aEntry.bDeleted = optionDeleted;
+      aEntry.bExpand = optionExpand;
+      aEntry.bNLS = (locale != 0);
+
+      if (pWriteBackMap) {
+         // don't insert into the config object but into the temporary
+         // scratchpad map
+         pWriteBackMap->insert(aEntryKey, aEntry);
+      } else {
+         // directly insert value into config object
+         // no need to specify localization; if the key we just
+         // retrieved was localized already, no need to localize it again.
+         pConfig->putData(aEntryKey, aEntry, false);
+      }
+   }
+
+   if (fileOptionImmutable)
+      bFileImmutable = true;
+
+#ifdef HAVE_MMAP
+   if (map)
+   {
+      munmap(( char* )map, rFile.size());
+#ifdef SIGBUS
+      sigaction (SIGBUS, &mmap_old_sigact, 0);
+#endif
+   }
+#endif
+}
+
+
+void KConfigINIParser::sync(bool bMerge)
+{
+
+  // write-sync is only necessary if there are dirty entries
+  if (!pConfig->isDirty())
+    return;
+
+  bool bEntriesLeft = true;
+
+  // find out the file to write to (most specific writable file)
+  // try local app-specific file first
+
+  if (!mfileName.isEmpty()) {
+    // Create the containing dir if needed
+    if ((resType!="config") && !QDir::isRelativePath(mLocalFileName))
+    {
+       KURL path;
+       path.setPath(mLocalFileName);
+       QString dir=path.directory();
+       KStandardDirs::makeDir(dir);
+    }
+
+    // Can we allow the write? We can, if the program
+    // doesn't run SUID. But if it runs SUID, we must
+    // check if the user would be allowed to write if
+    // it wasn't SUID.
+    if (checkAccess(mLocalFileName, W_OK)) {
+      // File is writable
+      KLockFile::Ptr lf;
+
+      bool mergeLocalFile = bMerge;
+      // Check if the file has been updated since.
+      if (mergeLocalFile)
+      {
+         lf = lockFile(false); // Lock file for local file
+         if (lf && lf->isLocked())
+            lf = 0; // Already locked, we don't need to lock/unlock again
+
+         if (lf) 
+         {
+            lf->lock( KLockFile::LockForce );
+            // But what if the locking failed? Ignore it for now...
+         }
+         
+         QFileInfo info(mLocalFileName);
+         if ((mLocalLastSize == info.size()) &&
+             (mLocalLastModified == info.lastModified()))
+         {
+            // Not changed, don't merge.
+            mergeLocalFile = false;
+         }
+         else
+         {
+            // Changed...
+            mLocalLastModified = QDateTime();
+            mLocalLastSize = 0;
+         }
+      }
+
+      bEntriesLeft = writeConfigFile( mLocalFileName, false, mergeLocalFile );
+      
+      // Only if we didn't have to merge anything can we use our in-memory state
+      // the next time around. Otherwise the config-file may contain entries
+      // that are different from our in-memory state which means we will have to 
+      // do a merge from then on. 
+      // We do not automatically update the in-memory state with the on-disk 
+      // state when writing the config to disk. We only do so when 
+      // KCOnfig::reparseConfiguration() is called.
+      // For KDE 4.0 we may wish to reconsider that.
+      if (!mergeLocalFile)
+      {
+         QFileInfo info(mLocalFileName);
+         mLocalLastModified = info.lastModified();
+         mLocalLastSize = info.size();
+      }
+      if (lf) lf->unlock();
+    }
+  }
+
+  // only write out entries to the kdeglobals file if there are any
+  // entries marked global (indicated by bEntriesLeft) and
+  // the useKDEGlobals flag is set.
+  if (bEntriesLeft && useKDEGlobals) {
+
+    // can we allow the write? (see above)
+    if (checkAccess ( mGlobalFileName, W_OK )) {
+      KLockFile::Ptr lf = lockFile(true); // Lock file for global file
+      if (lf && lf->isLocked())
+         lf = 0; // Already locked, we don't need to lock/unlock again
+
+      if (lf) 
+      {
+         lf->lock( KLockFile::LockForce );
+         // But what if the locking failed? Ignore it for now...
+      }
+      writeConfigFile( mGlobalFileName, true, bMerge ); // Always merge
+      if (lf) lf->unlock();
+    }
+  }
+
+}
+
+static void writeEntries(FILE *pStream, const KEntryMap& entryMap, bool defaultGroup, bool &firstEntry, const QCString &localeString)
+{
+  // now write out all other groups.
+  QCString currentGroup;
+  for (KEntryMapConstIterator aIt = entryMap.begin();
+       aIt != entryMap.end(); ++aIt)
+  {
+     const KEntryKey &key = aIt.key();
+
+     // Either proces the default group or all others
+     if ((key.mGroup != "<default>") == defaultGroup)
+        continue; // Skip
+
+     // Skip default values and group headers.
+     if ((key.bDefault) || key.mKey.isEmpty())
+        continue; // Skip
+
+     const KEntry &currentEntry = *aIt;
+
+     KEntryMapConstIterator aTestIt = aIt;
+     ++aTestIt;
+     bool hasDefault = (aTestIt != entryMap.end());
+     if (hasDefault)
+     {
+        const KEntryKey &defaultKey = aTestIt.key();
+        if ((!defaultKey.bDefault) ||
+            (defaultKey.mKey != key.mKey) ||
+            (defaultKey.mGroup != key.mGroup) ||
+            (defaultKey.bLocal != key.bLocal))
+           hasDefault = false;
+     }
+
+
+     if (hasDefault)
+     {
+        // Entry had a default value
+        if ((currentEntry.mValue == (*aTestIt).mValue) &&
+            (currentEntry.bDeleted == (*aTestIt).bDeleted))
+           continue; // Same as default, don't write.
+     }
+     else
+     {
+        // Entry had no default value.
+        if (currentEntry.bDeleted)
+           continue; // Don't write deleted entries if there is no default.
+     }
+
+     if (!defaultGroup && (currentGroup != key.mGroup)) {
+	if (!firstEntry)
+	    fprintf(pStream, "\n");
+	currentGroup = key.mGroup;
+	fprintf(pStream, "[%s]\n", encodeGroup(currentGroup).data());
+     }
+
+     firstEntry = false;
+     // it is data for a group
+     fputs(key.mKey.data(), pStream); // Key
+
+     if ( currentEntry.bNLS )
+     {
+        fputc('[', pStream);
+        fputs(localeString.data(), pStream);
+        fputc(']', pStream);
+     }
+
+     if (currentEntry.bDeleted)
+     {
+        fputs("[$d]\n", pStream); // Deleted
+     }
+     else
+     {
+        if (currentEntry.bImmutable || currentEntry.bExpand)
+        {
+           fputc('[', pStream);
+           fputc('$', pStream);
+           if (currentEntry.bImmutable)
+              fputc('i', pStream);
+           if (currentEntry.bExpand)
+              fputc('e', pStream);
+
+           fputc(']', pStream);
+        }
+        fputc('=', pStream);
+        fputs(stringToPrintable(currentEntry.mValue).data(), pStream);
+        fputc('\n', pStream);
+     }
+  } // for loop
+}
+
+bool KConfigINIParser::getEntryMap(KEntryMap &aTempMap, bool bGlobal,
+                                    QFile *mergeFile)
+{
+  bool bEntriesLeft = false;
+  bFileImmutable = false;
+
+  // Read entries from disk
+  if (mergeFile && mergeFile->open(IO_ReadOnly))
+  {
+     // fill the temporary structure with entries from the file
+     parseSingleConfigFile(*mergeFile, &aTempMap, bGlobal, false );
+
+     if (bFileImmutable) // File has become immutable on disk
+        return bEntriesLeft;
+  }
+
+  KEntryMap aMap = pConfig->internalEntryMap();
+
+  // augment this structure with the dirty entries from the config object
+  for (KEntryMapIterator aIt = aMap.begin();
+       aIt != aMap.end(); ++aIt)
+  {
+    const KEntry &currentEntry = *aIt;
+    if(aIt.key().bDefault)
+    {
+       aTempMap.replace(aIt.key(), currentEntry);
+       continue;
+    }
+
+    if (mergeFile && !currentEntry.bDirty)
+       continue;
+
+    // only write back entries that have the same
+    // "globality" as the file
+    if (currentEntry.bGlobal != bGlobal)
+    {
+       // wrong "globality" - might have to be saved later
+       bEntriesLeft = true;
+       continue;
+    }
+
+    // put this entry from the config object into the
+    // temporary map, possibly replacing an existing entry
+    KEntryMapIterator aIt2 = aTempMap.find(aIt.key());
+    if (aIt2 != aTempMap.end() && (*aIt2).bImmutable)
+       continue; // Bail out if the on-disk entry is immutable
+
+    aTempMap.insert(aIt.key(), currentEntry, true);
+  } // loop
+
+  return bEntriesLeft;
+}
+
+/* antlarr: KDE 4.0:  make the first parameter "const QString &" */
+bool KConfigINIParser::writeConfigFile(QString filename, bool bGlobal,
+					bool bMerge)
+{
+  // is the config object read-only?
+  if (pConfig->isReadOnly())
+    return true; // pretend we wrote it
+
+  KEntryMap aTempMap;
+  QFile *mergeFile = (bMerge ? new QFile(filename) : 0);
+  bool bEntriesLeft = getEntryMap(aTempMap, bGlobal, mergeFile);
+  delete mergeFile;
+  if (bFileImmutable)
+    return true; // pretend we wrote it
+
+  // OK now the temporary map should be full of ALL entries.
+  // write it out to disk.
+
+  // Check if file exists:
+  int fileMode = -1;
+  bool createNew = true;
+
+  KDE_struct_stat buf;
+  if (KDE_stat(QFile::encodeName(filename), &buf) == 0)
+  {
+     if (buf.st_uid == getuid())
+     {
+        // Preserve file mode if file exists and is owned by user.
+        fileMode = buf.st_mode & 0777;
+     }
+     else
+     {
+        // File is not owned by user:
+        // Don't create new file but write to existing file instead.
+        createNew = false;
+     }
+  }
+
+  KSaveFile *pConfigFile = 0;
+  FILE *pStream = 0;
+
+  if (createNew)
+  {
+     pConfigFile = new KSaveFile( filename, 0600 );
+
+     if (pConfigFile->status() != 0)
+     {
+        delete pConfigFile;
+        return bEntriesLeft;
+     }
+
+     if (!bGlobal && (fileMode == -1))
+        fileMode = mFileMode;
+
+     if (fileMode != -1)
+     {
+        fchmod(pConfigFile->handle(), fileMode);
+     }
+
+     pStream = pConfigFile->fstream();
+  }
+  else
+  {
+     // Open existing file.
+     // We use open() to ensure that we call without O_CREAT.
+     int fd = KDE_open( QFile::encodeName(filename), O_WRONLY | O_TRUNC );
+     if (fd < 0)
+     {
+        return bEntriesLeft;
+     }
+     pStream = KDE_fdopen( fd, "w");
+     if (!pStream)
+     {
+        close(fd);
+        return bEntriesLeft;
+     }
+  }
+
+  writeEntries(pStream, aTempMap);
+
+  if (pConfigFile)
+  {
+     bool bEmptyFile = (ftell(pStream) == 0);
+     if ( bEmptyFile && ((fileMode == -1) || (fileMode == 0600)) )
+     {
+        // File is empty and doesn't have special permissions: delete it.
+        ::unlink(QFile::encodeName(filename));
+        pConfigFile->abort();
+     }
+     else
+     {
+        // Normal case: Close the file
+        pConfigFile->close();
+     }
+     delete pConfigFile;
+  }
+  else
+  {
+     fclose(pStream);
+  }
+
+  return bEntriesLeft;
+}
+
+void KConfigINIParser::writeEntries(FILE *pStream, const KEntryMap &aTempMap)
+{
+  bool firstEntry = true;
+
+  // Write default group
+  ::writeEntries(pStream, aTempMap, true, firstEntry, localeString);
+
+  // Write all other groups
+  ::writeEntries(pStream, aTempMap, false, firstEntry, localeString);
+}
+
+KLockFile::Ptr KConfigINIParser::lockFile(bool bGlobal)
+{
+	if (bGlobal) {
+		if (mGlobalLockFile)
+			return mGlobalLockFile;
+      
+		if (!mGlobalFileName.isEmpty()) {
+			mGlobalLockFile = new KLockFile(mGlobalFileName+".lock");
+			return mGlobalLockFile;
+		}
+	} else {
+		if (mLocalLockFile)
+			return mLocalLockFile;
+
+		if (!mLocalFileName.isEmpty()) {
+			mLocalLockFile = new KLockFile(mLocalFileName+".lock");
+			return mLocalLockFile;
+		}
+	}
+
+	return 0;
+}
+
+bool KConfigINIParser::checkConfigFilesWritable(bool warnUser)
+{
+  // WARNING: Do NOT use the event loop as it may not exist at this time.
+  bool allWritable = true;
+  QString errorMsg( i18n("Will not save configuration.\n") );
+  if ( !mLocalFileName.isEmpty() && !bFileImmutable && !checkAccess(mLocalFileName,W_OK) )
+  {
+    allWritable = false;
+    errorMsg += i18n("Configuration file \"%1\" not writable.\n").arg(mLocalFileName);
+  }
+  // We do not have an immutability flag for kdeglobals. However, making kdeglobals mutable while making
+  // the local config file immutable is senseless.
+  if ( !mGlobalFileName.isEmpty() && useKDEGlobals && !bFileImmutable && !checkAccess(mGlobalFileName,W_OK) )
+  {
+    errorMsg += i18n("Configuration file \"%1\" not writable.\n").arg(mGlobalFileName);
+    allWritable = false;
+  }
+
+  if (warnUser && !allWritable)
+  {
+    // Note: We don't ask the user if we should not ask this question again because we can't save the answer.
+    errorMsg += i18n("Please contact your system administrator.");
+    QString cmdToExec = KStandardDirs::findExe(QString("kdialog"));
+    KApplication *app = kapp;
+    if (!cmdToExec.isEmpty() && app)
+    {
+      KProcess lprocess;
+      lprocess << cmdToExec << "--title" << app->instanceName() << "--msgbox" << errorMsg.local8Bit();
+      lprocess.start( KProcess::Block );
+    }
+  }
+  return allWritable;
+}	
diff -Naur kdelibs-3.5.2.orig/kdecore/kconfiginiparser.h kdelibs-3.5.2/kdecore/kconfiginiparser.h
--- kdelibs-3.5.2.orig/kdecore/kconfiginiparser.h	1970-01-01 01:00:00.000000000 +0100
+++ kdelibs-3.5.2/kdecore/kconfiginiparser.h	2006-05-21 13:05:24.000000000 +0200
@@ -0,0 +1,53 @@
+/*
+	KConfigINIParser
+	
+	Yannick Lecaillez - <sizon5@gmail.com>
+
+	KConfig configuration parser using INI file.
+	This is a simple restruction of the original KConfigINIBackEnd
+	written by
+
+	Copyright (c) 1999 Preston Brown <pbrown@kde.org>
+	Copyright (c) 1997-1999 Matthias Kalle Dalheimer <kalle@kde.org>
+*/
+
+#ifndef _KCONFIGINIPARSER_H
+#define _KCONFIGINIPARSER_H
+
+#include "kconfigdata.h"
+#include <kconfigbase.h>
+#include "kconfigparser.h"
+#include <klockfile.h>
+#include "kdelibs_export.h"
+
+class QFile;
+
+
+class KDECORE_EXPORT KConfigINIParser : public KConfigParser
+{
+	public:
+		KConfigINIParser(KConfigBase *config, const QString &fileName, const char *resType, bool useKDEGlobals);
+
+		virtual bool parseConfigFiles();
+		virtual void sync(bool bMerge);
+		virtual bool checkConfigFilesWritable(bool warnUser);
+		virtual KLockFile::Ptr lockFile(bool bGlobal);
+	
+	protected:
+		void parseSingleConfigFile(QFile &rFile, KEntryMap *pWriteBackMap,
+					      bool bGlobal, bool bDefault);
+		bool writeConfigFile(QString filename, bool bGlobal = false, bool bMerge = true);
+		bool getEntryMap(KEntryMap &map, bool bGlobal, QFile *mergeFile);
+		void writeEntries(FILE *pStream, const KEntryMap &aTempMap);
+
+	private:
+		QString mLocalFileName;
+		QString mGlobalFileName;
+
+		QDateTime	mLocalLastModified;
+		uint		mLocalLastSize;
+		KLockFile::Ptr	mLocalLockFile;
+		KLockFile::Ptr	mGlobalLockFile;
+};
+
+#endif
diff -Naur kdelibs-3.5.2.orig/kdecore/kconfigparser.cpp kdelibs-3.5.2/kdecore/kconfigparser.cpp
--- kdelibs-3.5.2.orig/kdecore/kconfigparser.cpp	1970-01-01 01:00:00.000000000 +0100
+++ kdelibs-3.5.2/kdecore/kconfigparser.cpp	2006-05-21 13:01:04.000000000 +0200
@@ -0,0 +1,68 @@
+/*
+ *  This file is part of the KDE libraries
+ *  Copyright (c) 2006 Yannick Lecaillez <sizon5@gmail.com>
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public License
+ * along with this library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ *
+ */
+
+#include "kdbconfig.h"
+
+#include <unistd.h>
+#include <ctype.h>
+#ifdef HAVE_SYS_MMAN_H
+#include <sys/mman.h>
+#endif
+#include <sys/types.h>
+#ifdef HAVE_SYS_STAT_H
+#include <sys/stat.h>
+#endif
+#include <fcntl.h>
+#include <signal.h>
+#include <setjmp.h>
+
+#include <qdir.h>
+#include <qfileinfo.h>
+#include <qtextcodec.h>
+#include <qtextstream.h>
+
+#include "kconfigbackend_wrapper.h"
+#include "kconfigparser.h"
+#include "kconfigparserfactory.h"
+#include "kconfigbase.h"
+#include <kapplication.h>
+#include <kglobal.h>
+#include <kprocess.h>
+#include <klocale.h>
+#include <kstandarddirs.h>
+#include <ksavefile.h>
+#include <kurl.h>
+#include <kde_file.h>
+
+KConfigParser::KConfigParser(KConfigBase *_config, 
+				const QString &_fileName,
+				const char *_resType,
+				bool _useKDEGlobals)
+	: pConfig(_config), mfileName(_fileName), resType(_resType), mConfigState(KConfig::NoAccess), mFileMode(-1), useKDEGlobals(_useKDEGlobals) { }
+
+void KConfigParser::setConfigState (KConfigBase::ConfigState state) { mConfigState = state; }
+
+QString KConfigParser::fileName() { return mfileName; }
+const char *KConfigParser::resource() { return resType; }
+void KConfigParser::setFileImmutable(bool immutable) { bFileImmutable = immutable; }
+bool KConfigParser::isFileImmutable() { return bFileImmutable; }
+bool KConfigParser::isUseKDEGlobals() { return useKDEGlobals; }
+void KConfigParser::setLocaleString(const QCString locale) { localeString = locale; }
diff -Naur kdelibs-3.5.2.orig/kdecore/kconfigparserfactory.cpp kdelibs-3.5.2/kdecore/kconfigparserfactory.cpp
--- kdelibs-3.5.2.orig/kdecore/kconfigparserfactory.cpp	1970-01-01 01:00:00.000000000 +0100
+++ kdelibs-3.5.2/kdecore/kconfigparserfactory.cpp	2006-05-21 12:37:54.000000000 +0200
@@ -0,0 +1,38 @@
+/*
+	KConfigParserFactory
+	
+	Yannick Lecaillez - <sizon5@gmail.com>
+
+	Return a newly created parser depending of
+	file to parse and resource type.
+*/
+
+#include "kdbconfig.h"
+
+#include "kconfigparser.h"
+#include "kconfiginiparser.h"
+#include "kconfigelektraparser.h"
+#include "kconfigparserfactory.h"
+#include "kconfigbase.h"
+
+KConfigParser *KConfigParserFactory::create(KConfigBase *_config, const QString &_fileName, const char * _resType, bool _useKDEGlobals)
+{
+	
+	if ( (strcmp(_resType, "elektra-config") == 0) ||
+		(strcmp(_resType, "config") == 0) && (_fileName.isEmpty() || QDir::isRelativePath(_fileName))) {
+		return new KConfigElektraParser(_config, _fileName, "elektra-config", _useKDEGlobals);
+		
+/*	} else if ( (strcmp(_resType, "servicetypes") == 0) && (_fileName.isEmpty() || QDir::isRelativePath(_fileName))) {
+		return new KConfigElektraParser(_config, _fileName, "elektra-servicetypes", _useKDEGlobals);
+		
+	} else if ( (strcmp(_resType, "services") == 0) && (_fileName.isEmpty() || QDir::isRelativePath(_fileName))) {
+		return new KConfigElektraParser(_config, _fileName, "elektra-services", _useKDEGlobals);
+
+	} else if ( (strcmp(_resType, "apps") == 0) && (_fileName.isEmpty() || QDir::isRelativePath(_fileName))) {
+		return new KConfigElektraParser(_config, _fileName, "elektra-apps", _useKDEGlobals); */
+		
+	} else { 
+		return new KConfigINIParser(_config, _fileName, _resType, _useKDEGlobals);
+	}
+}
+
diff -Naur kdelibs-3.5.2.orig/kdecore/kconfigparserfactory.h kdelibs-3.5.2/kdecore/kconfigparserfactory.h
--- kdelibs-3.5.2.orig/kdecore/kconfigparserfactory.h	1970-01-01 01:00:00.000000000 +0100
+++ kdelibs-3.5.2/kdecore/kconfigparserfactory.h	2006-05-21 12:37:57.000000000 +0200
@@ -0,0 +1,52 @@
+/*
+   This file is part of the KDE libraries
+   Copyright (c) 2006 Yannick Lecaillez <sizon5@gmail.com>
+
+   This library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Library General Public
+   License as published by the Free Software Foundation; either
+   version 2 of the License, or (at your option) any later version.
+
+   This library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Library General Public License for more details.
+
+   You should have received a copy of the GNU Library General Public License
+   along with this library; see the file COPYING.LIB.  If not, write to
+   the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+   Boston, MA 02111-1307, USA.
+*/
+
+#ifndef _KCONFIGPARSERFACTORY_H
+#define _KCONFIGPARSERFACTORY_H
+
+#include "kconfigparser.h"
+#include "kconfigelektraparser.h"
+#include "kconfiginiparser.h"
+#include "kconfigparserfactory.h"
+#include "kconfigbase.h"
+
+/**
+ * Determinate and create KConfigParser object responsible
+ * of configuration loading/saving for the specified
+ * filename and resource type.
+ *
+ * @author Yannick Lecaillez - <sizon5@gmail.com>
+ *
+ * @short Configuration file parser selector
+ */
+class KDECORE_EXPORT KConfigParserFactory {
+	public:
+
+		/**
+		 * Create a new KConfigParser associated to a specific
+		 * filename/resource type couple
+		 *
+		 * @returns A newly allocated KConfigParser
+		 * @see KConfigParser
+		 */
+		static KConfigParser *KConfigParserFactory::create(KConfigBase *_config, const QString &_fileName, const char * _resType, bool _useKDEGlobals);
+};
+
+#endif
diff -Naur kdelibs-3.5.2.orig/kdecore/kconfigparser.h kdelibs-3.5.2/kdecore/kconfigparser.h
--- kdelibs-3.5.2.orig/kdecore/kconfigparser.h	1970-01-01 01:00:00.000000000 +0100
+++ kdelibs-3.5.2/kdecore/kconfigparser.h	2006-05-21 12:37:57.000000000 +0200
@@ -0,0 +1,155 @@
+/*
+ *  This file is part of the KDE libraries
+ *  Copyright (c) 2006 Yannick Lecaillez <sizon5@gmail.com>
+ *
+ *  This library is free software; you can redistribute it and/or
+ *  modify it under the terms of the GNU Library General Public
+ *  License as published by the Free Software Foundation; either
+ *  version 2 of the License, or (at your option) any later version.
+ *
+ *  This library is distributed in the hope that it will be useful,
+ *  but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ *  Library General Public License for more details.
+ *
+ * You should have received a copy of the GNU Library General Public License
+ * along with this library; see the file COPYING.LIB.  If not, write to
+ * the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
+ * Boston, MA 02111-1307, USA.
+ *
+ */
+
+#ifndef _KCONFIGPARSER_H
+#define _KCONFIGPARSER_H
+
+#include "kconfig.h"
+#include "kconfigdata.h"
+#include <kconfigbase.h>
+#include <klockfile.h>
+#include "kdelibs_export.h"
+
+/**
+ * Abstract base class for KDE configuration file loading/saving.
+ *
+ * This class forms the base for all classes that implement some
+ * manner of loading/saving to configuration files.  It is an
+ * abstract base class, meaning that you cannot directly instantiate
+ * objects of this class. 
+ *
+ * This class is heavily insprired from "old" KConfigBackEnd originaly
+ * written  by Preston Brown <pbrown@kde.org> and Matthias Kalle Dalheimer
+ * <kalle@kde.org>. Main change is now Parser are allowed to define
+ * their own method for locking, configuration writable check.
+ * Configuration resource/filename can't be changed during object life
+ * (see kconfigparserfactory), this allow to usage of specific parser depending
+ * of resource and/or filename. These change was made for elektra backend
+ * but could be usefull for other KConfig Backend which doesn't rely on 
+ * file.
+ *
+ * @author Yannick Lecaillez <sizon5@gmail.com>
+ *
+ * @short KDE Configuration file loading/saving abstract base class
+ *
+ * @see KConfigParserFactory
+ */
+class KDECORE_EXPORT KConfigParser {
+	public:
+		/**
+		 * Constructs a configuration back end.
+		 *
+		 * @param _config Specifies the configuration object which values
+		 *        will be passed to as they are read, or from where values
+		 *        to be written to will be obtained from.
+		 * @param _fileName The name of the file in which config
+		 *        data is stored.  All registered configuration directories
+		 *        will be looked in in order of decreasing relevance.
+		 * @param _resType the resource type of the fileName specified, _if_
+		 *        it is not an absolute path (otherwise this parameter is ignored).
+		 * @param _useKDEGlobals If true, the user's system-wide kdeglobals file
+		 *        will be imported into the config object.  If false, only
+		 *        the filename specified will be dealt with.
+		 */
+		KConfigParser(KConfigBase *_config, 
+				const QString &_fileName,
+				const char *_resType,
+				bool _useKDEGlobals);
+
+		/**
+		 * Set the locale string that defines the current language.
+		 * @param _localeString the identifier of the language
+		 * @see KLocale
+		 */
+		void setLocateString(const QCString &_localeString) { localeString = _localeString; }
+		
+		/**
+		 * Returns the state of the app-config object.
+		 *
+		 * @see KConfig::getConfigState
+		 */
+		KConfigBase::ConfigState getConfigState() const
+		 { return mConfigState; }
+		void setConfigState (KConfigBase::ConfigState state);
+
+		/**
+		 * Return fileName as passed to the constructor
+		 */
+		QString fileName();
+
+		/**
+		 * Returns the resource type as passed to the constructor.
+		 * @return the resource type as passed to the constructor.
+		 */
+		const char *resource();
+		void setFileImmutable(bool immutable);
+		bool isFileImmutable();
+
+		bool isUseKDEGlobals();
+		
+		void setLocaleString(const QCString locale);
+
+		/**
+		 * Parses all configuration files for a configuration object.  This
+		 * method must be reimplemented by the derived classes.
+		 *
+		 * @returns Whether or not parsing was successful.
+		 */
+		virtual bool parseConfigFiles() = 0;
+
+		/**
+		 * Writes configuration data to file(s).  This method must be
+		 * reimplemented by the derived classes.
+		 *
+		 * @param bMerge Specifies whether the old config file already
+		 * on disk should be merged in with the data in memory. If true,
+		 * data is read off the disk and merged. If false, the on-disk
+		 * file is removed and only in-memory data is written out.
+		 */
+		virtual void sync(bool bMerge) = 0;
+
+		/**
+		 * Returns a lock file object for the configuration file
+		 * @param bGlobal If true, returns a lock file object for kdeglobals
+		 * @since 3.3
+		 */
+		virtual KLockFile::Ptr lockFile(bool bGlobal) = 0;
+
+		/**
+		 * Check whether the config files are writable.
+		 * @param warnUser Warn the user if the configuration files are not writable.
+		 * @return Indicates that all of the configuration files used are writable.
+		 * @since 3.2
+		 */
+		virtual bool checkConfigFilesWritable(bool warnUser) = 0;
+
+	protected:
+		KConfigBase *pConfig;
+		QCString localeString;
+		QString mfileName;
+		QCString resType;
+		KConfigBase::ConfigState mConfigState;
+		int mFileMode;
+		bool useKDEGlobals : 1;
+		bool bFileImmutable : 1;
+};
+
+#endif
diff -Naur kdelibs-3.5.2.orig/kdecore/kdesktopfile.cpp kdelibs-3.5.2/kdecore/kdesktopfile.cpp
--- kdelibs-3.5.2.orig/kdecore/kdesktopfile.cpp	2005-10-10 17:06:03.000000000 +0200
+++ kdelibs-3.5.2/kdecore/kdesktopfile.cpp	2006-05-21 13:00:45.000000000 +0200
@@ -30,7 +30,7 @@
 
 #include <kdebug.h>
 #include "kurl.h"
-#include "kconfigbackend.h"
+#include "kconfigbackend_wrapper.h"
 #include "kapplication.h"
 #include "kstandarddirs.h"
 #include "kmountpoint.h"
diff -Naur kdelibs-3.5.2.orig/kdecore/ksimpleconfig.cpp kdelibs-3.5.2/kdecore/ksimpleconfig.cpp
--- kdelibs-3.5.2.orig/kdecore/ksimpleconfig.cpp	2005-10-10 17:06:02.000000000 +0200
+++ kdelibs-3.5.2/kdecore/ksimpleconfig.cpp	2006-05-21 15:31:15.000000000 +0200
@@ -33,7 +33,7 @@
 
 #include "kglobal.h"
 #include "kstandarddirs.h"
-#include "kconfigbackend.h"
+#include "kconfigbackend_wrapper.h"
 
 #include "ksimpleconfig.h"
 
@@ -44,7 +44,7 @@
   // for KSimpleConfig an absolute filename is guaranteed
   if (!fileName.isNull() && QDir::isRelativePath(fileName)) {
      backEnd->changeFileName( KGlobal::dirs()->
-	saveLocation("config", QString::null, !bReadOnly)+fileName, "config", false);
+	saveLocation("elektra-config", QString::null, !bReadOnly)+fileName, "elektra-config", false);
   } else {
      backEnd->changeFileName(fileName, "config", false);
   }
diff -Naur kdelibs-3.5.2.orig/kdecore/kstandarddirs.cpp kdelibs-3.5.2/kdecore/kstandarddirs.cpp
--- kdelibs-3.5.2.orig/kdecore/kstandarddirs.cpp	2005-10-10 17:06:02.000000000 +0200
+++ kdelibs-3.5.2/kdecore/kstandarddirs.cpp	2006-05-21 12:59:18.000000000 +0200
@@ -16,6 +16,8 @@
    along with this library; see the file COPYING.LIB.  If not, write to
    the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
    Boston, MA 02110-1301, USA.
+
+   Elektra patch by Yannick Lecaillez <sizon5@gmail.com>
 */
 
 /*
@@ -56,6 +58,9 @@
 #include "kstaticdeleter.h"
 #include <kde_file.h>
 
+#include "elektra.h"
+#include <kdb.h>
+
 template class QDict<QStringList>;
 
 class KStandardDirs::KStandardDirsPrivate
@@ -73,6 +78,8 @@
    QAsciiDict<bool> restrictions;
    QStringList xdgdata_prefixes;
    QStringList xdgconf_prefixes;
+
+   QStringList elektra_prefixes;
 };
 
 // Singleton, with data shared by all kstandarddirs instances.
@@ -97,6 +104,7 @@
 static const char* const types[] = {"html", "icon", "apps", "sound",
 			      "data", "locale", "services", "mime",
 			      "servicetypes", "config", "exe",
+			      "elektra-config",
 			      "wallpaper", "lib", "pixmap", "templates",
 			      "module", "qtplugins",
 			      "xdgdata-apps", "xdgdata-dirs", "xdgconf-menu",
@@ -237,6 +245,26 @@
     }
 }
 
+void KStandardDirs::addElektraPrefix(const QString& _dir)
+{
+	addElektraPrefix(_dir, false);
+}
+
+void KStandardDirs::addElektraPrefix(const QString& _dir, bool priority)
+{
+	if (_dir.isEmpty())
+		return;
+
+	QString dir = _dir;
+	if (dir.at(dir.length() - 1) != '/')
+		dir += '/';
+
+	if (!d->elektra_prefixes.contains(dir)) {
+		priorityAdd(d->elektra_prefixes, dir, priority);
+		dircache.clear();
+	}
+}
+
 QString KStandardDirs::kfsstnd_prefixes()
 {
    return prefixes.join(QChar(KPATH_SEPARATOR));
@@ -539,6 +567,150 @@
   }
 }
 
+static void lookupKeyDirectory(const QString& path, const QString &relPart,
+			    const QRegExp &regexp,
+			    QStringList& list,
+			    QStringList& relList,
+			    bool recursive, bool unique)
+{
+  QString pattern = regexp.pattern();
+  KDB handle;
+  KeySet *ks;
+  Key *cur;
+
+  if (recursive || pattern.contains('?') || pattern.contains('*'))
+  {
+    if (path.isEmpty()) //for sanity
+      return;
+    // We look for a set of files.
+    ks = ksNew();
+    kdbOpen(&handle);
+    if ( kdbGetChildKeys(handle, path.latin1(), ks, KDB_O_STATONLY | KDB_O_INACTIVE | KDB_O_DIR ) ) {
+	kdbClose(&handle);
+	ksDel(ks);
+	return;
+    }
+
+	
+    ksRewind(ks);
+    while( ( cur = ksNext(ks) ) != 0L ) {
+      QString fn(keyStealBaseName(cur));
+
+      if (!recursive && !regexp.exactMatch(fn))
+	continue; // No match
+
+      QString pathfn = path + fn;
+      if ( recursive ) {
+	if ( keyIsDir(cur) ) {
+	  lookupKeyDirectory(pathfn + '/', relPart + fn + '/', regexp, list, relList, recursive, unique);
+	}
+        if (!regexp.exactMatch(fn))
+	  continue; // No match
+      }
+      if ( keyIsString(cur) || keyIsBin(cur) )
+      {
+        if (!unique || !relList.contains(relPart + fn))
+        {
+	    list.append( pathfn );
+	    relList.append( relPart + fn );
+        }
+      }
+    }
+    ksDel(ks);
+    kdbClose(&handle);
+
+  } else {
+     // We look for a single file.
+     QString fn = pattern;
+     QString pathfn = path + fn;
+
+     cur = keyNew(pathfn.latin1(), KEY_SWITCH_END);
+     kdbOpen(&handle);
+     if ( kdbStatKey(handle, cur) ) {
+	// Key not found
+	kdbClose(&handle);
+	keyDel(cur);
+	return;
+     }
+
+     if ( keyIsDir(cur) || keyIsBin(cur) ) {
+       if (!unique || !relList.contains(relPart + fn))
+       {
+         list.append( pathfn );
+         relList.append( relPart + fn );
+       }
+     }
+  }
+}
+
+static void lookupKeyPrefix(const QString& prefix, const QString& relpath,
+                         const QString& relPart,
+			 const QRegExp &regexp,
+			 QStringList& list,
+			 QStringList& relList,
+			 bool recursive, bool unique)
+{
+
+    if (relpath.isEmpty()) {
+       lookupKeyDirectory(prefix, relPart, regexp, list,
+		       relList, recursive, unique);
+       return;
+    }
+    QString path;
+    QString rest;
+
+    if (relpath.length())
+    {
+       int slash = relpath.find('/');
+       if (slash < 0)
+	   rest = relpath.left(relpath.length() - 1);
+       else {
+	   path = relpath.left(slash);
+	   rest = relpath.mid(slash + 1);
+       }
+    }
+
+    if (prefix.isEmpty()) //for sanity
+      return;
+
+    if (path.contains('*') || path.contains('?')) {
+	KDB handle;
+	KeySet	*ks;
+	Key *cur;
+
+	QRegExp pathExp(path, true, true);
+	
+	ks = ksNew();
+	kdbOpen(&handle);
+	if ( kdbGetChildKeys(handle, prefix.latin1(), ks, KDB_O_STATONLY | KDB_O_INACTIVE | KDB_O_DIR) ) {
+		kdbClose(&handle);
+		ksDel(ks);
+		return;
+	}
+	ksRewind(ks);
+	while( (cur = ksNext(ks) ) != 0L )
+	    {
+		QString fn(keyStealBaseName(cur));
+
+		if ( !pathExp.exactMatch(fn) )
+		    continue; // No match
+		QString rfn = relPart+fn;
+		fn = prefix + fn;
+		if ( keyIsDir(cur) )
+		    lookupKeyPrefix(fn + '/', rest, rfn + '/', regexp, list, relList, recursive, unique);
+	    }
+
+	kdbClose(&handle);
+	ksDel(ks);
+    } else {
+        // Don't stat, if the dir doesn't exist we will find out
+        // when we try to open it.
+        lookupKeyPrefix(prefix + path + '/', rest,
+                     relPart + path + '/', regexp, list,
+                     relList, recursive, unique);
+    }
+}
+
 static void lookupPrefix(const QString& prefix, const QString& relpath,
                          const QString& relPart,
 			 const QRegExp &regexp,
@@ -661,6 +833,16 @@
 
     QRegExp regExp(filterFile, true, true);
 
+    if ( strncmp(type, "elektra-", 8) == 0 ) {
+	for (QStringList::ConstIterator it = candidates.begin();
+        	 it != candidates.end(); it++)
+    	{
+        	lookupKeyPrefix(*it, filterPath, "", regExp, list,
+                	     relList, recursive, unique);
+    	}
+	
+    } else {
+
     for (QStringList::ConstIterator it = candidates.begin();
          it != candidates.end(); ++it)
     {
@@ -668,6 +850,8 @@
                      relList, recursive, unique);
     }
 
+    }
+
     return list;
 }
 
@@ -817,9 +1001,38 @@
                 prefixList = &(d->xdgdata_prefixes);
             else if (strncmp(type, "xdgconf-", 8) == 0)
                 prefixList = &(d->xdgconf_prefixes);
+            else if (strncmp(type, "elektra-", 8) == 0)
+                prefixList = &(d->elektra_prefixes);
             else
                 prefixList = &prefixes;
 
+            if ( strncmp(type, "elektra-", 8) == 0 ) {
+		KDB handle;
+		Key *key;
+		int rc;
+		kdbOpen(&handle);
+
+		for (QStringList::ConstIterator pit = prefixList->begin();
+                	 pit != prefixList->end(); pit++) {
+                	for (QStringList::ConstIterator it = dirs->begin(); it != dirs->end(); ++it) {
+                    		QString path = (*pit) + (*it);
+
+                    		if (local && restrictionActive)
+                    	   		continue;
+
+				key = keyNew(path.latin1(), KEY_SWITCH_END);
+				rc = kdbStatKey(handle, key);
+				if ((local || rc == 0) && !candidates->contains(path))
+                        		candidates->append(path);
+				keyDel(key);
+                	}
+                	local = false;
+		}
+
+		kdbClose(&handle);
+		
+ 	    } else {
+
             for (QStringList::ConstIterator pit = prefixList->begin();
                  pit != prefixList->end();
                  ++pit)
@@ -835,9 +1048,31 @@
                 }
                 local = false;
             }
+
+            }
         }
         dirs = absolutes.find(type);
         if (dirs)
+            if ( strncmp(type, "elektra-", 8) == 0 ) {
+		KDB handle;
+		Key *key;
+		kdbOpen(&handle);		
+
+		for (QStringList::ConstIterator it = dirs->begin();
+                	 it != dirs->end(); ++it)
+            	{
+			key = keyNew((*it).latin1(), KEY_SWITCH_END);
+			if ( kdbStatKey(handle, key) == 0 ) {
+                    		if (!candidates->contains(*it))
+                        		candidates->append(*it);
+                	}
+			keyDel(key);
+	        }
+
+		kdbClose(&handle);
+
+	    } else {
+
             for (QStringList::ConstIterator it = dirs->begin();
                  it != dirs->end(); ++it)
             {
@@ -849,6 +1084,8 @@
                         candidates->append(filename);
                 }
             }
+ 
+            }
         dircache.insert(type, candidates);
     }
 
@@ -1025,6 +1262,8 @@
 	return "share/icons/";
     if (!strcmp(type, "config"))
 	return "share/config/";
+    if (!strcmp(type, "elektra-config"))
+	return "kde/current/config/";
     if (!strcmp(type, "pixmap"))
 	return "share/pixmaps/";
     if (!strcmp(type, "apps"))
@@ -1094,6 +1333,8 @@
              pPath = new QString(realPath(localxdgdatadir() + dirs->last()));
           else if (strncmp(type, "xdgconf-", 8) == 0)
              pPath = new QString(realPath(localxdgconfdir() + dirs->last()));
+          else if ( strncmp(type, "elektra-", 8) == 0 )
+             pPath = new QString(localelektrakey() + dirs->last());
           else
              pPath = new QString(realPath(localkdedir() + dirs->last()));
        }
@@ -1107,6 +1348,37 @@
        savelocations.insert(type, pPath);
     }
     QString fullPath = *pPath + (pPath->endsWith("/") ? "" : "/") + suffix;
+    if ( strncmp(type, "elektra-", 8) == 0 ) {
+        KDB handle;
+	int rc;
+	Key *key;
+
+	key = keyNew(fullPath.latin1(), KEY_SWITCH_END);
+
+	kdbOpen(&handle);
+	rc = kdbStatKey(handle, key);
+	if ( rc || !keyIsDir(key) ) {
+	    if (!create) {
+#ifndef NDEBUG
+		    kdDebug() << QString("save location %s doesn't exist").arg(fullPath) << endl;
+#endif
+		    keyDel(key);
+		    kdbClose(&handle);
+		    return fullPath;
+	    }
+	    keySetType(key, KEY_TYPE_DIR);
+	    keySetAccess(key, 0700);
+	    if ( kdbSetKey(handle, key) ) {
+		    keyDel(key);
+		    kdbClose(&handle);
+		    return fullPath;
+	    }
+	    dircache.remove(type);
+	}
+	keyDel(key);   
+	kdbClose(&handle);	
+		   
+    } else {
 
     KDE_struct_stat st;
     if (KDE_stat(QFile::encodeName(fullPath), &st) != 0 || !(S_ISDIR(st.st_mode))) {
@@ -1121,6 +1393,8 @@
 	}
         dircache.remove(type);
     }
+
+    }
     if (!fullPath.endsWith("/"))
 	    fullPath += "/";
     return fullPath;
@@ -1411,6 +1685,32 @@
     }
     // end XDG_DATA_XXX
 
+    // begin KDEKEYS (elektra support)
+    QStringList kdekeyList;
+    QString kdekeys = readEnvPath("KDEKEYS");
+    if (!kdekeys.isEmpty()) {
+	tokenize(kdekeyList, kdekeys, QChar(KPATH_SEPARATOR));
+    }
+    kdekeyList.append(ELEKTRA_ROOT_PATH);
+	
+    // We treat root differently to prevent a "su" shell messing up the
+    // file permissions in the user's home directory.
+    QString localElektraDir = readEnvPath(getuid() ? "KDEKEYHOME" : "KDEKEYROOTHOME");
+    if (!localElektraDir.isEmpty()) {
+	// TODO: add escaping support !
+	if (localElektraDir[localElektraDir.length()-1] != '/') {
+		localElektraDir += '/';
+	}
+    } else {
+	localElektraDir = ELEKTRA_USER_PATH;
+    }
+    addElektraPrefix(localElektraDir);
+    
+    for (QStringList::ConstIterator it = kdekeyList.begin(); it != kdekeyList.end(); it++) {
+        QString dir = *it;
+	addElektraPrefix(dir);	
+    }
+    // end KDEKEYS (elektra support)
 
     uint index = 0;
     while (types[index] != 0) {
@@ -1504,6 +1804,7 @@
     // save the numbers of config directories. If this changes,
     // we will return true to give KConfig a chance to reparse
     uint configdirs = resourceDirs("config").count();
+    uint elektrakeys = resourceDirs("elektra-config").count();
 
     // Remember original group
     QString oldGroup = config->group();
@@ -1573,9 +1874,33 @@
                 addXdgDataPrefix(dir+"/share", priority);
             }
 
+            list =  config->readListEntry("key_prefixes");
+            for (QStringList::ConstIterator it = list.begin(); it != list.end(); it++) {
+                addElektraPrefix(*it, priority);
+            }
+
+            // Get entry for additional elektra key directories
+            QMap<QString, QString> entries = config->entryMap(group);
+	    for (QMap<QString, QString>::ConstIterator it2 = entries.begin();
+			    it2 != entries.end(); it2++)
+	    {
+		    QString key = it2.key();
+		    if (key.startsWith("key_")) {
+			    // generate directory list, there may be more than 1.
+			    
+			    QStringList dirs = QStringList::split(',', *it2);
+			    QStringList::Iterator sIt(dirs.begin());
+
+			    QString resType = key.mid(4, key.length());
+			    for (; sIt != dirs.end(); ++sIt) {
+				    addResourceDir(resType.latin1(), *sIt, priority);
+			    }
+		    }
+	    }
+
             // iterating over all entries in the group Directories
             // to find entries that start with dir_$type
-            QMap<QString, QString> entries = config->entryMap(group);
+            entries = config->entryMap(group);
             for (QMap<QString, QString>::ConstIterator it2 = entries.begin();
                  it2 != entries.end(); it2++)
             {
@@ -1621,7 +1946,7 @@
     config->setGroup(oldGroup);
 
     // check if the number of config dirs changed
-    bool configDirsChanged = (resourceDirs("config").count() != configdirs);
+    bool configDirsChanged = ( (resourceDirs("config").count() != configdirs) || resourceDirs("elektra-config").count() != elektrakeys);
     // If the config dirs changed, we check kiosk restrictions again.
     d->checkRestrictions = configDirsChanged;
     // return true if the number of config dirs changed: reparse config file
@@ -1646,6 +1971,10 @@
     return d->xdgconf_prefixes.first();
 }
 
+QString KStandardDirs::localelektrakey() const
+{
+    return d->elektra_prefixes.first();
+}
 
 // just to make code more readable without macros
 QString locate( const char *type,
diff -Naur kdelibs-3.5.2.orig/kdecore/kstandarddirs.h kdelibs-3.5.2/kdecore/kstandarddirs.h
--- kdelibs-3.5.2.orig/kdecore/kstandarddirs.h	2005-10-10 17:06:03.000000000 +0200
+++ kdelibs-3.5.2/kdecore/kstandarddirs.h	2006-05-21 12:56:34.000000000 +0200
@@ -18,6 +18,8 @@
   along with this library; see the file COPYING.LIB.  If not, write to
   the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
   Boston, MA 02110-1301, USA.
+
+  Elektra patch by Yannick Lecaillez <sizon5@gmail.com>
 */
 
 #ifndef SSK_KSTDDIRS_H
@@ -165,6 +167,15 @@
 	void addXdgDataPrefix( const QString& dir );
 
 	/**
+	 * Adds another search key to front of the KDE_ELEKTRA_XXX list
+	 * of prefixes.
+	 * This prefix is only used for resource "elektra-config"
+	 *
+	 * @param key The key name to append relative paths to.
+	 */
+	void addElektraPrefix(const QString& key);
+	
+	/**
 	 * Adds suffixes for types.
 	 *
 	 * You may add as many as you need, but it is advised that there
@@ -509,6 +520,7 @@
 	 * @li html - share/doc/HTML
 	 * @li icon - share/icon
 	 * @li config - share/config
+	 * @li elektra-config - kde/current/config
 	 * @li pixmap - share/pixmaps
 	 * @li apps - share/applnk
 	 * @li sound - share/sounds
@@ -577,6 +589,12 @@
 	QString localxdgconfdir() const;
 
 	/**
+	 * @return $KDEKEYS
+	 * See also http://www.freedesktop.org/standards/basedir/draft/basedir-spec/basedir-spec.html
+	 */
+	QString localelektrakey() const;
+	
+	/**
 	 * Checks for existence and accessability of a file or directory.
 	 * Faster than creating a QFileInfo first.
 	 * @param fullPath the path to check. IMPORTANT: must end with a slash if expected to be a directory
@@ -635,6 +653,7 @@
 	void addPrefix( const QString& dir, bool priority );
 	void addXdgConfigPrefix( const QString& dir, bool priority );
 	void addXdgDataPrefix( const QString& dir, bool priority );
+	void addElektraPrefix( const QString& dir, bool priority);
 
 	// If priority is true, the directory is added before any other,
 	// otherwise after
diff -Naur kdelibs-3.5.2.orig/kdecore/Makefile.am kdelibs-3.5.2/kdecore/Makefile.am
--- kdelibs-3.5.2.orig/kdecore/Makefile.am	2005-10-10 17:06:02.000000000 +0200
+++ kdelibs-3.5.2/kdecore/Makefile.am	2006-05-21 15:30:10.000000000 +0200
@@ -39,7 +39,8 @@
 include_HEADERS = kconfig.h kconfigskeleton.h \
 	kconfigdata.h ksimpleconfig.h kconfigdialogmanager.h \
 	kconfigbase.h kdesktopfile.h kurl.h ksock.h kaboutdata.h \
-	kcmdlineargs.h kconfigbackend.h kapp.h kapplication.h kuniqueapp.h \
+	kcmdlineargs.h kconfigbackend_wrapper.h kapp.h kapplication.h kuniqueapp.h \
+	kconfigparser.h kconfigparserfactory.h kconfiginiparser.h kconfigelektraparser.h elektra.h \
 	kuniqueapplication.h kcharsets.h kdeversion.h kpty.h kprocess.h \
 	kprocctrl.h klocale.h kicontheme.h kiconloader.h kdebug.h \
 	kwinmodule.h kwin.h krootprop.h kshortcut.h kkeynative.h kaccel.h \
@@ -85,7 +86,8 @@
 
 libkdecore_la_SOURCES = libintl.cpp kapplication.cpp \
 	kdebug.cpp netwm.cpp kconfigbase.cpp kconfig.cpp  ksimpleconfig.cpp \
-	kconfigbackend.cpp kmanagerselection.cpp kdesktopfile.cpp \
+	kconfigbackend_wrapper.cpp kmanagerselection.cpp kdesktopfile.cpp \
+	kconfigparser.cpp kconfigparserfactory.cpp kconfigelektraparser.cpp kconfiginiparser.cpp \
 	kstandarddirs.cpp ksock.cpp kpty.cpp kprocess.cpp kprocctrl.cpp \
 	klocale.cpp krfcdate.cpp kiconeffect.cpp kicontheme.cpp \
 	kiconloader.cpp kwin.cpp kwinmodule.cpp krootprop.cpp kcharsets.cpp \
@@ -116,7 +118,7 @@
 	kqiodevicegzip_p.cpp ktimezones.cpp
 
 libkdecore_la_LDFLAGS = $(QT_LDFLAGS) $(KDE_RPATH) $(KDE_MT_LDFLAGS) $(X_LDFLAGS) $(USER_LDFLAGS) -version-info 6:0:2 -no-undefined
-libkdecore_la_LIBADD = malloc/libklmalloc.la network/libkdecorenetwork.la $(SVGICON_LIB) ../dcop/libDCOP.la ../libltdl/libltdlc.la $(LIB_XEXT) $(LIBRESOLV) $(LIBUTIL) $(LIBART_LIBS) $(LIB_IDN) ../kdefx/libkdefx.la
+libkdecore_la_LIBADD = malloc/libklmalloc.la network/libkdecorenetwork.la $(SVGICON_LIB) ../dcop/libDCOP.la ../libltdl/libltdlc.la $(LIB_XEXT) $(LIBRESOLV) $(LIBUTIL) $(LIBART_LIBS) $(LIB_IDN) ../kdefx/libkdefx.la -lelektra
 libkdecore_la_NMCHECK = $(srcdir)/libkdecore.nmcheck
 libkdecore_la_NMCHECKWEAK = $(srcdir)/libkdecore_weak.nmcheck $(srcdir)/libqt-mt_weak.nmcheck \
 	$(top_srcdir)/dcop/libDCOP_weak.nmcheck $(top_srcdir)/kdecore/standard_weak.nmcheck
