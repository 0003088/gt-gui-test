*** fstab.old.c	2004-11-04 20:25:17.000000000 +0100
--- fstab.c	2004-12-26 15:39:51.959211480 +0100
***************
*** 7,14 ****
--- 7,16 ----
  #include <unistd.h>
  #include <errno.h>
  #include <stdio.h>
+ #include <ctype.h>
  #include <string.h>
  #include <sys/stat.h>
+ #include <kdb.h>
  #include "mntent.h"
  #include "fstab.h"
  #include "sundries.h"		/* for xmalloc() etc */
***************
*** 16,21 ****
--- 18,25 ----
  #include "paths.h"
  #include "nls.h"
  
+ #define KDB_FSTAB   "system/filesystems"
+ 
  #define streq(s, t)	(strcmp ((s), (t)) == 0)
  
  #define PROC_MOUNTS		"/proc/mounts"
***************
*** 172,195 ****
  	read_mntentchn(mfp, fnam, mc);
  }
  
  static void
  read_fstab() {
- 	mntFILE *mfp = NULL;
- 	const char *fnam;
- 	struct mntentchn *mc = &fstab;
  
  	got_fstab = 1;
  	mc->nxt = mc->prev = NULL;
  
! 	fnam = _PATH_FSTAB;
! 	mfp = my_setmntent (fnam, "r");
! 	if (mfp == NULL || mfp->mntent_fp == NULL) {
! 		int errsv = errno;
! 		error(_("warning: can't open %s: %s"),
! 		      _PATH_FSTAB, strerror (errsv));
! 		return;
! 	}
! 	read_mntentchn(mfp, fnam, mc);
  }
       
  
--- 176,269 ----
  	read_mntentchn(mfp, fnam, mc);
  }
  
+ /*
+ 	Changed by Rémi Flament : added elektra support (26/12/2004)
+ 	if keys don't exist it fallbacks to the old method and says it on the screen 
+ */
  static void
  read_fstab() {
  
+ 	KeySet *entries=ksNew();
+ 	Key *current;
+ 	int rc;
+ 	struct mntentchn *mc0 = &fstab;
+ 	struct mntentchn *mc = mc0;
+ 	
  	got_fstab = 1;
  	mc->nxt = mc->prev = NULL;
+ 	
+ 	kdbOpen();
+ 	rc=kdbGetChildKeys(KDB_FSTAB, entries, KDB_O_SORT|KDB_O_DIR);
+ 	if (rc==0)
+ 		{
+ 		ksRewind(entries);
+ 		while ((current=ksNext(entries))) 
+ 			{
+ 			char keyName[300];
+ 			char buf[3];
+ 			char *device;
+ 			char *mpoint;
+ 			char *type;
+ 			char *opts;
+ 			struct my_mntent mnt;
+ 			
+ 			mnt.mnt_freq=0;
+ 			mnt.mnt_passno=0;
+ 			keyGetFullName(current,keyName,sizeof(keyName));
+ 			
+ 			// size of buffers are choosen arbitrary, I guess that should be changed...
+ 			device=xmalloc(300);
+ 			mpoint=xmalloc(300);
+ 			type=xmalloc(100);
+ 			opts=xmalloc(200);
+ 			
+ 			kdbGetValueByParent(keyName,"device",device,300);
+ 			kdbGetValueByParent(keyName,"mpoint",mpoint,300);
+ 			kdbGetValueByParent(keyName,"type",type,100);
+ 			kdbGetValueByParent(keyName,"options",opts,200);
+ 			
+ 			mnt.mnt_fsname=device;
+ 			mnt.mnt_dir=mpoint;
+ 			mnt.mnt_type=type;
+ 			mnt.mnt_opts=opts;
+ 			
+ 			kdbGetValueByParent(keyName,"passno",buf,3);
+ 			if (isdigit(buf[0])) mnt.mnt_passno=atoi(buf);
+ 			
+ 			kdbGetValueByParent(keyName,"dumpfreq",buf,3);
+ 			if (isdigit(buf[0])) mnt.mnt_freq=atoi(buf);
+ 			
+ 			
+ 			if (!streq(mnt.mnt_type, MNTTYPE_IGNORE)) {
+ 				mc->nxt = (struct mntentchn *) xmalloc(sizeof(*mc));
+ 				mc->nxt->prev = mc;
+ 				mc = mc->nxt;
+ 				mc->m = mnt;
+ 				mc->nxt = mc0;
+ 			}
+ 			
+ 			
+ 			}
+ 		mc0->prev = mc;
+ 		}
+ 	else
+ 		{
+ 		printf("\nElektra keys haven't been found ! Falling back to the old method...\n\n");
+ 		mntFILE *mfp = NULL;
+ 		const char *fnam;
  
! 		fnam = _PATH_FSTAB;
! 		mfp = my_setmntent (fnam, "r");
! 		if (mfp == NULL || mfp->mntent_fp == NULL) {
! 			int errsv = errno;
! 			error(_("warning: can't open %s: %s"),
! 			_PATH_FSTAB, strerror (errsv));
! 			return;
! 		}
! 		read_mntentchn(mfp, fnam, mc);
! 		}
! 	ksDel(entries);
! 	kdbClose();
  }
       
  
