

<HTML><HEAD><TITLE>Manpage of KeyDB :: Class Methods</TITLE>
</HEAD><BODY>
<H1>KeyDB :: Class Methods</H1>
Section: C Library Functions (3)<BR>Updated: 25 Jul 2005<BR><A HREF="#index">Index</A>
<A HREF="index.html">Return to Main Contents</A><HR>



<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

KeyDB :: Class Methods - General methods to access the Key database.  
<P>
<P>

<A NAME="lbAC">&nbsp;</A>
<H3>Enumerations</H3>

<P>

<BR>

enum <B>KDBErr</B> { <B>KDB_RET_OK</B> = 0, <B>KDB_RET_NULLKEY</B> = EINVAL, <B>KDB_RET_UNINITIALIZED</B> = EINVAL, <B>KDB_RET_NOTFOUND</B> = ENOENT, <B>KDB_RET_INVALIDKEY</B> = EAFNOSUPPORT, <B>KDB_RET_NOKEY</B> = EBADMSG, <B>KDB_RET_NODATA</B> = ENOMSG, <B>KDB_RET_NODESC</B> = EIDRM, <B>KDB_RET_NODOMAIN</B> = EDOM, <B>KDB_RET_NOGROUP</B> = ECHILD, <B>KDB_RET_NOTIME</B> = EMULTIHOP, <B>KDB_RET_NOCRED</B> = EACCES, <B>KDB_RET_TRUNC</B> = ENOBUFS, <B>KDB_RET_NOMEM</B> = ENOMEM, <B>KDB_RET_TYPEMISMATCH</B> = EILSEQ, <B>KDB_RET_NOSYS</B> = ENOSYS, <B>KDB_RET_EBACKEND</B> = EIO }

<BR>

<I>Some return codes generated by the Elektra library. </I>

<BR>

enum <B>KDBOptions</B> { <B>KDB_O_RECURSIVE</B> = 1, <B>KDB_O_DIR</B> = 1&lt;&lt;1, <B>KDB_O_DIRONLY</B> = 1&lt;&lt;2, <B>KDB_O_STATONLY</B> = 1&lt;&lt;4, <B>KDB_O_INACTIVE</B> = 1&lt;&lt;5, <B>KDB_O_SORT</B> = 1&lt;&lt;6, <B>KDB_O_NFOLLOWLINK</B> = 1&lt;&lt;7, <B>KDB_O_CONDENSED</B> = 1&lt;&lt;8, <B>KDB_O_NUMBERS</B> = 1&lt;&lt;9, <B>KDB_O_XMLHEADERS</B> = 1&lt;&lt;10, <B>KDB_O_FULLNAME</B> = 1&lt;&lt;11, <B>KDB_O_FULLUGID</B> = 1&lt;&lt;12, <B>KDB_O_NOCASE</B> = 1&lt;&lt;15, <B>KDB_O_NOSPANPARENT</B> = 1&lt;&lt;16 }

<BR>

<I>Options to change the default behavior of some methods. </I>


<A NAME="lbAD">&nbsp;</A>
<H3>Functions</H3>

<P>

<BR>

int <B>kdbOpen</B> ()

<BR>

<I>Opens the session with the Key database, using a backend defined by environment var $KDB_BACKEND</I>. 

<BR>

int <B>kdbOpenDefault</B> ()

<BR>

<I>Opens the session with the Key database. </I>

<BR>

int <B>kdbOpenBackend</B> (char *backendName)

<BR>

<I>Opens the session with the Key database, dynamically loading a specific beckend for libkdb.so. </I>

<BR>

int <B>kdbClose</B> ()

<BR>

<I>Closes the session with the Key database. </I>

<BR>

int <B>kdbGetValue</B> (const char *keyname, char *returned, size_t maxSize)

<BR>

<I>A high-level method to get a key value, by key name. </I>

<BR>

int <B>kdbSetValue</B> (const char *keyname, const char *value)

<BR>

<I>A high-level method to set a value to a key, by key name. </I>

<BR>

int <B>kdbGetValueByParent</B> (const char *parentName, const char *baseName, char *returned, size_t maxSize)

<BR>

<I>Fills the </I>returned buffer with the value of a key, which name is the concatenation of parentName and baseName. 

<BR>

int <B>kdbSetValueByParent</B> (const char *parentName, const char *baseName, const char *value)

<BR>

<I>Sets the provided </I>value to the key whose name is the concatenation of parentName and baseName. 

<BR>

int <B>kdbGetKeyByParent</B> (const char *parentName, const char *baseName, <B>Key</B> *returned)

<BR>

<I>Given a parent key name plus a basename, returns the key. </I>

<BR>

int <B>kdbGetKeyByParentKey</B> (const <B>Key</B> *parent, const char *baseName, <B>Key</B> *returned)

<BR>

<I>Similar to previous, provided for convenience. </I>

<BR>

ssize_t <B>kdbGetKeyChildKeys</B> (const <B>Key</B> *parentKey, <B>KeySet</B> *returned, unsigned long options)

<BR>

<I>Retrieve a number of inter-related keys in one shot. </I>

<BR>

ssize_t <B>kdbGetChildKeys</B> (const char *parentName, <B>KeySet</B> *returned, unsigned long options)

<BR>

<I>This method is similar and calls </I><B>kdbGetKeyChildKeys()</B>. 

<BR>

ssize_t <B>kdbGetRootKeys</B> (<B>KeySet</B> *returned)

<BR>

<I>Returns a KeySet with all root keys currently recognized and present on the system. </I>

<BR>

int <B>kdbStatKey</B> (<B>Key</B> *key)

<BR>

<I>Taps the key only for its meta-info from the backend storage. </I>

<BR>

int <B>kdbGetKey</B> (<B>Key</B> *key)

<BR>

<I>Fully retrieves the passed </I>key from the backend storage. 

<BR>

int <B>kdbSetKeys</B> (<B>KeySet</B> *ks)

<BR>

<I>Commits the </I>ks KeySet to the backend storage, starting from ks's current position until its end. 

<BR>

int <B>kdbSetKey</B> (<B>Key</B> *key)

<BR>

<I>Sets </I>key in the backend storage. 

<BR>

int <B>kdbRename</B> (<B>Key</B> *key, const char *newName)

<BR>

<I>Rename a key in the backend storage. </I>

<BR>

int <B>kdbRemoveKey</B> (const <B>Key</B> *key)

<BR>

<I>Remove a key from the backend storage. </I>

<BR>

int <B>kdbRemove</B> (const char *keyName)

<BR>

<I>Remove a key by its name from the backend storage. </I>

<BR>

int <B>kdbLink</B> (const char *oldPath, const char *newKeyName)

<BR>

<I>Create a link key on the backend storage that points to other key. </I>

<BR>

u_int32_t <B>kdbMonitorKeys</B> (<B>KeySet</B> *interests, u_int32_t diffMask, unsigned long iterations, unsigned sleep)

<BR>

<I>Monitor a KeySet for some key change. </I>

<BR>

u_int32_t <B>kdbMonitorKey</B> (<B>Key</B> *interest, u_int32_t diffMask, unsigned long iterations, unsigned sleep)

<BR>

<I>Monitor a key change. </I>


<A NAME="lbAE">&nbsp;</A>
<H2>Detailed Description</H2>

<P>

General methods to access the Key database. 
<P>

To use them: 
<P>

<PRE>
#include &lt;<A HREF="file:/usr/include/kdb.h">kdb.h</A>&gt;

</PRE>

<P>

<P>

This is the class that accesses the storage backend. When <B>writing a new backend </B>, these are the methods you'll have to reimplement: <B>kdbOpen()</B>, <B>kdbClose()</B>, <B>kdbGetKey()</B>, <B>kdbSetKey()</B>, <B>kdbStatKey()</B>, <B>kdbGetKeyChildKeys()</B>, <B>kdbRemove()</B>, <B>kdbRename()</B>.
<P>

And methods that are suggested to reimplement (but not needed) if you want them to get the benefits of your new backend: <B>kdbSetKeys()</B>, <B>kdbMonitorKey()</B>, <B>kdbMonitorKeys()</B>.
<P>

The other methods are higher level. They use the above methods to do their job, and generally don't have to be reimplemented for a different backend.
<P>

Language binding writers should follow the same rules:
<DL COMPACT>
<DT>*<DD>
You should relay completelly on the backend-dependent methods
<DT>*<DD>
You may use or reimplement the second set of methods
<DT>*<DD>
You should completelly reimplement in your language the higher lever methods 
</DL>
<P>

<P>
<A NAME="lbAF">&nbsp;</A>
<H2>Enumeration Type Documentation</H2>

<P>

<A NAME="lbAG">&nbsp;</A>
<H3>enum <B>KDBErr</B></H3>

<P>

Some return codes generated by the Elektra library. 
<P>

These are Elektra specific errors only, that the library sets in errno. Other errors can be generated by system calls that the API uses. Then errno is propagated.
<P>

The idea is to keep compatibility to POSIX errno system, so each library error code maps to some POSIX E* error. Some mappings realy makes no sense, so to detect Elektra errors use the following error names, and to detect system's, use the naming convetions documented in errno man page.
<P>

A very robust program should check errno after each API call. 
<P>

<B>See also:</B>
<DL COMPACT><DT><DD>
<B>kdbGetChildKeys()</B> for an example on how to handle errors 
</DL>

<P>

<P>
<P>

<B>Enumeration values: </B>

<DL COMPACT>
<DT><B></B><I>KDB_RET_OK </I><DD>
No error 
<DT><B></B><I>KDB_RET_NULLKEY </I><DD>
Invalid Key object 
<DT><B></B><I>KDB_RET_UNINITIALIZED </I><DD>
Object not initilized 
<DT><B></B><I>KDB_RET_NOTFOUND </I><DD>
Key was not found 
<DT><B></B><I>KDB_RET_INVALIDKEY </I><DD>
Key name is not 'system/something' or 'user/something...' 
<DT><B></B><I>KDB_RET_NOKEY </I><DD>
Key has no name 
<DT><B></B><I>KDB_RET_NODATA </I><DD>
Key has no data 
<DT><B></B><I>KDB_RET_NODESC </I><DD>
Key has no comment/description 
<DT><B></B><I>KDB_RET_NODOMAIN </I><DD>
Key has no user domain set 
<DT><B></B><I>KDB_RET_NOGROUP </I><DD>
Key has no group 
<DT><B></B><I>KDB_RET_NOTIME </I><DD>
Key has no access time set 
<DT><B></B><I>KDB_RET_NOCRED </I><DD>
No credentials to access resource 
<DT><B></B><I>KDB_RET_TRUNC </I><DD>
Buffer was too small 
<DT><B></B><I>KDB_RET_NOMEM </I><DD>
Out of memory 
<DT><B></B><I>KDB_RET_TYPEMISMATCH </I><DD>
Failed to convert key data due to data type 
<DT><B></B><I>KDB_RET_NOSYS </I><DD>
Backend method not implemented 
<DT><B></B><I>KDB_RET_EBACKEND </I><DD>
Error opening backend 
</DL>
<P>

Definition at line 201 of file kdb.h.
<A NAME="lbAH">&nbsp;</A>
<H3>enum <B>KDBOptions</B></H3>

<P>

Options to change the default behavior of some methods. 
<P>

These options should be ORed. 
<P>

<B>See also:</B>
<DL COMPACT><DT><DD>
<B>kdbGetChildKeys()</B> 
<P>

<B>ksToStream()</B> 
<P>

<B>keyToStream()</B> 
</DL>

<P>

<P>
<P>

<B>Enumeration values: </B>

<DL COMPACT>
<DT><B></B><I>KDB_O_RECURSIVE </I><DD>
Act recursively. 
<DT><B></B><I>KDB_O_DIR </I><DD>
Include dir keys in result. 
<DT><B></B><I>KDB_O_DIRONLY </I><DD>
Retrieve only directory keys. 
<DT><B></B><I>KDB_O_STATONLY </I><DD>
Only stat key, instead of getting entirelly. 
<DT><B></B><I>KDB_O_INACTIVE </I><DD>
Do not ignore inactive keys (that name begins with .). 
<DT><B></B><I>KDB_O_SORT </I><DD>
Sort keys. 
<DT><B></B><I>KDB_O_NFOLLOWLINK </I><DD>
Do not follow symlinks. 
<DT><B></B><I>KDB_O_CONDENSED </I><DD>
Compressed XML, not usefull for human eyes. 
<DT><B></B><I>KDB_O_NUMBERS </I><DD>
Use numbers intead of user and group names. 
<DT><B></B><I>KDB_O_XMLHEADERS </I><DD>
Show also the XML header of the document. 
<DT><B></B><I>KDB_O_FULLNAME </I><DD>
Export user keys using full name (e.g. user:username/some/key). 
<DT><B></B><I>KDB_O_FULLUGID </I><DD>
Don't supress obvious key UID, GID, and user domain. Affects only user keys. 
<DT><B></B><I>KDB_O_NOCASE </I><DD>
Ignore case in ksLookup*() methods 
<DT><B></B><I>KDB_O_NOSPANPARENT </I><DD>
Don't continue search if end of current folder reached, in <B>ksLookupRE()</B> 
</DL>
<P>

Definition at line 245 of file kdb.h.
<A NAME="lbAI">&nbsp;</A>
<H2>Function Documentation</H2>

<P>

<A NAME="lbAJ">&nbsp;</A>
<H3>int kdbOpen ()</H3>

<P>

Opens the session with the Key database, using a backend defined by environment var <I>$KDB_BACKEND</I>. 
<P>

If the environment is not set the <I>default</I> backend will be opened.
<P>

You should allways call this method before retrieving or commiting any keys to the database. Otherwise, consequences are unpredictable. And after using the key database, you should not forget to <B>kdbClose()</B>.
<P>

This is the best way to have affairs with the key database, unless the program is concerned about security and authentication (e.g. su, login, telnetd, etc), in which <B>kdbOpenDefault()</B> should be used. <B>kdbOpen()</B> is used by the kdb command.
<P>

Currently you can have only one backend (and key database session) initialized at a certain time.
<P>

To simply manipulate Key or KeySet objects without having to retrieve them from the storage, you don't need to open the key database before with any of the kdbOpen*() methods.
<P>

<B>See also:</B>
<DL COMPACT><DT><DD>
<B>kdbOpenDefault()</B>, <B>kdbOpenBackend()</B>, <B>kdbClose()</B> 
</DL>

<P>

<B>Returns:</B>
<DL COMPACT><DT><DD>
0 on success or whatever is returned by <B>kdbOpenBackend()</B> 
</DL>

<P>

<P>
<P>

Definition at line 146 of file libkdb.c.
<P>

References kdbOpenBackend().
<P>

Referenced by commandExport().
<A NAME="lbAK">&nbsp;</A>
<H3>int kdbOpenDefault ()</H3>

<P>

Opens the session with the Key database. 
<P>

Different from <B>kdbOpen()</B>, <B>kdbOpenDefault()</B> will completely ignore the <I>$KDB_BACKEND</I> environment and open the <I>default</I> backend. So <B>kdbOpenDefault()</B> must be used by programs concerned about security (e.g. su, login, sshd, etc).
<P>

The <I>default</I> backend use to be a symlink to the real backend, and is found in /lib/libkdb-default.so
<P>

<B>See also:</B>
<DL COMPACT><DT><DD>
<B>kdbOpen()</B>, <B>kdbOpenBackend()</B>, <B>kdbClose()</B> 
</DL>

<P>

<B>Returns:</B>
<DL COMPACT><DT><DD>
0 on success or whatever is returned by <B>kdbOpenBackend()</B> 
</DL>

<P>

<P>
<P>

Definition at line 171 of file libkdb.c.
<P>

References kdbOpenBackend().
<A NAME="lbAL">&nbsp;</A>
<H3>int kdbOpenBackend (char * backendName)</H3>

<P>

Opens the session with the Key database, dynamically loading a specific beckend for libkdb.so. 
<P>

After dynamic loading, the backend will be initialized with its implementation of <B>kdbOpen()</B>.
<P>

<B>Parameters:</B>
<DL COMPACT><DT><DD>
<I>backendName</I> used to define the module filename as libkdb-'backendName'.so 
</DL>

<P>

<B>Returns:</B>
<DL COMPACT><DT><DD>
0 on success. On failure, errno is set to <B>KDBErr::KDB_RET_NOSYS</B> and 1 if backend library could not be opened, 2 if backend doesn't have the essential 'kdbBackendFactory' initialization symbol, 3 if backend failed to export its methods, 4 if backend does not provide a <B>kdbOpen()</B> implementation, or anything else that the backend's kdbOpen implementation (see <B>kdbOpen_backend()</B>) returns. 
</DL>

<P>

<B>See also:</B>
<DL COMPACT><DT><DD>
<B>kdbOpen()</B> 
</DL>

<P>

<B>Example of copying keys from one backend to another</B>.RS 4
<P>
<P>

<PRE>
KeySet *ks=ksNew();

kdbOpen(); // open default backend
kdbGetChildKeys('system/sw/httpd',ks, 
    KDB_O_NFOLLOWLINK |  // we want real links, not their targets
    KDB_O_INACTIVE |     // even commented (inactive) keys
    KDB_O_DIR |          // even pure directory keys
    KDB_O_RECURSIVE |    // all of this recursivelly
    KDB_O_SORT);         // sort all
kdbClose();

kdbOpenBackend('apache');

// The hipotethical libkdb-apache.so backend implementation for kdbSetKeys()
// simply interprets the passed KeySet and generates an old style
// equivalent /etc/httpd/httpd.conf file.
kdbSetKeys(ks);
kdbClose();

ksDel(ks);

</PRE>

<P>


<P>

<B>Emulating same bahavior of previous example but now with the kdb command</B>.RS 4
<P>
<P>

<PRE>
bash# kdb export system/sw/httpd &gt; apacheconf.xml
bash# KDB_BACKEND=apache kdb import apacheconf.xml

</PRE>

<P>


<P>

<P>
<P>

Definition at line 223 of file libkdb.c.
<P>

Referenced by kdbOpen(), and kdbOpenDefault().
<A NAME="lbAM">&nbsp;</A>
<H3>int kdbClose ()</H3>

<P>

Closes the session with the Key database. 
<P>

You should call this method when you finished your affairs with the key database. You can manipulate Key and KeySet objects after <B>kdbClose()</B>.
<P>

This is the counterpart of <B>kdbOpen()</B>. 
<P>

<B>See also:</B>
<DL COMPACT><DT><DD>
<B>kdbOpen()</B> 
</DL>

<P>

<B>Returns:</B>
<DL COMPACT><DT><DD>
0 on success, anything else on failure, and errno is set. If the backend implementation of kdbOpen can't be found, errno is set to <B>KDBErr::KDB_RET_NOSYS</B>. 
</DL>

<P>

<P>
<P>

Definition at line 285 of file libkdb.c.
<P>

Referenced by commandExport().
<A NAME="lbAN">&nbsp;</A>
<H3>int kdbGetValue (const char * keyname, char * returned, size_t maxSize)</H3>

<P>

A high-level method to get a key value, by key name. 
<P>

This method is valid only for string keys. You should use other methods to get non-string keys.
<P>

<B>Parameters:</B>
<DL COMPACT><DT><DD>
<I>keyname</I> the name of the key to receive the value 
<BR>

<I>returned</I> a buffer to put the key value 
<BR>

<I>maxSize</I> the size of the buffer 
</DL>

<P>

<B>Returns:</B>
<DL COMPACT><DT><DD>
0 on success, or other value in case of error, and errno is set 
</DL>

<P>

<B>See also:</B>
<DL COMPACT><DT><DD>
<B>kdbSetValue()</B>, <B>kdbGetKey()</B>, <B>kdbGetValueByParent()</B>, <B>keyGetString()</B> 
</DL>

<P>

<P>
<P>

Definition at line 494 of file libkdb.c.
<P>

References kdbGetKey(), KEY_SWITCH_END, keyDel(), keyGetString(), and keyNew().
<P>

Referenced by kdbGetValueByParent(), and ksFromXMLfile().
<A NAME="lbAO">&nbsp;</A>
<H3>int kdbSetValue (const char * keyname, const char * value)</H3>

<P>

A high-level method to set a value to a key, by key name. 
<P>

It will obviously check if key exists first, and keep its metadata. So you'll not loose the precious key comment.
<P>

This will set a text key. So if the key was previously a binary, etc key, it will be retyped as text.
<P>

<B>Parameters:</B>
<DL COMPACT><DT><DD>
<I>keyname</I> the name of the key to receive the value 
<BR>

<I>value</I> the value to be set 
</DL>

<P>

<B>Returns:</B>
<DL COMPACT><DT><DD>
0 on success, other value otherwise, and errno is set 
</DL>

<P>

<B>See also:</B>
<DL COMPACT><DT><DD>
<B>kdbGetValue()</B>, <B>keySetString()</B>, <B>kdbSetKey()</B> 
</DL>

<P>

<P>
<P>

Definition at line 522 of file libkdb.c.
<P>

References kdbGetKey(), kdbSetKey(), KEY_SWITCH_END, keyDel(), keyNew(), and keySetString().
<P>

Referenced by kdbSetValueByParent().
<A NAME="lbAP">&nbsp;</A>
<H3>int kdbGetValueByParent (const char * parentName, const char * baseName, char * returned, size_t maxSize)</H3>

<P>

Fills the returned buffer with the value of a key, which name is the concatenation of parentName and baseName. 
<P>

<B>Example:</B>.RS 4
<P>
<P>

<PRE>
char *parent='user/sw/MyApp';
char *keys[]={'key1','key2','key3'};
char buffer[150];   // a big buffer
int c;

for (c=0; c&lt;3; c++) {
    kdbGetValueByParent(parent,keys[c],buffer,sizeof(buffer));
    // Do something with buffer....
}

</PRE>

<P>


<P>

<B>Parameters:</B>
<DL COMPACT><DT><DD>
<I>parentName</I> the name of the parent key 
<BR>

<I>baseName</I> the name of the child key 
<BR>

<I>returned</I> pre-allocated buffer to be filled with key value 
<BR>

<I>maxSize</I> size of the returned buffer 
</DL>

<P>

<B>Returns:</B>
<DL COMPACT><DT><DD>
whathever is returned by <B>kdbGetValue()</B> 
</DL>

<P>

<B>See also:</B>
<DL COMPACT><DT><DD>
<B>kdbGetKeyByParent()</B> 
</DL>

<P>

<P>
<P>

Definition at line 563 of file libkdb.c.
<P>

References kdbGetValue(), and strblen().
<A NAME="lbAQ">&nbsp;</A>
<H3>int kdbSetValueByParent (const char * parentName, const char * baseName, const char * value)</H3>

<P>

Sets the provided value to the key whose name is the concatenation of parentName and baseName. 
<P>

<B>Parameters:</B>
<DL COMPACT><DT><DD>
<I>parentName</I> the name of the parent key 
<BR>

<I>baseName</I> the name of the child key 
<BR>

<I>value</I> the value to set  whatever is returned by <B>kdbSetValue()</B> 
</DL>

<P>

<P>
<P>

Definition at line 582 of file libkdb.c.
<P>

References kdbSetValue(), and strblen().
<A NAME="lbAR">&nbsp;</A>
<H3>int kdbGetKeyByParent (const char * parentName, const char * baseName, <B>Key</B> * returned)</H3>

<P>

Given a parent key name plus a basename, returns the key. 
<P>

So here you'll provide something like
<DL COMPACT>
<DT>*<DD>
system/sw/myApp plus key1 to get system/sw/myApp/key1 
<DT>*<DD>
user/sw/MyApp plus dir1/key2 to get user/sw/MyApp/dir1/key2 
</DL>
<P>

<P>

<B>Parameters:</B>
<DL COMPACT><DT><DD>
<I>parentName</I> parent key name 
<BR>

<I>baseName</I> leaf or child name 
<BR>

<I>returned</I> a pointer to an initialized key to be filled 
</DL>

<P>

<B>Returns:</B>
<DL COMPACT><DT><DD>
0 on success, or what <B>kdbGetKey()</B> returns, and errno is set 
</DL>

<P>

<B>See also:</B>
<DL COMPACT><DT><DD>
<B>kdbGetKey()</B>, <B>kdbGetValueByParent()</B>, <B>kdbGetKeyByParentKey()</B> 
</DL>

<P>

<P>
<P>

Definition at line 605 of file libkdb.c.
<P>

References kdbGetKey(), keySetName(), and strblen().
<A NAME="lbAS">&nbsp;</A>
<H3>int kdbGetKeyByParentKey (const <B>Key</B> * parent, const char * basename, <B>Key</B> * returned)</H3>

<P>

Similar to previous, provided for convenience. 
<P>

<B>Parameters:</B>
<DL COMPACT><DT><DD>
<I>parent</I> pointer to the parent key 
</DL>

<P>

<B>See also:</B>
<DL COMPACT><DT><DD>
<B>kdbGetKey()</B>, <B>kdbGetKeyByParent()</B>, <B>kdbGetValueByParent()</B> 
</DL>

<P>

<B>Returns:</B>
<DL COMPACT><DT><DD>
0 on success, or what <B>kdbGetKey()</B> returns, and errno is set 
</DL>

<P>

<P>
<P>

Definition at line 622 of file libkdb.c.
<P>

References kdbGetKey(), keyGetFullName(), keyGetFullNameSize(), keySetName(), and strblen().
<A NAME="lbAT">&nbsp;</A>
<H3>ssize_t kdbGetKeyChildKeys (const <B>Key</B> * parentKey, <B>KeySet</B> * returned, unsigned long options)</H3>

<P>

Retrieve a number of inter-related keys in one shot. 
<P>

This is one of the most practicall methods of the library. Returns a KeySet with all retrieved keys. So if your application keys live bellow system/sw/myApp, you'll use this method to get them all.
<P>

Option can be any of the following, ORed:
<DL COMPACT>
<DT>*<DD>
<B>KDBOptions::KDB_O_RECURSIVE</B> 
<BR>

<BR>&nbsp;Retrieve&nbsp;also&nbsp;the&nbsp;keys&nbsp;under&nbsp;the&nbsp;child&nbsp;keys,&nbsp;recursively.&nbsp;The&nbsp;<A HREF="kdb.1.html">kdb</A>(1)&nbsp;ls&nbsp;command,&nbsp;with&nbsp;switch&nbsp;-R&nbsp;uses&nbsp;this&nbsp;option.
<DT>*<DD>
<B>KDBOptions::KDB_O_DIR</B> 
<BR>

<BR>&nbsp;By&nbsp;default,&nbsp;folder&nbsp;keys&nbsp;will&nbsp;not&nbsp;be&nbsp;returned&nbsp;because&nbsp;they&nbsp;don't&nbsp;have&nbsp;values&nbsp;and&nbsp;exist&nbsp;only&nbsp;to&nbsp;define&nbsp;hierarchy.&nbsp;Use&nbsp;this&nbsp;option&nbsp;if&nbsp;you&nbsp;need&nbsp;them&nbsp;to&nbsp;be&nbsp;included&nbsp;in&nbsp;the&nbsp;returned&nbsp;KeySet.
<DT>*<DD>
<B>KDBOptions::KDB_O_DIRONLY</B> 
<BR>

<BR>&nbsp;Include&nbsp;in&nbsp;returned&nbsp;only&nbsp;the&nbsp;directory&nbsp;keys.&nbsp;The&nbsp;resulting&nbsp;KeySet&nbsp;will&nbsp;be&nbsp;only&nbsp;the&nbsp;skeleton&nbsp;of&nbsp;the&nbsp;tree.
<DT>*<DD>
<B>KDBOptions::KDB_O_STATONLY</B> 
<BR>

<BR>&nbsp;Only&nbsp;<A HREF="stat.2.html">stat</A>(2)&nbsp;the&nbsp;keys;&nbsp;do&nbsp;not&nbsp;retrieve&nbsp;the&nbsp;value,&nbsp;comment&nbsp;and&nbsp;key&nbsp;data&nbsp;type.&nbsp;The&nbsp;resulting&nbsp;keys&nbsp;will&nbsp;be&nbsp;empty&nbsp;and&nbsp;usefull&nbsp;only&nbsp;for&nbsp;informational&nbsp;purposes.&nbsp;The&nbsp;<A HREF="kdb.1.html">kdb</A>(1)&nbsp;ls&nbsp;command,&nbsp;without&nbsp;the&nbsp;-v&nbsp;switch&nbsp;uses&nbsp;this&nbsp;option.
<DT>*<DD>
<B>KDBOptions::KDB_O_INACTIVE</B> 
<BR>

<BR>&nbsp;Will&nbsp;make&nbsp;it&nbsp;not&nbsp;ignore&nbsp;inactive&nbsp;keys.&nbsp;So&nbsp;returned&nbsp;will&nbsp;be&nbsp;filled&nbsp;also&nbsp;with&nbsp;inactive&nbsp;keys.&nbsp;See&nbsp;<A HREF="elektra.7.html">elektra</A>(7)&nbsp;to&nbsp;understand&nbsp;how&nbsp;inactive&nbsp;keys&nbsp;work.
<DT>*<DD>
<B>KDBOptions::KDB_O_SORT</B> 
<BR>

<BR>&nbsp;Will&nbsp;sort&nbsp;keys&nbsp;alphabetically&nbsp;by&nbsp;their&nbsp;names.
</DL>
<P>

<P>

<B>Example:</B>.RS 4
<P>
<P>

<PRE>
char errormsg[300];
KeySet *myConfig;
Key *key;

key=keyNew('system/sw/MyApp',KEY_SWITCH_END);
myConfig=ksNew();

kdbOpen();
rc=kdbGetKeyChildKeys(key, myConfig, KDB_O_RECURSIVE);
keyDel(key); // free this resource.... we'll use it later
kdbClose();

// Check and handle propagated error
if (rc) switch (errno) {
    case KDB_RET_INVALIDKEY:
        sprintf(errormsg,'Something invalid');
        perror(errormsg); // use system error messages
        break;
    case KDB_RET_NOTFOUND:
        fprintf(stderr,'Key not found'); // custom error message
        break;
    default:
        sprintf(errormsg,'My application');
        perror(errormsg); // use system error messages
        break;
}

ksRewind(myConfig); // go to begining of KeySet
key=ksNext(myConfig);
while (key) {
    // do something with each key . . .

    key=ksNext(myConfig); // next key
}

</PRE>

<P>


<P>

<B>Parameters:</B>
<DL COMPACT><DT><DD>
<I>parentKey</I> parent key 
<BR>

<I>returned</I> the (pre-initialized) KeySet returned with all keys found 
<BR>

<I>options</I> ORed options to control approaches 
</DL>

<P>

<B>See also:</B>
<DL COMPACT><DT><DD>
<B>KDBOptions</B> 
<P>

<B>kdbGetChildKeys()</B> for a convenience method 
<P>

<B>ksLookupByName()</B>, <B>ksLookupRE()</B>, <B>ksLookupByValue()</B> for powerfull lookups after the KeySet was retrieved 
<P>

<B>ksSort()</B> for what is done when you ask for <B>KDBOptions::KDB_O_SORT</B> 
<P>

<B>commandList()</B> code in <B>kdb</B> command for usage example 
<P>

<B>commandEdit()</B> code in <B>kdb</B> command for usage example 
<P>

<B>commandExport()</B> code in <B>kdb</B> command for usage example 
</DL>

<P>

<B>Returns:</B>
<DL COMPACT><DT><DD>
number of keys contained by returned, or a negative value on error and errno is set 
</DL>

<P>

<P>
<P>

Definition at line 721 of file libkdb.c.
<P>

Referenced by commandList(), and kdbGetChildKeys().
<A NAME="lbAU">&nbsp;</A>
<H3>ssize_t kdbGetChildKeys (const char * parentName, <B>KeySet</B> * returned, unsigned long options)</H3>

<P>

This method is similar and calls <B>kdbGetKeyChildKeys()</B>. 
<P>

It is provided for convenience. 
<P>

Definition at line 738 of file libkdb.c.
<P>

References kdbGetKeyChildKeys(), KEY_SWITCH_END, keyDel(), and keyNew().
<P>

Referenced by commandEdit(), and commandList().
<A NAME="lbAV">&nbsp;</A>
<H3>ssize_t kdbGetRootKeys (<B>KeySet</B> * returned)</H3>

<P>

Returns a KeySet with all root keys currently recognized and present on the system. 
<P>

Currently, the system and current user's user keys are returned. 
<P>

<B>Parameters:</B>
<DL COMPACT><DT><DD>
<I>returned</I> the initialized KeySet to be filled 
</DL>

<P>

<B>Returns:</B>
<DL COMPACT><DT><DD>
the number of root keys found 
</DL>

<P>

<B>See also:</B>
<DL COMPACT><DT><DD>
<B>KeyNamespace</B> 
<P>

<B>commandList()</B> code in <B>kdb</B> command for usage example 
</DL>

<P>

<P>
<P>

Definition at line 763 of file libkdb.c.
<P>

References _Key::flags, KEY_SWITCH_END, KEY_SWITCH_NEEDSYNC, keyDel(), keyNew(), ksInsert(), and _KeySet::size.
<P>

Referenced by commandList().
<A NAME="lbAW">&nbsp;</A>
<H3>int kdbStatKey (<B>Key</B> * key)</H3>

<P>

Taps the key only for its meta-info from the backend storage. 
<P>

The bahavior may change from backend to backend. In the filesystem backend, it will make only a <A HREF="stat.2.html">stat</A>(2) on the key.
<P>

A key of type KEY_TYPE_LINK will have its target address loaded in the key structure, which can be accessed later using <B>keyStealValue()</B> or <B>keyGetString()</B>. This is the only way to know the target of a link key without dereferencing it (in contrast to <B>kdbGetKey()</B>, where the link is dereferenced).
<P>

Info like comments and key data type are not retrieved.
<P>

<B>Parameters:</B>
<DL COMPACT><DT><DD>
<I>key</I> an initialized Key pointer to be filled. 
</DL>

<P>

<B>Returns:</B>
<DL COMPACT><DT><DD>
0 on success, -1 otherwise 
</DL>

<P>

<P>
<P>

Definition at line 801 of file libkdb.c.
<P>

Referenced by commandList().
<A NAME="lbAX">&nbsp;</A>
<H3>int kdbGetKey (<B>Key</B> * key)</H3>

<P>

Fully retrieves the passed key from the backend storage. 
<P>

<B>Parameters:</B>
<DL COMPACT><DT><DD>
<I>key</I> a pointer to a Key that has a name set 
</DL>

<P>

<B>Returns:</B>
<DL COMPACT><DT><DD>
0 on success, or other value and errno is set 
</DL>

<P>

<B>See also:</B>
<DL COMPACT><DT><DD>
<B>kdbSetKey()</B> 
<P>

<B>commandGet()</B> code in <B>kdb</B> command for usage example 
</DL>

<P>

<P>
<P>

Definition at line 825 of file libkdb.c.
<P>

Referenced by commandEdit(), commandGet(), commandList(), commandSet(), kdbGetKeyByParent(), kdbGetKeyByParentKey(), kdbGetValue(), kdbMonitorKey_default(), kdbSetValue(), and keyNew().
<A NAME="lbAY">&nbsp;</A>
<H3>int kdbSetKeys (<B>KeySet</B> * ks)</H3>

<P>

Commits the ks KeySet to the backend storage, starting from ks's current position until its end. 
<P>

This is why it is suggested that you call <B>ksRewind()</B> on ks beffore calling this method. Each key is checked with <B>keyNeedsSync()</B> before being actually commited. So only changed keys are updated.
<P>

If some error occurs, <B>kdbSetKeys()</B> stops and returns whatever <B>kdbSetKey()</B> returned. The KeySet internal cursor is left on the key that generated the error (so you may check it latter with <B>ksCurrent()</B>). The internal <B>kdbSetKey()</B> also sets errno in case of error.
<P>

<B>Parameters:</B>
<DL COMPACT><DT><DD>
<I>ks</I> a KeySet full of changed keys 
</DL>

<P>

<B>Returns:</B>
<DL COMPACT><DT><DD>
0 on success, or whatever <B>kdbSetKey()</B> returns 
</DL>

<P>

<B>See also:</B>
<DL COMPACT><DT><DD>
<B>kdbSetKey()</B>, <B>keyNeedsSync()</B>, <B>ksNext()</B>, <B>ksCurrent()</B> 
<P>

<B>commandEdit()</B>, <B>commandImport()</B> code in <B>kdb</B> command for usage and error handling example 
</DL>

<P>

<P>
<P>

Definition at line 859 of file libkdb.c.
<P>

Referenced by commandEdit(), and commandImport().
<A NAME="lbAZ">&nbsp;</A>
<H3>int kdbSetKey (<B>Key</B> * key)</H3>

<P>

Sets key in the backend storage. 
<P>

<B>See also:</B>
<DL COMPACT><DT><DD>
<B>kdbGetKey()</B>, <B>kdbSetKeys()</B> 
<P>

<B>commandSet()</B> code in <B>kdb</B> command for usage example 
</DL>

<P>

<B>Returns:</B>
<DL COMPACT><DT><DD>
0 on success, or other value and errno is set 
</DL>

<P>

<P>
<P>

Definition at line 910 of file libkdb.c.
<P>

Referenced by commandSet(), kdbLink(), kdbSetKeys_default(), and kdbSetValue().
<A NAME="lbBA">&nbsp;</A>
<H3>int kdbRename (<B>Key</B> * key, const char * newName)</H3>

<P>

Rename a key in the backend storage. 
<P>

<B>Parameters:</B>
<DL COMPACT><DT><DD>
<I>key</I> the key to be renamed 
<BR>

<I>newName</I> the new key name 
</DL>

<P>

<B>Returns:</B>
<DL COMPACT><DT><DD>
0 on success, or whathever is returned by the backend implementation on failure, and errno is propagated 
</DL>

<P>

<P>
<P>

Definition at line 935 of file libkdb.c.
<P>

Referenced by commandMove().
<A NAME="lbBB">&nbsp;</A>
<H3>int kdbRemoveKey (const <B>Key</B> * key)</H3>

<P>

Remove a key from the backend storage. 
<P>

This method is not recursive.
<P>

<B>Parameters:</B>
<DL COMPACT><DT><DD>
<I>key</I> the key to be removed 
</DL>

<P>

<B>Returns:</B>
<DL COMPACT><DT><DD>
0 on success, or whathever is returned by the backend implementation on failure, and errno is propagated 
</DL>

<P>

<B>See also:</B>
<DL COMPACT><DT><DD>
<B>commandRemove()</B>, and <B>ksCompare()</B> code in <B>kdb</B> command for usage example 
</DL>

<P>

<P>
<P>

Definition at line 960 of file libkdb.c.
<P>

Referenced by kdbRemove().
<A NAME="lbBC">&nbsp;</A>
<H3>int kdbRemove (const char * keyName)</H3>

<P>

Remove a key by its name from the backend storage. 
<P>

This is a convenience to <B>kdbRemoveKey()</B>.
<P>

<B>Parameters:</B>
<DL COMPACT><DT><DD>
<I>keyName</I> the name of the key to be removed 
</DL>

<P>

<B>Returns:</B>
<DL COMPACT><DT><DD>
0 on success, or whathever is returned by <B>kdbRemoveKey()</B>, and errno is propagated 
</DL>

<P>

<B>See also:</B>
<DL COMPACT><DT><DD>
<B>commandRemove()</B> code in <B>kdb</B> command for usage example 
</DL>

<P>

<P>
<P>

Definition at line 985 of file libkdb.c.
<P>

References kdbRemoveKey(), KEY_SWITCH_END, keyDel(), keyNew(), and keySetName().
<P>

Referenced by commandEdit(), and commandRemove().
<A NAME="lbBD">&nbsp;</A>
<H3>int kdbLink (const char * oldPath, const char * newKeyName)</H3>

<P>

Create a link key on the backend storage that points to other key. 
<P>

<B>Parameters:</B>
<DL COMPACT><DT><DD>
<I>oldPath</I> destination key name 
<BR>

<I>newKeyName</I> name of the key that will be created and will point to 
<BR>

<I>oldPath</I> 
</DL>

<P>

<B>Returns:</B>
<DL COMPACT><DT><DD>
whathever is returned by <B>kdbSetKey()</B>, and errno is set 
</DL>

<P>

<B>See also:</B>
<DL COMPACT><DT><DD>
<B>commandLink()</B> code in <B>kdb</B> command for usage example 
<P>

<B>commandSet()</B> code in <B>kdb</B> command for usage example 
</DL>

<P>

<P>
<P>

Definition at line 1017 of file libkdb.c.
<P>

References kdbSetKey(), KEY_SWITCH_END, keyDel(), keyNew(), and keySetLink().
<P>

Referenced by commandLink().
<A NAME="lbBE">&nbsp;</A>
<H3>u_int32_t kdbMonitorKeys (<B>KeySet</B> * interests, u_int32_t diffMask, unsigned long iterations, unsigned sleep)</H3>

<P>

Monitor a KeySet for some key change. 
<P>

This method will scan the interests KeySet, starting and finishing in the KeySet's next cursor position, in a circular behavior, looking for some change defined in the diffMask mask. It will use <B>kdbMonitorKey()</B> and will return at the first key change ocurrence, or when requested iterations finish.
<P>

You may check the return code to see if some key changed, and get the updated key using <B>ksCurrent()</B>.
<P>

<B>Example:</B>.RS 4
<P>
<P>

<PRE>
KeySet *myConfigs;

myConfigs=ksNew();
kdbGetChildKeys('system/sw/MyApp',myConfigs,KDB_O_RECURSIVE | KDB_O_SORT);

// use the keys . . . .

// now monitor any key change
ksRewind(myConfigs);
while (1) {
    Key *changed=0;
    char keyName[300];
    char keyData[300];
    u_int32_t diff;

    // block until any change in key value or comment . . .
    diff=kdbMonitorKeys(myConfigs,
        KEY_SWITCH_VALUE | KEY_SWITCH_COMMENT,
        0,0); // ad-infinitum

    changed=ksCurrent(myConfigs);
    keyGetName(changed,keyName,sizeof(keyName));

    switch (diff) {
        case KEY_SWITCH_FLAG:
            printf('Key %s was deleted,keyName);
            break;
        case KEY_SWITCH_NEEDSYNC:
            printf('No cretentials to access Key %s,keyName);
            break;
        default:
            keyGetString(changed,keyData,sizeof(keyData));
            printf('Key %s has changed its value to %s,keyName,keyData);
    }
}

ksDel(myConfigs);

</PRE>

<P>


<P>

<B>See also:</B>
<DL COMPACT><DT><DD>
<B>kdbMonitorKey()</B>, <B>ksCurrent()</B>, <B>ksRewind()</B>, <B>ksNext()</B>, <B>KeySwitch</B> 
<P>

<B>commandMonitor()</B> code in <B>kdb</B> command for usage example 
</DL>

<P>

<P>
<P>

Definition at line 1091 of file libkdb.c.
<A NAME="lbBF">&nbsp;</A>
<H3>u_int32_t kdbMonitorKey (<B>Key</B> * interest, u_int32_t diffMask, unsigned long iterations, unsigned sleep)</H3>

<P>

Monitor a key change. 
<P>

This method will block execution until one of the folowing happens:
<DL COMPACT>
<DT>*<DD>
All requested iterations, with requested sleep times, finish. If no change happens, zero is returned.
<DT>*<DD>
Requested key info and meta-info (defined by diffMask) changes when <B>keyCompare()</B>ed with the original interest.
</DL>
<P>

<P>

interest should be a full key with name, value, comments, permissions, etc, and all will be compared and then masked by diffMask.
<P>

If interest is a folder key, use KEY_SWITCH_TIME in diffMask to detect a time change, so you'll know something happened (key modification, creation, deletion) inside the folder.
<P>

If interest was not found, or deleted, the method will return immediatly a KEY_SWITCH_FLAG value.
<P>

If you don't have access rights to interest, the method will return immediatly a KEY_SWITCH_NEEDSYNC value.
<P>

If something from diffMask has changed in interest, it will be updated, so when method returns, you'll have an updated version of the key.
<P>

<B>Parameters:</B>
<DL COMPACT><DT><DD>
<I>interest</I> key that will be monitored 
<BR>

<I>diffMask</I> what particular info change we are interested 
<BR>

<I>iterations</I> how many times to test. 0 means infinitum or until some change happens 
<BR>

<I>sleep</I> time to sleep, in microseconds, between iterations. 0 defaults to 1 second. 
</DL>

<P>

<B>Returns:</B>
<DL COMPACT><DT><DD>
the ORed KEY_SWITCH_* flags of what changed 
</DL>

<P>

<B>See also:</B>
<DL COMPACT><DT><DD>
<B>KeySwitch</B> 
<P>

<B>keyCompare()</B> 
<P>

<B>kdbMonitorKeys()</B> to monitor KeySets, and for a code example 
<P>

<B>commandMonitor()</B> code in <B>kdb</B> command for usage example 
</DL>

<P>

<P>
<P>

Definition at line 1184 of file libkdb.c.
<P>

Referenced by commandMonitor(), and kdbMonitorKeys_default().
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DL>
<DT><A HREF="#lbAC">Enumerations</A><DD>
<DT><A HREF="#lbAD">Functions</A><DD>
</DL>
<DT><A HREF="#lbAE">Detailed Description</A><DD>
<DT><A HREF="#lbAF">Enumeration Type Documentation</A><DD>
<DL>
<DT><A HREF="#lbAG">enum <B>KDBErr</B></A><DD>
<DT><A HREF="#lbAH">enum <B>KDBOptions</B></A><DD>
</DL>
<DT><A HREF="#lbAI">Function Documentation</A><DD>
<DL>
<DT><A HREF="#lbAJ">int kdbOpen ()</A><DD>
<DT><A HREF="#lbAK">int kdbOpenDefault ()</A><DD>
<DT><A HREF="#lbAL">int kdbOpenBackend (char * backendName)</A><DD>
<DT><A HREF="#lbAM">int kdbClose ()</A><DD>
<DT><A HREF="#lbAN">int kdbGetValue (const char * keyname, char * returned, size_t maxSize)</A><DD>
<DT><A HREF="#lbAO">int kdbSetValue (const char * keyname, const char * value)</A><DD>
<DT><A HREF="#lbAP">int kdbGetValueByParent (const char * parentName, const char * baseName, char * returned, size_t maxSize)</A><DD>
<DT><A HREF="#lbAQ">int kdbSetValueByParent (const char * parentName, const char * baseName, const char * value)</A><DD>
<DT><A HREF="#lbAR">int kdbGetKeyByParent (const char * parentName, const char * baseName, <B>Key</B> * returned)</A><DD>
<DT><A HREF="#lbAS">int kdbGetKeyByParentKey (const <B>Key</B> * parent, const char * basename, <B>Key</B> * returned)</A><DD>
<DT><A HREF="#lbAT">ssize_t kdbGetKeyChildKeys (const <B>Key</B> * parentKey, <B>KeySet</B> * returned, unsigned long options)</A><DD>
<DT><A HREF="#lbAU">ssize_t kdbGetChildKeys (const char * parentName, <B>KeySet</B> * returned, unsigned long options)</A><DD>
<DT><A HREF="#lbAV">ssize_t kdbGetRootKeys (<B>KeySet</B> * returned)</A><DD>
<DT><A HREF="#lbAW">int kdbStatKey (<B>Key</B> * key)</A><DD>
<DT><A HREF="#lbAX">int kdbGetKey (<B>Key</B> * key)</A><DD>
<DT><A HREF="#lbAY">int kdbSetKeys (<B>KeySet</B> * ks)</A><DD>
<DT><A HREF="#lbAZ">int kdbSetKey (<B>Key</B> * key)</A><DD>
<DT><A HREF="#lbBA">int kdbRename (<B>Key</B> * key, const char * newName)</A><DD>
<DT><A HREF="#lbBB">int kdbRemoveKey (const <B>Key</B> * key)</A><DD>
<DT><A HREF="#lbBC">int kdbRemove (const char * keyName)</A><DD>
<DT><A HREF="#lbBD">int kdbLink (const char * oldPath, const char * newKeyName)</A><DD>
<DT><A HREF="#lbBE">u_int32_t kdbMonitorKeys (<B>KeySet</B> * interests, u_int32_t diffMask, unsigned long iterations, unsigned sleep)</A><DD>
<DT><A HREF="#lbBF">u_int32_t kdbMonitorKey (<B>Key</B> * interest, u_int32_t diffMask, unsigned long iterations, unsigned sleep)</A><DD>
</DL>
</DL>
<HR>
This document was created by
<A HREF="http://localhost/cgi-bin/man/man2html">man2html</A>,
using the manual pages.<BR>
Time: 13:54:02 GMT, July 25, 2005
</BODY>
</HTML>
