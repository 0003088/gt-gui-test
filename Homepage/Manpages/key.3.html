

<HTML><HEAD><TITLE>Manpage of Key :: Basic Methods</TITLE>
</HEAD><BODY>
<H1>Key :: Basic Methods</H1>
Section: C Library Functions (3)<BR>Updated: 25 Jul 2005<BR><A HREF="#index">Index</A>
<A HREF="index.html">Return to Main Contents</A><HR>



<A NAME="lbAB">&nbsp;</A>
<H2>NAME</H2>

Key :: Basic Methods - Key construction and initialization methods.  
<P>
<P>

<A NAME="lbAC">&nbsp;</A>
<H3>Enumerations</H3>

<P>

<BR>

enum <B>KeyType</B> { <B>KEY_TYPE_UNDEFINED</B> = 0, <B>KEY_TYPE_DIR</B> = 1, <B>KEY_TYPE_LINK</B> = 2, <B>KEY_TYPE_BINARY</B> = 20, <B>KEY_TYPE_STRING</B> = 40 }

<BR>

<I>Key data types. </I>

<BR>

enum <B>KeyNamespace</B> { <B>KEY_NS_SYSTEM</B> = 1, <B>KEY_NS_USER</B> = 2 }

<BR>

<I>Elektra currently supported Key namespaces. </I>

<BR>

enum <B>KeySwitch</B> { <B>KEY_SWITCH_TYPE</B> = 1, <B>KEY_SWITCH_NAME</B> = 1&lt;&lt;1, <B>KEY_SWITCH_VALUE</B> = 1&lt;&lt;2, <B>KEY_SWITCH_OWNER</B> = 1&lt;&lt;5, <B>KEY_SWITCH_DOMAIN</B> = KEY_SWITCH_OWNER, <B>KEY_SWITCH_COMMENT</B> = 1&lt;&lt;6, <B>KEY_SWITCH_UID</B> = 1&lt;&lt;7, <B>KEY_SWITCH_GID</B> = 1&lt;&lt;8, <B>KEY_SWITCH_MODE</B> = 1&lt;&lt;10, <B>KEY_SWITCH_TIME</B> = 1&lt;&lt;11, <B>KEY_SWITCH_NEEDSYNC</B> = 1&lt;&lt;12, <B>KEY_SWITCH_ISSYSTEM</B> = 1&lt;&lt;23, <B>KEY_SWITCH_ISUSER</B> = 1&lt;&lt;24, <B>KEY_SWITCH_FLAG</B> = 1&lt;&lt;31, <B>KEY_SWITCH_END</B> = 0 }

<BR>

<I>Switches to denote the various Key attributes in methods throughout this library. </I>


<A NAME="lbAD">&nbsp;</A>
<H3>Functions</H3>

<P>

<BR>

<B>Key</B> * <B>keyNew</B> (const char *keyName,...)

<BR>

<I>A practical way to fully create a Key object in one step. </I>

<BR>

int <B>keyDel</B> (<B>Key</B> *key)

<BR>

<I>A destructor for Key objects. </I>

<BR>

int <B>keyDup</B> (const <B>Key</B> *source, <B>Key</B> *dest)

<BR>

<I>Clone a key. </I>

<BR>

int <B>keyInit</B> (<B>Key</B> *key)

<BR>

<I>Initializes a previously allocated Key object. </I>

<BR>

int <B>keyClose</B> (<B>Key</B> *key)

<BR>

<I>Finishes the usage of a Key object. </I>


<A NAME="lbAE">&nbsp;</A>
<H2>Detailed Description</H2>

<P>

Key construction and initialization methods. 
<P>

To use them: 
<P>

<PRE>
#include &lt;<A HREF="file:/usr/include/kdb.h">kdb.h</A>&gt;

</PRE>

<P>

<P>

A Key is the essential class that encapsulates key <B>name </B>, <B>value </B> and <B>metainfo </B>. Key properties are:
<DL COMPACT>
<DT>*<DD>
<B>Key name </B>
<DT>*<DD>
<B>Key value </B>
<DT>*<DD>
<B>Data type </B>
<DT>*<DD>
<B>Key comment </B>
<DT>*<DD>
<B>User domain </B> (the user that owns the key)
<DT>*<DD>
<B>UID, GID and filesystem-like access permissions </B>
<DT>*<DD>
<B>Access, change and modification times </B>
<DT>*<DD>
<B>A general flag </B>
</DL>
<P>

<P>

Described here the methods to allocate and free the key. 
<A NAME="lbAF">&nbsp;</A>
<H2>Enumeration Type Documentation</H2>

<P>

<A NAME="lbAG">&nbsp;</A>
<H3>enum <B>KeyType</B></H3>

<P>

Key data types. 
<P>

Key type values grow from the semantically poor to the semantically rich. The gaps between them is for user-defined types.
<P>

If your application needs value types with more semantics, like Color, Font, etc, you can still use it. You'll have to define a new type number in the scope of your application, and force the type with <B>keySetType()</B>, or <B>keyNew()</B>.
<P>

The type number is a value between 0 and 255. If your user-defined type &gt;= KEY_TYPE_STRING, it will be still treated as a string (in the terms of Unicode handling). If KEY_TYPE_BINARY &lt;= type &lt; KEY_TYPE_STRING, Elektra will handle it as a binary value, will not make Unicode handling and will save it hex-encoded.
<P>

<B>See also:</B>
<DL COMPACT><DT><DD>
<B>keyGetType()</B> 
<P>

<B>keySetType()</B> for an example of how to define custom types 
</DL>

<P>

<P>
<P>

<B>Enumeration values: </B>

<DL COMPACT>
<DT><B></B><I>KEY_TYPE_UNDEFINED </I><DD>
Undefined key type 
<DT><B></B><I>KEY_TYPE_DIR </I><DD>
A directory key 
<DT><B></B><I>KEY_TYPE_LINK </I><DD>
A symbolink link key. This gap is for special key meta types, that can't go into regular files. 
<DT><B></B><I>KEY_TYPE_BINARY </I><DD>
A binary key. This gap is for binary data types that have some semantics that somebody can invent in the future 
<DT><B></B><I>KEY_TYPE_STRING </I><DD>
A string key 
</DL>
<P>

Definition at line 72 of file kdb.h.
<A NAME="lbAH">&nbsp;</A>
<H3>enum <B>KeyNamespace</B></H3>

<P>

Elektra currently supported Key namespaces. 
<P>

<B>See also:</B>
<DL COMPACT><DT><DD>
<B>kdbGetRootKeys()</B>, <B>keyGetNamespace()</B>, <B>keyNameGetNamespace()</B> 
</DL>

<P>

<P>
<P>

<B>Enumeration values: </B>

<DL COMPACT>
<DT><B></B><I>KEY_NS_SYSTEM </I><DD>
The system keys 
<DT><B></B><I>KEY_NS_USER </I><DD>
The user keys 
</DL>
<P>

Definition at line 95 of file kdb.h.
<A NAME="lbAI">&nbsp;</A>
<H3>enum <B>KeySwitch</B></H3>

<P>

Switches to denote the various Key attributes in methods throughout this library. 
<P>

<B>See also:</B>
<DL COMPACT><DT><DD>
<B>keyNew()</B> 
<P>

<B>keyCompare()</B> 
<P>

<B>kdbMonitorKey()</B>, <B>kdbMonitorKeys()</B>, the diffMask parameter 
<P>

<B>keyGetFlag()</B>, <B>keySetFlag()</B> 
</DL>

<P>

<P>
<P>

<B>Enumeration values: </B>

<DL COMPACT>
<DT><B></B><I>KEY_SWITCH_TYPE </I><DD>
Flag for the key type 
<DT><B></B><I>KEY_SWITCH_NAME </I><DD>
Flag for the key name 
<DT><B></B><I>KEY_SWITCH_VALUE </I><DD>
Flag for the key data 
<DT><B></B><I>KEY_SWITCH_OWNER </I><DD>
Flag for the key user domain 
<DT><B></B><I>KEY_SWITCH_DOMAIN </I><DD>
An alias 
<DT><B></B><I>KEY_SWITCH_COMMENT </I><DD>
Flag for the key comment 
<DT><B></B><I>KEY_SWITCH_UID </I><DD>
Flag for the key UID 
<DT><B></B><I>KEY_SWITCH_GID </I><DD>
Flag for the key GID 
<DT><B></B><I>KEY_SWITCH_MODE </I><DD>
Flag for the key permissions 
<DT><B></B><I>KEY_SWITCH_TIME </I><DD>
Flag for the key change time 
<DT><B></B><I>KEY_SWITCH_NEEDSYNC </I><DD>
Flags that key needs syncronization 
<DT><B></B><I>KEY_SWITCH_ISSYSTEM </I><DD>
Flag to denote a 'system' key 
<DT><B></B><I>KEY_SWITCH_ISUSER </I><DD>
Flag to denote a 'user' key 
<DT><B></B><I>KEY_SWITCH_FLAG </I><DD>
General purpose flag that has semantics only to your app 
<DT><B></B><I>KEY_SWITCH_END </I><DD>
Used as a parameter terminator to <B>keyNew()</B> 
</DL>
<P>

Definition at line 135 of file kdb.h.
<A NAME="lbAJ">&nbsp;</A>
<H2>Function Documentation</H2>

<P>

<A NAME="lbAK">&nbsp;</A>
<H3><B>Key</B>* keyNew (const char * keyName,  ...)</H3>

<P>

A practical way to fully create a Key object in one step. 
<P>

This function tries to mimic the C++ way for constructors.
<P>

Due to ABI compatibility, the Key structure is not defined in <B>kdb.h</B>, only declared. So you can only declare pointers to Keys in your program, and allocate and free memory for them with <B>keyNew()</B> and <B>keyDel()</B> respectively. See <A HREF="http://tldp.org/HOWTO/Program-Library-HOWTO/shared-libraries.html#AEN135">http://tldp.org/HOWTO/Program-Library-HOWTO/shared-libraries.html#AEN135</A>
<P>

You can call it in many different ways depending on the attribute tags you pass as parameters. Tags are represented as the <B>KeySwitch</B> values, and tell <B>keyNew()</B> which Key attribute comes next.
<P>

The simplest way to call it is with no tags, only a key name. See example bellow.
<P>

The Key attribute tags are the following:
<DL COMPACT>
<DT>*<DD>
<B>KeySwitch::KEY_SWITCH_TYPE</B> 
<BR>

<BR>&nbsp;This&nbsp;tag&nbsp;requires&nbsp;1&nbsp;or&nbsp;2&nbsp;more&nbsp;parameters.&nbsp;The&nbsp;first&nbsp;is&nbsp;obviously&nbsp;the&nbsp;type.&nbsp;If&nbsp;the&nbsp;type&nbsp;is&nbsp;<B>KeySwitch::KEY_TYPE_BINARY</B>&nbsp;or&nbsp;any&nbsp;other&nbsp;binary-like&nbsp;user-defined&nbsp;type&nbsp;(see&nbsp;<B>keySetType()</B>),&nbsp;a&nbsp;second&nbsp;parameter&nbsp;is&nbsp;needed&nbsp;and&nbsp;is&nbsp;the&nbsp;size&nbsp;in&nbsp;bytes&nbsp;(size_t)&nbsp;of&nbsp;the&nbsp;data&nbsp;passed&nbsp;on&nbsp;the&nbsp;subsequent&nbsp;<B>KeySwitch::KEY_SWITCH_VALUE</B>&nbsp;parameter.&nbsp;You&nbsp;must&nbsp;use&nbsp;this&nbsp;tag&nbsp;before&nbsp;<B>KeySwitch::KEY_SWITCH_VALUE</B>,&nbsp;otherwise&nbsp;<B>KeyType::KEY_TYPE_STRING</B>&nbsp;is&nbsp;assumed.
<DT>*<DD>
<B>KeySwitch::KEY_SWITCH_VALUE</B> 
<BR>

<BR>&nbsp;Next&nbsp;parameter&nbsp;is&nbsp;a&nbsp;pointer&nbsp;to&nbsp;the&nbsp;value&nbsp;that&nbsp;will&nbsp;be&nbsp;set&nbsp;to&nbsp;the&nbsp;key.&nbsp;If&nbsp;no&nbsp;<B>KeySwitch::KEY_SWITCH_TYPE</B>&nbsp;was&nbsp;used&nbsp;before,&nbsp;<B>KeySwitch::KEY_TYPE_STRING</B>&nbsp;is&nbsp;assumed.
<DT>*<DD>
<B>KeySwitch::KEY_SWITCH_UID</B>, <B>KeySwitch::KEY_SWITCH_GID</B> 
<BR>

<BR>&nbsp;Next&nbsp;parameter&nbsp;is&nbsp;taken&nbsp;as&nbsp;the&nbsp;UID&nbsp;(uid_t)&nbsp;or&nbsp;GID&nbsp;(gid_t)&nbsp;that&nbsp;will&nbsp;be&nbsp;defined&nbsp;on&nbsp;the&nbsp;key.&nbsp;See&nbsp;<B>keySetUID()</B>&nbsp;and&nbsp;<B>keySetGID()</B>.
<DT>*<DD>
<B>KeySwitch::KEY_SWITCH_MODE</B> 
<BR>

<BR>&nbsp;Next&nbsp;parameter&nbsp;is&nbsp;taken&nbsp;as&nbsp;access&nbsp;permissions&nbsp;(mode_t)&nbsp;to&nbsp;the&nbsp;key.&nbsp;See&nbsp;<B>keySetAccess()</B>.
<DT>*<DD>
<B>KeySwitch::KEY_SWITCH_DOMAIN</B> 
<BR>

<BR>&nbsp;Next&nbsp;parameter&nbsp;is&nbsp;the&nbsp;user&nbsp;domain.&nbsp;See&nbsp;<B>keySetOwner()</B>.
<DT>*<DD>
<B>KeySwitch::KEY_SWITCH_COMMENT</B> 
<BR>

<BR>&nbsp;Next&nbsp;parameter&nbsp;is&nbsp;a&nbsp;comment.&nbsp;See&nbsp;<B>keySetComment()</B>.
<DT>*<DD>
<B>KeySwitch::KEY_SWITCH_NEEDSYNC</B> 
<BR>

<BR>&nbsp;Needs&nbsp;no&nbsp;extra&nbsp;parameter.&nbsp;Makes&nbsp;<B>keyNew()</B>&nbsp;retrieve&nbsp;the&nbsp;Key&nbsp;from&nbsp;the&nbsp;backend&nbsp;with&nbsp;<B>kdbGetKey()</B>.&nbsp;In&nbsp;the&nbsp;same&nbsp;<B>keyNew()</B>&nbsp;call&nbsp;you&nbsp;can&nbsp;use&nbsp;this&nbsp;tag&nbsp;in&nbsp;conjunction&nbsp;with&nbsp;any&nbsp;other,&nbsp;which&nbsp;will&nbsp;make&nbsp;<B>keyNew()</B>&nbsp;modify&nbsp;only&nbsp;some&nbsp;attributes&nbsp;of&nbsp;the&nbsp;retrieved&nbsp;key,&nbsp;and&nbsp;return&nbsp;it&nbsp;for&nbsp;you.&nbsp;Order&nbsp;of&nbsp;parameters&nbsp;do&nbsp;matter.&nbsp;If&nbsp;the&nbsp;internal&nbsp;call&nbsp;to&nbsp;<B>kdbGetKey()</B>&nbsp;failed,&nbsp;you'll&nbsp;still&nbsp;have&nbsp;a&nbsp;valid,&nbsp;but&nbsp;flaged,&nbsp;key.&nbsp;Check&nbsp;with&nbsp;<B>keyGetFlag()</B>,&nbsp;and&nbsp;errno.&nbsp;You&nbsp;will&nbsp;have&nbsp;to&nbsp;<B>kdbOpen()</B>&nbsp;before&nbsp;using&nbsp;<B>keyNew()</B>&nbsp;with&nbsp;this&nbsp;tag.
<DT>*<DD>
<B>KeySwitch::KEY_SWITCH_END</B> 
<BR>

<BR>&nbsp;Must&nbsp;be&nbsp;the&nbsp;last&nbsp;parameter&nbsp;passed&nbsp;to&nbsp;<B>keyNew()</B>.&nbsp;It&nbsp;is&nbsp;allways&nbsp;required,&nbsp;unless&nbsp;the&nbsp;keyName&nbsp;is&nbsp;NULL&nbsp;too.
</DL>
<P>

<P>

<B>Example:</B>.RS 4
<P>
<P>

<PRE>
KeySet *ks=ksNew();

kdbOpen();
    
ksAppend(ks,keyNew(KEY_SWITCH_END));       // an empty key
    
ksAppend(ks,keyNew('user/sw',              // a simple key
    KEY_SWITCH_END));                      // no more args
    
ksAppend(ks,keyNew('system/sw',
    KEY_SWITCH_NEEDSYNC,                   // a key retrieved from storage
    KEY_SWITCH_END));                      // end of args               
    
ksAppend(ks,keyNew('user/tmp/ex1',
    KEY_SWITCH_VALUE,'some data',          // with a simple value
    KEY_SWITCH_END));                      // end of args
    
ksAppend(ks,keyNew('user/tmp/ex2',
    KEY_SWITCH_VALUE,'some data',          // with a simple value
    KEY_SWITCH_MODE,0777,                  // permissions
    KEY_SWITCH_END));                      // end of args
    
ksAppend(ks,keyNew('user/tmp/ex3',
    KEY_SWITCH_TYPE,KEY_TYPE_LINK,         // only type
    KEY_SWITCH_VALUE,'system/mtp/x',       // link destination
    KEY_SWITCH_MODE,0654,                  // weird permissions
    KEY_SWITCH_END));                      // end of args
    
ksAppend(ks,keyNew('user/tmp/ex4',
    KEY_SWITCH_TYPE,KEY_TYPE_BINARY,7,     // key type and value size (because it is binary)
    KEY_SWITCH_DOMAIN,'root',              // owner (not uid) is root
    KEY_SWITCH_VALUE,'some data',          // value that will be truncated
    KEY_SWITCH_COMMENT,'value is truncated',
    KEY_SWITCH_UID,0,                      // root uid
    KEY_SWITCH_END));                      // end of args
    
ksAppend(ks,keyNew('user/env/alias/ls',    // a key we know we have
    KEY_SWITCH_NEEDSYNC,                   // retrieve from storage
    KEY_SWITCH_END));                      // do nothing more
    
ksAppend(ks,keyNew('user/env/alias/ls',    // same key
    KEY_SWITCH_NEEDSYNC,                   // retrieve from storage
    KEY_SWITCH_DOMAIN,'root',              // set new owner (not uid) as root
    KEY_SWITCH_COMMENT,'new comment',      // set new comment
    KEY_SWITCH_END));                      // end of args
    
ksToStream(ks,stdout,KDB_O_XMLHEADERS);
    
ksDel(ks);
kdbClose();

</PRE>

<P>


<P>

<B>Parameters:</B>
<DL COMPACT><DT><DD>
<I>keyName</I> a valid name to the key, or NULL to get a simple initialized, but really empty, object 
</DL>

<P>

<B>See also:</B>
<DL COMPACT><DT><DD>
<B>keyDel()</B> 
</DL>

<P>

<B>Returns:</B>
<DL COMPACT><DT><DD>
a pointer to a new allocated and initialized Key object, or NULL if an invalid keyName was passed (see <B>keySetName()</B>). 
</DL>

<P>

<P>
<P>

Definition at line 321 of file key.c.
<P>

References _Key::flags, kdbGetKey(), KEY_SWITCH_COMMENT, KEY_SWITCH_DOMAIN, KEY_SWITCH_GID, KEY_SWITCH_MODE, KEY_SWITCH_NEEDSYNC, KEY_SWITCH_TYPE, KEY_SWITCH_UID, KEY_SWITCH_VALUE, KEY_TYPE_BINARY, keyInit(), keySetAccess(), keySetComment(), keySetGID(), keySetName(), keySetOwner(), keySetRaw(), keySetString(), keySetType(), and keySetUID().
<P>

Referenced by commandEdit(), commandGet(), commandList(), commandMonitor(), commandMove(), commandSet(), kdbGetChildKeys(), kdbGetRootKeys(), kdbGetValue(), kdbLink(), kdbMonitorKey_default(), kdbRemove(), and kdbSetValue().
<A NAME="lbAL">&nbsp;</A>
<H3>int keyDel (<B>Key</B> * key)</H3>

<P>

A destructor for Key objects. 
<P>

Every key created by <B>keyNew()</B> must be deleted with <B>keyDel()</B>. It will <B>keyClose()</B> and free() the key pointer.
<P>

There is the keyFree() macro if you prefer this method name.
<P>

<B>See also:</B>
<DL COMPACT><DT><DD>
<B>keyNew()</B> 
</DL>

<P>

<B>Returns:</B>
<DL COMPACT><DT><DD>
whatever is returned by <B>keyClose()</B> 
</DL>

<P>

<P>
<P>

Definition at line 424 of file key.c.
<P>

References keyClose().
<P>

Referenced by commandEdit(), commandGet(), commandList(), commandMonitor(), commandMove(), commandSet(), kdbGetChildKeys(), kdbGetRootKeys(), kdbGetValue(), kdbLink(), kdbMonitorKey_default(), kdbRemove(), kdbSetValue(), ksClose(), and ksCompare().
<A NAME="lbAM">&nbsp;</A>
<H3>int keyDup (const <B>Key</B> * source, <B>Key</B> * dest)</H3>

<P>

Clone a key. 
<P>

All private attributes of the source key will be copied, including its context on a KeySet, and nothing will be shared between both keys. <B>keyClose()</B> will be used on dest key before the operation, and internal buffers will be automatically allocated on dest.
<P>

<B>Parameters:</B>
<DL COMPACT><DT><DD>
<I>source</I> the source key 
<BR>

<I>dest</I> the new copy of the key 
</DL>

<P>

<B>Returns:</B>
<DL COMPACT><DT><DD>
0 on success 
</DL>

<P>

<B>See also:</B>
<DL COMPACT><DT><DD>
<B>keyClose()</B>, <B>keyInit()</B> 
</DL>

<P>

<P>
<P>

Definition at line 2211 of file key.c.
<P>

References _Key::comment, _Key::data, _Key::dataSize, _Key::flags, _Key::key, keyClose(), keySetComment(), keySetName(), keySetOwner(), keySetRaw(), and _Key::userDomain.
<P>

Referenced by kdbMonitorKey_default().
<A NAME="lbAN">&nbsp;</A>
<H3>int keyInit (<B>Key</B> * key)</H3>

<P>

Initializes a previously allocated Key object. 
<P>

This function should not be used, use <B>keyNew()</B> instead.
<P>

keyInit sets the key to a clear state. It uses memset to clear the memory. The type of the key is KEY_TYPE_UNDEFINED afterwards.
<P>

uid, gid and access masks are set with the current values of your system.
<P>

<B>example</B>.RS 4
code key=(Key *)malloc(sizeof(Key)); if (!key) return 0; keyInit(key); endcode 

<P>

<B>See also:</B>
<DL COMPACT><DT><DD>
<B>keyNew()</B>, <B>keyDel()</B>, <B>keyClose()</B> 
</DL>

<P>

<B>Returns:</B>
<DL COMPACT><DT><DD>
allways 0; 
</DL>

<P>

<P>
<P>

Definition at line 2832 of file key.c.
<P>

References _Key::access, _Key::flags, _Key::gid, _Key::type, and _Key::uid.
<P>

Referenced by keyNew().
<A NAME="lbAO">&nbsp;</A>
<H3>int keyClose (<B>Key</B> * key)</H3>

<P>

Finishes the usage of a Key object. 
<P>

Frees all internally allocated memory, and leave the Key object ready to be <B>keyInit()</B>ed to reuse, or deallocated.
<P>

<B>See also:</B>
<DL COMPACT><DT><DD>
<B>keyInit()</B> for usage example 
<P>

<B>keyNew()</B> and <B>keyDel()</B> as a more practicall approach for Key construction and destruction 
</DL>

<P>

<B>Returns:</B>
<DL COMPACT><DT><DD>
allways 0; 
</DL>

<P>

<P>
<P>

Definition at line 2862 of file key.c.
<P>

References _Key::comment, _Key::data, _Key::key, and _Key::userDomain.
<P>

Referenced by keyDel(), and keyDup().
<P>

<HR>
<A NAME="index">&nbsp;</A><H2>Index</H2>
<DL>
<DT><A HREF="#lbAB">NAME</A><DD>
<DL>
<DT><A HREF="#lbAC">Enumerations</A><DD>
<DT><A HREF="#lbAD">Functions</A><DD>
</DL>
<DT><A HREF="#lbAE">Detailed Description</A><DD>
<DT><A HREF="#lbAF">Enumeration Type Documentation</A><DD>
<DL>
<DT><A HREF="#lbAG">enum <B>KeyType</B></A><DD>
<DT><A HREF="#lbAH">enum <B>KeyNamespace</B></A><DD>
<DT><A HREF="#lbAI">enum <B>KeySwitch</B></A><DD>
</DL>
<DT><A HREF="#lbAJ">Function Documentation</A><DD>
<DL>
<DT><A HREF="#lbAK"><B>Key</B>* keyNew (const char * keyName,  ...)</A><DD>
<DT><A HREF="#lbAL">int keyDel (<B>Key</B> * key)</A><DD>
<DT><A HREF="#lbAM">int keyDup (const <B>Key</B> * source, <B>Key</B> * dest)</A><DD>
<DT><A HREF="#lbAN">int keyInit (<B>Key</B> * key)</A><DD>
<DT><A HREF="#lbAO">int keyClose (<B>Key</B> * key)</A><DD>
</DL>
</DL>
<HR>
This document was created by
<A HREF="http://localhost/cgi-bin/man/man2html">man2html</A>,
using the manual pages.<BR>
Time: 13:54:02 GMT, July 25, 2005
</BODY>
</HTML>
