<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>Elektra Project: kdbtools.c Source File</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.9.1 -->
<div class="qindex"><a class="qindex" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="modules.html">Modules</a> | <a class="qindex" href="annotated.html">Data&nbsp;Structures</a> | <a class="qindex" href="files.html">File&nbsp;List</a> | <a class="qindex" href="functions.html">Data&nbsp;Fields</a></div>
<h1>kdbtools.c</h1><div class="fragment"><pre class="fragment">00001 <span class="comment">/***************************************************************************</span>
00002 <span class="comment">            kdbtools.c  -  Elektra High Level Methods</span>
00003 <span class="comment">                             -------------------</span>
00004 <span class="comment">    begin                : Sat Jan 22 2005</span>
00005 <span class="comment">    copyright            : (C) 2005 by Avi Alkalay</span>
00006 <span class="comment">    email                : avi@unix.sh</span>
00007 <span class="comment"> ***************************************************************************/</span>
00008 
00009 <span class="comment">/***************************************************************************</span>
00010 <span class="comment"> *                                                                         *</span>
00011 <span class="comment"> *   This program is free software; you can redistribute it and/or modify  *</span>
00012 <span class="comment"> *   it under the terms of the BSD License (revised).                      *</span>
00013 <span class="comment"> *                                                                         *</span>
00014 <span class="comment"> ***************************************************************************/</span>
00015 
00016 
00017 
00018 
00019 <span class="comment">/* Subversion stuff</span>
00020 <span class="comment"></span>
00021 <span class="comment">$Id: kdbtools.c 218 2005-04-23 21:48:53Z aviram $</span>
00022 <span class="comment">$LastChangedBy: aviram $</span>
00023 <span class="comment"></span>
00024 <span class="comment">*/</span>
00025 
00026 
00027 
00028 <span class="preprocessor">#include &lt;libxml/xmlreader.h&gt;</span>
00029 <span class="preprocessor">#include &lt;libxml/xmlschemas.h&gt;</span>
00030 
00031 <span class="preprocessor">#ifndef KDB_SCHEMA_PATH</span>
00032 <span class="preprocessor"></span><span class="preprocessor">#define KDB_SCHEMA_PATH       "/usr/share/sgml/elektra-0.1.1/elektra.xsd"</span>
00033 <span class="preprocessor"></span><span class="preprocessor">#endif</span>
00034 <span class="preprocessor"></span><span class="preprocessor">#define KDB_SCHEMA_PATH_KEY   "system/sw/kdb/current/schemapath"</span>
00035 <span class="preprocessor"></span>
00036 
00037 
00038 <span class="preprocessor">#include "kdbtools.h"</span>
00039 <span class="preprocessor">#include "kdbprivate.h"</span>
00040 <span class="preprocessor">#include "kdb.h"</span>
00041 
00042 <span class="preprocessor">#include &lt;ctype.h&gt;</span>
00043 <span class="preprocessor">#include &lt;string.h&gt;</span>
00044 <span class="preprocessor">#include &lt;grp.h&gt;</span>
00045 <span class="preprocessor">#include &lt;pwd.h&gt;</span>
00046 <span class="preprocessor">#include &lt;unistd.h&gt;</span>
00047 <span class="preprocessor">#include &lt;stdlib.h&gt;</span>
00048 
00049 
00050 
00067 <span class="comment">/*</span>
00068 <span class="comment"> * Processes the current &lt;key&gt; node from reader, converting from XML</span>
00069 <span class="comment"> * to a Key object, and ksAppend() it to ks.</span>
00070 <span class="comment"> * </span>
00071 <span class="comment"> * See keyToStream() for an example of a &lt;key&gt; node.</span>
00072 <span class="comment"> * </span>
00073 <span class="comment"> * </span>
00074 <span class="comment"> * This function is completelly dependent on libxml.</span>
00075 <span class="comment"> */</span>
00076 <span class="keywordtype">int</span> processKeyNode(<a class="code" href="struct__KeySet.html">KeySet</a> *ks, <span class="keywordtype">char</span> *context, xmlTextReaderPtr reader) {
00077     xmlChar *nodeName=0;
00078     xmlChar *buffer=0;
00079     xmlChar *privateContext=0;
00080     <a class="code" href="struct__Key.html">Key</a> *newKey=0;
00081     <span class="keywordtype">int</span> appended=0;
00082     
00083     nodeName=xmlTextReaderName(reader);
00084     <span class="keywordflow">if</span> (!strcmp(nodeName,<span class="stringliteral">"key"</span>)) {
00085         u_int8_t type=KEY_TYPE_STRING; <span class="comment">/* default type */</span>
00086         <span class="keywordtype">int</span> end=0;
00087         
00088         newKey=<a class="code" href="group__key.html#ga0">keyNew</a>(0);
00089         
00090         xmlFree(nodeName); nodeName=0;
00091         
00092         buffer=xmlTextReaderGetAttribute(reader,<span class="stringliteral">"name"</span>);
00093         <span class="keywordflow">if</span> (buffer) {
00094             <a class="code" href="group__keyname.html#ga0">keySetName</a>(newKey,(<span class="keywordtype">char</span> *)buffer);
00095             xmlFree(buffer); buffer=0;
00096         } <span class="keywordflow">else</span> {
00097             privateContext=xmlTextReaderGetAttribute(reader,<span class="stringliteral">"parent"</span>);
00098             buffer=xmlTextReaderGetAttribute(reader,<span class="stringliteral">"basename"</span>);
00099             
00100             <span class="keywordflow">if</span> (buffer) {
00101                 <span class="keywordflow">if</span> (privateContext) <a class="code" href="group__keyname.html#ga0">keySetName</a>(newKey,privateContext);
00102                 <span class="keywordflow">else</span> <a class="code" href="group__keyname.html#ga0">keySetName</a>(newKey,context);
00103                 
00104                 <a class="code" href="group__keyname.html#ga1">keyAddBaseName</a>(newKey,buffer);
00105                 xmlFree(buffer);
00106             } <span class="keywordflow">else</span> {
00107                 <span class="comment">/* error: where is the name? */</span>
00108             }
00109         }
00110         
00111         buffer=xmlTextReaderGetAttribute(reader,<span class="stringliteral">"type"</span>);
00112         <span class="keywordflow">if</span> (buffer) {
00113             <span class="keywordflow">if</span> (!strcmp(buffer,<span class="stringliteral">"string"</span>))
00114                 type=KEY_TYPE_STRING;
00115             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(buffer,<span class="stringliteral">"link"</span>))
00116                 type=KEY_TYPE_LINK;
00117             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(buffer,<span class="stringliteral">"directory"</span>))
00118                 type=KEY_TYPE_DIR;
00119             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(buffer,<span class="stringliteral">"binary"</span>))
00120                 type=KEY_TYPE_BINARY;
00121             <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(buffer,<span class="stringliteral">"undefined"</span>))
00122                 type=KEY_TYPE_UNDEFINED;
00123             <span class="keywordflow">else</span> { <span class="comment">/* special user-defined value types */</span>
00124                 <span class="keywordtype">void</span> *converter=0;
00125                 
00126                 type=strtol(buffer,(<span class="keywordtype">char</span> **)&amp;converter,10);
00127                 <span class="keywordflow">if</span> ((<span class="keywordtype">void</span> *)buffer==converter)
00128                     <span class="comment">/* in case of error, fallback to default type again */</span>
00129                     type=KEY_TYPE_STRING;
00130             }
00131         }
00132         
00133         <a class="code" href="group__keyvalue.html#ga10">keySetType</a>(newKey,type);
00134         
00135         xmlFree(buffer); buffer=0;
00136 
00137 
00138 
00139         <span class="comment">/* Parse UID */</span>
00140         buffer=xmlTextReaderGetAttribute(reader,<span class="stringliteral">"uid"</span>);
00141         <span class="keywordflow">if</span> (buffer) {
00142             <span class="keywordflow">if</span> (isdigit(*buffer))
00143                 <a class="code" href="group__keymeta.html#ga9">keySetUID</a>(newKey,atoi(buffer));
00144             <span class="keywordflow">else</span> {
00145                 <span class="keyword">struct </span>passwd *pwd;
00146                 pwd=getpwnam(buffer);
00147                 <span class="keywordflow">if</span> (pwd) <a class="code" href="group__keymeta.html#ga9">keySetUID</a>(newKey,pwd-&gt;pw_uid);
00148                 <span class="keywordflow">else</span> fprintf(stderr,<span class="stringliteral">"kdb: Ignoring invalid user %s.\n"</span>,
00149                         buffer);
00150             }
00151             xmlFree(buffer); buffer=0;
00152         }
00153 
00154         
00155         <span class="comment">/* Parse GID */</span>
00156         buffer=xmlTextReaderGetAttribute(reader,<span class="stringliteral">"gid"</span>);
00157         <span class="keywordflow">if</span> (buffer) {
00158             <span class="keywordflow">if</span> (isdigit(*buffer)) {
00159                 <a class="code" href="group__keymeta.html#ga11">keySetGID</a>(newKey,atoi(buffer));
00160             } <span class="keywordflow">else</span> {
00161                 <span class="keyword">struct </span>group *grp;
00162                 grp=getgrnam(buffer);
00163                 <span class="keywordflow">if</span> (grp) <a class="code" href="group__keymeta.html#ga11">keySetGID</a>(newKey,grp-&gt;gr_gid);
00164                 <span class="keywordflow">else</span> fprintf(stderr,<span class="stringliteral">"kdb: Ignoring invalid group %s.\n"</span>,
00165                         buffer);
00166             }
00167             xmlFree(buffer); buffer=0;
00168         }
00169 
00170 
00171         <span class="comment">/* Parse permissions */</span>
00172         buffer=xmlTextReaderGetAttribute(reader,<span class="stringliteral">"mode"</span>);
00173         <span class="keywordflow">if</span> (buffer) <a class="code" href="group__keymeta.html#ga13">keySetAccess</a>(newKey,strtol(buffer,0,8));
00174         xmlFree(buffer); buffer=0;
00175 
00176 
00177         <span class="comment">/* Parse everything else */</span>
00178         <span class="keywordflow">while</span> (!end) {
00179             xmlFree(nodeName); nodeName=0;
00180             xmlTextReaderRead(reader);
00181             nodeName=xmlTextReaderName(reader);
00182 
00183             <span class="keywordflow">if</span> (!strcmp(nodeName,<span class="stringliteral">"value"</span>)) {
00184                 <span class="keywordflow">if</span> (xmlTextReaderIsEmptyElement(reader) ||
00185                     xmlTextReaderNodeType(reader)==15) <span class="keywordflow">continue</span>;
00186                 xmlTextReaderRead(reader);
00187                 buffer=xmlTextReaderValue(reader);
00188                 <span class="keywordflow">if</span> (buffer) {
00189                     <span class="comment">/* Key's value type was already set above */</span>
00190                     <span class="keywordflow">if</span> (<a class="code" href="group__key.html#gga5a10">KEY_TYPE_BINARY</a> &lt;= type &amp;&amp; type &lt; KEY_TYPE_STRING) {
00191                         <span class="keywordtype">char</span> *unencoded=0;
00192                         size_t unencodedSize;
00193                         
00194                         unencodedSize=<a class="code" href="group__backend.html#ga8">strblen</a>(buffer)/2;
00195                         unencoded=malloc(unencodedSize);
00196                         unencodedSize=<a class="code" href="group__backend.html#ga0">unencode</a>(buffer,unencoded);
00197                         <span class="keywordflow">if</span> (!unencodedSize) <span class="keywordflow">return</span> -1;
00198                         <a class="code" href="group__keyvalue.html#ga11">keySetRaw</a>(newKey,unencoded,unencodedSize);
00199                         free(unencoded);
00200                     } <span class="keywordflow">else</span> <a class="code" href="group__keyvalue.html#ga11">keySetRaw</a>(newKey,buffer,<a class="code" href="group__backend.html#ga8">strblen</a>(buffer));
00201                 }
00202             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(nodeName,<span class="stringliteral">"comment"</span>)) {
00203                 <span class="keywordflow">if</span> (xmlTextReaderIsEmptyElement(reader) ||
00204                     xmlTextReaderNodeType(reader)==15) <span class="keywordflow">continue</span>;
00205                 xmlTextReaderRead(reader);
00206                 buffer=xmlTextReaderValue(reader);
00207 
00208                 <a class="code" href="group__keymeta.html#ga4">keySetComment</a>(newKey,buffer);
00209             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(nodeName,<span class="stringliteral">"key"</span>)) {
00210                 <span class="comment">/* Here we found &lt;/key&gt; or a sub &lt;key&gt;.</span>
00211 <span class="comment">                   So include current key in the KeySet. */</span>
00212                 <span class="keywordflow">if</span> (newKey &amp;&amp; !appended) {
00213                     <a class="code" href="group__keyset.html#ga16">ksAppend</a>(ks,newKey);
00214                     appended=1;
00215                 }
00216                 
00217                 <span class="keywordflow">if</span> (xmlTextReaderNodeType(reader)==15)
00218                 <span class="comment">/* found a &lt;/key&gt; */</span>
00219                 end=1;
00220                 <span class="keywordflow">else</span> {
00221                     <span class="comment">/* found a sub &lt;key&gt; */</span>
00222                     <a class="code" href="group__keyvalue.html#ga10">keySetType</a>(newKey,KEY_TYPE_DIR);
00223                     <span class="comment">/* prepare the context (parent) */</span>
00224                     processKeyNode(ks,newKey-&gt;<a class="code" href="struct__Key.html#o11">key</a>,reader);
00225                 }
00226             }
00227             xmlFree(buffer); buffer=0;
00228         }
00229         <span class="keywordflow">if</span> (privateContext) xmlFree(privateContext);
00230     }
00231 
00232     <span class="keywordflow">if</span> (nodeName) xmlFree(nodeName),nodeName=0;
00233     <span class="keywordflow">return</span> 0;
00234 }
00235 
00236 
00237 
00238 
00239 <span class="keywordtype">int</span> processKeySetNode(<a class="code" href="struct__KeySet.html">KeySet</a> *ks, <span class="keywordtype">char</span> *context, xmlTextReaderPtr reader) {
00240     xmlChar *nodeName=0;
00241     xmlChar *privateContext=0;
00242     
00243     nodeName=xmlTextReaderName(reader);
00244     <span class="keywordflow">if</span> (!strcmp(nodeName,<span class="stringliteral">"keyset"</span>)) {
00245         <span class="keywordtype">int</span> end=0;
00246         
00247         privateContext=xmlTextReaderGetAttribute(reader,<span class="stringliteral">"parent"</span>);
00248         
00249         <span class="comment">/* Parse everything else */</span>
00250         <span class="keywordflow">while</span> (!end) {
00251             xmlFree(nodeName); nodeName=0;
00252             xmlTextReaderRead(reader);
00253             nodeName=xmlTextReaderName(reader);
00254             
00255             <span class="keywordflow">if</span> (!strcmp(nodeName,<span class="stringliteral">"key"</span>)) {
00256                 <span class="keywordflow">if</span> (privateContext) processKeyNode(ks,privateContext,reader);
00257                 <span class="keywordflow">else</span> processKeyNode(ks,context,reader);
00258             } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(nodeName,<span class="stringliteral">"keyset"</span>)) {
00259                 <span class="keywordflow">if</span> (xmlTextReaderNodeType(reader)==15)
00260                      <span class="comment">/* found a &lt;/keyset&gt; */</span>
00261                     end=1;
00262             }
00263         }
00264     }
00265     <span class="keywordflow">return</span> 0;
00266 }
00267 
00268 
00269 
00270 <span class="comment">/*</span>
00271 <span class="comment"> * This is the workhorse behind for ksFromXML() and ksFromXMLfile().</span>
00272 <span class="comment"> * It will process the entire XML document in reader and convert and</span>
00273 <span class="comment"> * save it in ks KeySet. Each node is processed by the processNode() function.</span>
00274 <span class="comment"> *</span>
00275 <span class="comment"> * This function is completelly dependent on libxml.</span>
00276 <span class="comment"> */</span>
00277 <span class="keywordtype">int</span> ksFromXMLReader(<a class="code" href="struct__KeySet.html">KeySet</a> *ks,xmlTextReaderPtr reader) {
00278     <span class="keywordtype">int</span> ret;
00279     xmlChar *nodeName=0;
00280 
00281     ret = xmlTextReaderRead(reader); <span class="comment">/* go to first node */</span>
00282     <span class="keywordflow">while</span> (ret == 1) {
00283         nodeName=xmlTextReaderName(reader);
00284         
00285         <span class="keywordflow">if</span> (!strcmp(nodeName,<span class="stringliteral">"key"</span>))
00286             processKeyNode(ks, 0, reader);
00287         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (!strcmp(nodeName,<span class="stringliteral">"keyset"</span>))
00288             processKeySetNode(ks, 0, reader);
00289         
00290         ret = xmlTextReaderRead(reader);
00291     }
00292     xmlFreeTextReader(reader);
00293     <span class="keywordflow">if</span> (ret) fprintf(stderr,<span class="stringliteral">"kdb: Failed to parse XML input\n"</span>);
00294 
00295     <span class="keywordflow">return</span> ret;
00296 }
00297 
00298 
00299 
00300 <span class="keywordtype">int</span> isValidXML(xmlDocPtr doc,<span class="keywordtype">char</span> *schemaPath) {
00301     xmlSchemaPtr wxschemas = NULL;
00302     xmlSchemaValidCtxtPtr ctxt;
00303     xmlSchemaParserCtxtPtr ctxt2=NULL;
00304     <span class="keywordtype">int</span> ret=0;
00305 
00306     ctxt2 = xmlSchemaNewParserCtxt(schemaPath);
00307 
00308 
00309     <span class="keywordflow">if</span> (ctxt2==NULL) {
00310         xmlFreeDoc(doc);
00311         <span class="keywordflow">return</span> 1;
00312     }
00313     
00314     xmlSchemaSetParserErrors(ctxt2,
00315         (xmlSchemaValidityErrorFunc) fprintf,
00316         (xmlSchemaValidityWarningFunc) fprintf,
00317         stderr);
00318     wxschemas = xmlSchemaParse(ctxt2);
00319     
00320     <span class="keywordflow">if</span> (wxschemas==NULL) {
00321         xmlSchemaFreeParserCtxt(ctxt2);
00322         xmlFreeDoc(doc);
00323         <span class="keywordflow">return</span> 1;
00324     }
00325     
00326     <span class="comment">/* try to validate the doc against the xml schema */</span>
00327     ctxt = xmlSchemaNewValidCtxt(wxschemas);
00328     xmlSchemaSetValidErrors(ctxt,
00329         (xmlSchemaValidityErrorFunc) fprintf,
00330         (xmlSchemaValidityWarningFunc) fprintf,
00331         stderr);
00332     
00333     <span class="keywordflow">if</span> (ctxt==NULL) {
00334         xmlSchemaFree(wxschemas);
00335         xmlSchemaFreeParserCtxt(ctxt2);
00336         xmlFreeDoc(doc);
00337         <span class="keywordflow">return</span> 1;
00338     }
00339     
00340     ret = xmlSchemaValidateDoc(ctxt, doc);
00341     xmlSchemaFreeValidCtxt(ctxt);
00342     xmlSchemaFree(wxschemas);
00343     xmlSchemaFreeParserCtxt(ctxt2);
00344 
00345     <span class="keywordflow">return</span> ret;
00346 }
00347 
00348 
00349 
<a name="l00355"></a><a class="code" href="group__tools.html#ga0">00355</a> <span class="keywordtype">int</span> <a class="code" href="group__tools.html#ga0">ksFromXMLfile</a>(<a class="code" href="struct__KeySet.html">KeySet</a> *ks,<span class="keywordtype">char</span> *filename) {
00356     xmlTextReaderPtr reader;
00357     xmlDocPtr doc;
00358     <span class="keywordtype">int</span> ret;
00359     <span class="keywordtype">char</span> schemaPath[513];
00360 
00361     doc = xmlParseFile(filename);
00362     <span class="keywordflow">if</span> (doc==NULL) <span class="keywordflow">return</span> 1;
00363     
00364     <span class="comment">/* Open the kdb to get the xml schema path */</span>
00365     schemaPath[0]=0;
00366     ret=<a class="code" href="group__kdb.html#ga4">kdbGetValue</a>(KDB_SCHEMA_PATH_KEY,schemaPath,<span class="keyword">sizeof</span>(schemaPath));
00367 
00368 <span class="comment">//  if (ret==0) ret = isValidXML(filename,schemaPath);</span>
00369 <span class="comment">//  else ret = isValidXML(filename,KDB_SCHEMA_PATH); /* fallback to builtin */</span>
00370 
00371     
00372     <span class="comment">/* if the validation was successful */</span>
00373     <span class="keywordflow">if</span> (!ret) {
00374         reader=xmlReaderWalker(doc);
00375         <span class="keywordflow">if</span> (reader) ret=ksFromXMLReader(ks,reader);
00376         <span class="keywordflow">else</span> {
00377             perror(<span class="stringliteral">"kdb"</span>);
00378             <span class="keywordflow">return</span> 1;
00379         }
00380     }
00381     xmlFreeDoc(doc);
00382     <span class="keywordflow">return</span> ret;
00383 }
00384 
00385 
00386 
00387 
00388 
00389 <span class="comment">/* FIXME: not working when fd is stdin */</span>
<a name="l00395"></a><a class="code" href="group__tools.html#ga1">00395</a> <span class="keywordtype">int</span> <a class="code" href="group__tools.html#ga1">ksFromXML</a>(<a class="code" href="struct__KeySet.html">KeySet</a> *ks,<span class="keywordtype">int</span> fd) {
00396     <span class="comment">/* Start of support for old XML library (no xmlReaderForFd()) */</span>
00397     <span class="keywordtype">char</span> filename[]=<span class="stringliteral">"/var/tmp/kdbeditXXXXXX"</span>;
00398     FILE *xmlfile=0;
00399     xmlfile=fdopen(mkstemp(filename),<span class="stringliteral">"rw+"</span>);
00400     <span class="keywordflow">while</span> (! feof(xmlfile)) {
00401         <span class="keywordtype">char</span> buffer[1000];
00402         ssize_t readed, writen;
00403 
00404         readed=read(fd,buffer,<span class="keyword">sizeof</span>(buffer));
00405         <span class="keywordflow">if</span> (readed&lt;0) {
00406             perror(<span class="stringliteral">"kdb"</span>);
00407             fclose(xmlfile);
00408             remove(filename);
00409             <span class="keywordflow">return</span> 1;
00410         }
00411 
00412         writen=write(fileno(xmlfile),buffer,readed);
00413         <span class="keywordflow">if</span> (writen&lt;0) {
00414             perror(<span class="stringliteral">"kdb"</span>);
00415             fclose(xmlfile);
00416             remove(filename);
00417             <span class="keywordflow">return</span> 1;
00418         }
00419     }
00420     fclose(xmlfile);
00421     <span class="keywordflow">return</span> <a class="code" href="group__tools.html#ga0">ksFromXMLfile</a>(ks,filename);
00422     <span class="comment">/* end of support */</span>
00423 
00424     <span class="comment">/* This code requires a newer version of XML library, not present in all</span>
00425 <span class="comment">       Linux/BSD/Unix distros. Don't use it yet.</span>
00426 <span class="comment">    // a complete XML document is expected</span>
00427 <span class="comment">    xmlTextReaderPtr reader=0;</span>
00428 <span class="comment">    int ret;</span>
00429 <span class="comment">    reader=xmlReaderForFd(fd,"file:/tmp/imp.xml",0,0);</span>
00430 <span class="comment">    if (reader) {</span>
00431 <span class="comment">        ret=ksFromXMLReader(ks,reader);</span>
00432 <span class="comment">    } else {</span>
00433 <span class="comment">        printf("kdb: Unable to open file descriptor %d for XML reading\n", fd);</span>
00434 <span class="comment">        return 1;</span>
00435 <span class="comment">    }</span>
00436 <span class="comment">    return ret;</span>
00437 <span class="comment">    // end of newer code */</span>
00438 }
00439 
00440 
00441 
00442 
00443 
00444 
00445 
</pre></div><hr size="1"><address style="align: right;"><small>Generated on Sat Jul 30 09:10:59 2005 for Elektra Project by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.3.9.1 </small></address>
</body>
</html>
