Filesys has the problem that it can not efficiently deduce if something
has changed. stat() for every key could be quite expensive(?) on a large
tree.

Filesys however needs its own resolver, or the resolver needs a way to
stat() recursively.

-- filesys with cache --

With a cache updating would be even more complicated:
(old refers to the keys in the cache of the last update)

With intersections it would be possible to see which keys need to be
get on update:
new \ old = newly generated keys -> get them
old \ new = removed keys -> pop them from keyset

For setting keys:
new \ old = keys left in the backend -> remove files permanently
old \ new = newly keys by the user -> set them permanently
