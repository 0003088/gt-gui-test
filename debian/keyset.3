.TH "KeySet Class Methods" 3 "18 Oct 2004" "Elektra Project" \" -*- nroff -*-
.ad l
.nh
.SH NAME
KeySet Class Methods \- Methods to manipulate KeySets. A KeySet is a linked list to group a number of Keys. Key Sets have an internal cursor to help in the Key navigation. 
More...
.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBksInit\fP (KeySet *ks)"
.br
.ti -1c
.RI "int \fBksClose\fP (KeySet *ks)"
.br
.ti -1c
.RI "size_t \fBksGetSize\fP (KeySet *ks)"
.br
.ti -1c
.RI "Key * \fBksNext\fP (KeySet *ks)"
.br
.ti -1c
.RI "int \fBksRewind\fP (KeySet *ks)"
.br
.ti -1c
.RI "Key * \fBksCurrent\fP (const KeySet *ks)"
.br
.ti -1c
.RI "size_t \fBksInsert\fP (KeySet *ks, Key *toInsert)"
.br
.ti -1c
.RI "size_t \fBksInsertKeys\fP (KeySet *ks, KeySet *toInsert)"
.br
.ti -1c
.RI "size_t \fBksAppend\fP (KeySet *ks, Key *toAppend)"
.br
.ti -1c
.RI "size_t \fBksAppendKeys\fP (KeySet *ks, KeySet *toAppend)"
.br
.ti -1c
.RI "int \fBksCompare\fP (KeySet *ks1, KeySet *ks2, KeySet *removed)"
.br
.ti -1c
.RI "size_t \fBksToStream\fP (const KeySet *ks, FILE *stream, unsigned long options)"
.br
.in -1c
.SH "DETAILED DESCRIPTION"
.PP 
Methods to manipulate KeySets. A KeySet is a linked list to group a number of Keys. Key Sets have an internal cursor to help in the Key navigation.
.PP
.PP
 These are the methods to make various manipulations in the objects of class KeySet. Methods for sorting, merging, comparing, and internal cursor manipulation are provided. To use it: 
.PP
.nf
#include <kdb.h>
.fi
 
.SH "FUNCTION DOCUMENTATION"
.PP 
.SS "size_t ksAppend (KeySet * ks, Key * toAppend)"
.PP
Append a new Key to the end of the KeySet. You should not append Keys that are local variables to a KeySet, only dinamycally allocated ones, due to the future \fBksClose\fP() you'll call on the KeySet. The KeySet internal cursor is not moved.
.PP
Do not \fBksAppend\fP() Keys that are already members of other KeySets.
.PP
\fBReturns: \fP
.in +1c
the size of the KeySet after insertion 
.PP
Parameters: \fP
.in +1c
.TP
\fB\fIks\fP\fP
KeySet that will receive the key 
.TP
\fB\fItoAppend\fP\fP
Key that will be appended to ks 
.PP
\fBSee also: \fP
.in +1c
\fBksClose\fP() , \fBksInsert\fP() , \fBksInsertKeys\fP() , \fBksAppendKeys\fP() 
.PP
Definition at line 2408 of file key.c.
.SS "size_t ksAppendKeys (KeySet * ks, KeySet * toAppend)"
.PP
Transfers an entire KeySet to the end of the KeySet.
.PP
After this call, the toAppend KeySet will be empty.
.PP
\fBReturns: \fP
.in +1c
the size of the KeySet after transfer 
.PP
Parameters: \fP
.in +1c
.TP
\fB\fIks\fP\fP
the KeySet that will receive the keys 
.TP
\fB\fItoAppend\fP\fP
the KeySet that provides the keys that will be transfered 
.PP
\fBSee also: \fP
.in +1c
\fBksAppend\fP() , \fBksInsert\fP() , \fBksInsertKeys\fP() 
.PP
Definition at line 2431 of file key.c.
.SS "int ksClose (KeySet * ks)"
.PP
KeySet destructor.
.PP
Will cause \fBkeyClose\fP() destructor to be called for all contained keys, and then frees the key object. This is why you should not \fBksAppend\fP() or \fBksInsert\fP() a Key that is a local variable, only dinamycally allocated Keys.
.PP
After this call, \fCks\fP object is ready to be freed by you.
.PP
\fBSee also: \fP
.in +1c
\fBksInit\fP() , \fBkeyClose\fP() , \fBksAppend\fP() for details on how keys are inserted in KeySets 
.PP
\fBReturns: \fP
.in +1c
0 
.PP
Definition at line 2253 of file key.c.
.SS "int ksCompare (KeySet * ks1, KeySet * ks2, KeySet * removed)"
.PP
Compare 2 KeySets with the following behavior:
.TP
A key (by full name) that is present on \fCks1\fP and \fCks2\fP, and has something different, will be transfered from \fCks2\fP to \fCks1\fP, and \fCks1's\fP (old) version deleted.
.TP
Keys that are in \fCks1\fP, but aren't in \fCks2\fP will be trasnsfered from \fCks1\fP to \fCremoved\fP.
.TP
Keys that are \fBkeyCompare\fP() equal in \fCks1\fP and \fCks2\fP will be deleted from \fCks2\fP.
.TP
Keys that are available in \fCks2\fP but don't exist in \fCks1\fP will be transfered to \fCks1\fP.
.PP
In the end, \fCks1\fP will have all the keys that matter, and \fCks2\fP will be empty.
.PP
After \fBksCompare\fP(), you should:
.TP
free(ks2)
.TP
call \fBkdbSetKeys\fP() on \fCks1\fP to commit all changed keys
.TP
\fBkdbRemove\fP() for all keys in the \fCremoved\fP KeySet
.PP
\fBSee also: \fP
.in +1c
\fBkeyCompare\fP() , \fBcommandEdit\fP() at the KeyDB Class Methods command 
.PP
Parameters: \fP
.in +1c
.TP
\fB\fIks1\fP\fP
first KeySet 
.TP
\fB\fIks2\fP\fP
second KeySet 
.TP
\fB\fIremoved\fP\fP
empty KeySet that will be filled with keys removed from \fCks1\fP 
.PP
Definition at line 2483 of file key.c.
.SS "Key* ksCurrent (const KeySet * ks)"
.PP
Return the current Key
.PP
\fBSee also: \fP
.in +1c
\fBksNext\fP() , \fBksRewind\fP() , \fBkdbMonitorKeys\fP() for an example 
.PP
\fBReturns: \fP
.in +1c
pointer to the Key pointed by \fCks's\fP cursor 
.PP
Definition at line 2328 of file key.c.
.SS "size_t ksGetSize (KeySet * ks)"
.PP
\fBReturns: \fP
.in +1c
the number of keys in the \fCks\fP. 
.PP
Definition at line 2275 of file key.c.
.SS "int ksInit (KeySet * ks)"
.PP
KeySet object constructor.
.PP
Every KeySet object that will be used must be initialized first, to setup pointers, counters, etc. 
.PP
\fBSee also: \fP
.in +1c
\fBksClose\fP() , \fBkeyInit\fP() 
.PP
Definition at line 2231 of file key.c.
.SS "size_t ksInsert (KeySet * ks, Key * toInsert)"
.PP
Insert a new Key in the begining of the KeySet. A reference to key will be stored, and not a copy of the key. So a future \fBksClose\fP() on \fCks\fP will \fBkeyClose\fP() \fCtoInsert\fP and free() the \fCtoInsert\fP object. The KeySet internal cursor is not moved.
.PP
Do not \fBksInsert\fP() Keys that are already members of other KeySets.
.PP
\fBReturns: \fP
.in +1c
the size of the KeySet after insertion 
.PP
Parameters: \fP
.in +1c
.TP
\fB\fIks\fP\fP
KeySet that will receive the key 
.TP
\fB\fItoInsert\fP\fP
Key that will be inserted into ks 
.PP
\fBSee also: \fP
.in +1c
\fBksAppend\fP() , \fBksInsertKeys\fP() , \fBksAppendKeys\fP() , \fBksClose\fP() 
.PP
Definition at line 2352 of file key.c.
.SS "size_t ksInsertKeys (KeySet * ks, KeySet * toInsert)"
.PP
Transfers an entire KeySet to the begining of the KeySet.
.PP
After this call, the \fCtoInsert\fP KeySet will be empty.
.PP
\fBReturns: \fP
.in +1c
the size of the KeySet after insertion 
.PP
Parameters: \fP
.in +1c
.TP
\fB\fIks\fP\fP
the KeySet that will receive the keys 
.TP
\fB\fItoInsert\fP\fP
the KeySet that provides the keys that will be transfered 
.PP
\fBSee also: \fP
.in +1c
\fBksAppend\fP() , \fBksInsert\fP() , \fBksAppendKeys\fP() 
.PP
Definition at line 2375 of file key.c.
.SS "Key* ksNext (KeySet * ks)"
.PP
Returns the next Key in a KeySet. KeySets have an internal cursor that can be reset with \fBksRewind\fP(). Every time \fBksNext\fP() is called the cursor is incremented and the new current Key is returned. You'll get a NULL pointer if the end of KeySet was reached. After that, if \fBksNext\fP() is called again, it will set the cursor to the begining of the KeySet and the first key is returned.
.PP
\fBSee also: \fP
.in +1c
\fBksRewind\fP() , \fBksCurrent\fP() 
.PP
\fBReturns: \fP
.in +1c
the new current Key 
.PP
Definition at line 2294 of file key.c.
.SS "int ksRewind (KeySet * ks)"
.PP
Resets a KeySet internal cursor. Use it to set the cursor to the begining of the KeySet
.PP
\fBSee also: \fP
.in +1c
\fBksNext\fP() , \fBksCurrent\fP() , \fBkdbMonitorKeys\fP() for an example 
.PP
\fBReturns: \fP
.in +1c
allways 0 
.PP
Definition at line 2313 of file key.c.
.SS "size_t ksToStream (const KeySet * ks, FILE * stream, unsigned long options)"
.PP
Prints an XML version of a KeySet object.
.PP
Accepted options:
.TP
\fCKDB_O_NUMBERS\fP: Do not convert UID and GID into user and group names
.TP
\fCKDB_O_CONDENSED\fP: Less human readable, more condensed output
.TP
\fCKDB_O_XMLHEADERS\fP: Include the correct XML headers in the output. Use it.
.PP
Parameters: \fP
.in +1c
.TP
\fB\fIstream\fP\fP
where to write output: a file or stdout 
.TP
\fB\fIoptions\fP\fP
ORed of \fCKDB_O_*\fP options 
.PP
\fBSee also: \fP
.in +1c
\fBkeyToStream\fP() , \fBKDBOptions\fP 
.PP
\fBReturns: \fP
.in +1c
number of bytes written to output 
.PP
Definition at line 2581 of file key.c.
