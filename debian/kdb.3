.TH "KDB Class Methods" 3 "18 Oct 2004" "Elektra Project" \" -*- nroff -*-
.ad l
.nh
.SH NAME
KDB Class Methods \- General methods to access the Key database. 
More...
.SS "Enumerations"

.in +1c
.ti -1c
.RI "enum \fBKDBErr\fP { \fBKDB_ERR_OK\fP = 0, \fBKDB_ERR_NULLKEY\fP = EINVAL, \fBKDB_ERR_UNINITIALIZED\fP = EINVAL, \fBKDB_ERR_NOKEY\fP = ENOMSG, \fBKDB_ERR_NODATA\fP = ENOMSG, \fBKDB_ERR_NOGROUP\fP = ENOMSG, \fBKDB_ERR_NODESC\fP = ENOMSG, \fBKDB_ERR_NODOMAIN\fP = ENOMSG, \fBKDB_ERR_NOCRED\fP = EACCES, \fBKDB_ERR_NOTIME\fP = ENOMSG, \fBKDB_ERR_TRUNC\fP = ENOBUFS, \fBKDB_ERR_TYPEMISMATCH\fP = EILSEQ, \fBKDB_ERR_INVALIDKEY\fP = EAFNOSUPPORT, \fBKDB_ERR_NOTFOUND\fP = ENOENT }"
.br
.ti -1c
.RI "enum \fBoption_t\fP { \fBKDB_O_RECURSIVE\fP = 1, \fBKDB_O_DIR\fP = 1<<1, \fBKDB_O_NOVALUE\fP = 1<<2, \fBKDB_O_STATONLY\fP = 1<<4, \fBKDB_O_INACTIVE\fP = 1<<5, \fBKDB_O_SORT\fP = 1<<6, \fBKDB_O_NFOLLOWLINK\fP = 1<<7, \fBKDB_O_CONDENSED\fP = 1<<8, \fBKDB_O_NUMBERS\fP = 1<<9, \fBKDB_O_XMLHEADERS\fP = 1<<10 }"
.br
.in -1c
.SS "Functions"

.in +1c
.ti -1c
.RI "int \fBkdbOpen\fP ()"
.br
.ti -1c
.RI "int \fBkdbClose\fP ()"
.br
.ti -1c
.RI "int \fBkdbGetValue\fP (const char *keyname, char *returned, size_t maxSize)"
.br
.ti -1c
.RI "int \fBkdbSetValue\fP (const char *keyname, const char *value)"
.br
.ti -1c
.RI "int \fBkdbGetValueByParent\fP (const char *parentName, const char *baseName, char *returned, size_t maxSize)"
.br
.ti -1c
.RI "int \fBkdbSetValueByParent\fP (const char *parentName, const char *baseName, const char *value)"
.br
.ti -1c
.RI "int \fBkdbGetKeyByParent\fP (const char *parentName, const char *baseName, Key *returned)"
.br
.ti -1c
.RI "int \fBkdbGetKeyByParentKey\fP (const Key *parent, const char *baseName, Key *returned)"
.br
.ti -1c
.RI "int \fBkdbGetChildKeys\fP (const char *parentName, KeySet *returned, unsigned long options)"
.br
.ti -1c
.RI "int \fBkdbGetRootKeys\fP (KeySet *returned)"
.br
.ti -1c
.RI "int \fBkdbStatKey\fP (Key *key)"
.br
.ti -1c
.RI "int \fBkdbGetKey\fP (Key *key)"
.br
.ti -1c
.RI "int \fBkdbSetKeys\fP (KeySet *ks)"
.br
.ti -1c
.RI "int \fBkdbSetKey\fP (Key *key)"
.br
.ti -1c
.RI "int \fBkdbRemove\fP (const char *keyName)"
.br
.ti -1c
.RI "int \fBkdbLink\fP (const char *oldPath, const char *newKeyName)"
.br
.ti -1c
.RI "u_int32_t \fBkdbMonitorKeys\fP (KeySet *interests, u_int32_t diffMask, unsigned long iterations, unsigned sleep)"
.br
.ti -1c
.RI "u_int32_t \fBkdbMonitorKey\fP (Key *interest, u_int32_t diffMask, unsigned long iterations, unsigned sleep)"
.br
.in -1c
.SH "DETAILED DESCRIPTION"
.PP 
General methods to access the Key database.
.PP
.PP
 To use them: 
.PP
.nf
#include <kdb.h>
.fi
.PP
This is the class that accesses the storage backend. When writing a new backend, these are the methods you'll have to reimplement: \fBkdbGetKey\fP(), \fBkdbSetKey\fP(), \fBkdbStatKey\fP(), \fBkdbRemove\fP(), \fBkdbGetChildKeys\fP()
.PP
And methods that you'll probably have to reimplement to get benefits of your new backend: \fBkdbOpen\fP(), \fBkdbClose\fP(), \fBkdbMonitorKey\fP(), \fBkdbMonitorKeys\fP()
.PP
The other methods are higher level. They use the above methods to do their job, and generally don't have to be reimplemented for a different backend. 
.SH "ENUMERATION TYPE DOCUMENTATION"
.PP 
.SS "enum KDBErr"
.PP
Some return codes generated by the Elektra library.
.PP
These are only specific Elektra errors, that the library sets in errno. Other error can be generated by system calls that the API uses. Then errno is propagated.
.PP
A very robust program should check errno after each API call. 
.PP
\fBSee also: \fP
.in +1c
\fBkdbGetChildKeys\fP() for an example on how to handle errors 
.PP
\fBEnumeration values:\fP
.in +1c
.TP
\fB\fI\fIKDB_ERR_OK\fP \fP\fP
No error 
.TP
\fB\fI\fIKDB_ERR_NULLKEY\fP \fP\fP
Invalid Key object 
.TP
\fB\fI\fIKDB_ERR_UNINITIALIZED\fP \fP\fP
Object not initilized 
.TP
\fB\fI\fIKDB_ERR_NOKEY\fP \fP\fP
Key has no name 
.TP
\fB\fI\fIKDB_ERR_NODATA\fP \fP\fP
Key has no data 
.TP
\fB\fI\fIKDB_ERR_NOGROUP\fP \fP\fP
Key has no group 
.TP
\fB\fI\fIKDB_ERR_NODESC\fP \fP\fP
Key has no comment/description 
.TP
\fB\fI\fIKDB_ERR_NODOMAIN\fP \fP\fP
Key has no user domain set 
.TP
\fB\fI\fIKDB_ERR_NOCRED\fP \fP\fP
No credentials to access resource 
.TP
\fB\fI\fIKDB_ERR_NOTIME\fP \fP\fP
Key has no access time set 
.TP
\fB\fI\fIKDB_ERR_TRUNC\fP \fP\fP
Buffer was too small 
.TP
\fB\fI\fIKDB_ERR_TYPEMISMATCH\fP \fP\fP
Failed to convert key data due to data type 
.TP
\fB\fI\fIKDB_ERR_INVALIDKEY\fP \fP\fP
Key name is no 'system/' or 'user/' 
.TP
\fB\fI\fIKDB_ERR_NOTFOUND\fP \fP\fP
Key was not found 
.PP
Definition at line 167 of file kdb.h.
.SS "enum option_t"
.PP
Options to change the default behavior of some methods.
.PP
These options should be ORed. 
.PP
\fBSee also: \fP
.in +1c
\fBkdbGetChildKeys\fP() , \fBksToStream\fP() , \fBkeyToStream\fP() 
.PP
\fBEnumeration values:\fP
.in +1c
.TP
\fB\fI\fIKDB_O_RECURSIVE\fP \fP\fP
Act recursively 
.TP
\fB\fI\fIKDB_O_DIR\fP \fP\fP
Include dir keys in result 
.TP
\fB\fI\fIKDB_O_NOVALUE\fP \fP\fP
Retrieve only keys that don't have values (a.k.a dir keys) 
.TP
\fB\fI\fIKDB_O_STATONLY\fP \fP\fP
Only stat key, instead of getting entirelly 
.TP
\fB\fI\fIKDB_O_INACTIVE\fP \fP\fP
Do not ignore inactive keys (that name begins with .) 
.TP
\fB\fI\fIKDB_O_SORT\fP \fP\fP
Sort keys 
.TP
\fB\fI\fIKDB_O_NFOLLOWLINK\fP \fP\fP
Do not follow symlinks 
.TP
\fB\fI\fIKDB_O_CONDENSED\fP \fP\fP
Compressed XML, not usefull for human eyes 
.TP
\fB\fI\fIKDB_O_NUMBERS\fP \fP\fP
Use UID and GID intead of user and group names 
.TP
\fB\fI\fIKDB_O_XMLHEADERS\fP \fP\fP
Show also the XML header of the document 
.PP
Definition at line 194 of file kdb.h.
.SH "FUNCTION DOCUMENTATION"
.PP 
.SS "int kdbClose ()"
.PP
Closes a session with the Key database.
.PP
You should call this method when you finished your affairs with the key database. You can manipulate Key and KeySet objects after \fBkdbClose\fP().
.PP
This is the counterpart of \fBkdbOpen\fP(). 
.PP
\fBSee also: \fP
.in +1c
\fBkdbOpen\fP() 
.PP
Definition at line 145 of file localkdb.c.
.SS "int kdbGetChildKeys (const char * parentName, KeySet * returned, unsigned long options)"
.PP
Retrieve a number of inter-related keys in one shot. This is one of the most practicall methods of the library. Returns a KeySet with all retrieved keys. So if your application keys live bellow \fCsystem/sw/myApp\fP, you'll use this method to get them all.
.PP
Option can be any of the following, ORed:
.TP
\fCKDB_O_RECURSIVE\fP 
.br
 Retrieve also the keys under the child keys, recursively. The kdb(1) ls command, with switch -R uses this option.
.TP
\fCKDB_O_DIR\fP 
.br
 By default, folder keys will not be returned because they don't have values and exist only to define hierarchy. Use this option if you need them to be included in the returned KeySet.
.TP
\fCKDB_O_NOVALUE\fP 
.br
 Do not include in \fCreturned\fP the regular value keys. The resulting KeySet will be only the skeleton of the tree.
.TP
\fCKDB_O_STATONLY\fP 
.br
 Only stat(2) the keys; do not retrieve the value, comment and key data type. The resulting keys will be empty and usefull only for informational purposes. The kdb(1) ls command, without the -v switch uses this option.
.TP
\fCKDB_O_INACTIVE\fP 
.br
 Will make it not ignore inactive keys. So \fCreturned\fP will be filled also with inactive keys. See registry(7) to understand how inactive keys work.
.TP
\fCKDB_O_SORT\fP 
.br
 Will sort keys alphabetically by their names.
.PP
\fBExample:\fP
.in +1c
 
.PP
.nf
KeySet myConfig;
ksInit(&myConfig);

kdbOpen();
rc=kdbGetChildKeys('system/sw/MyApp', &myConfig, KDB_O_RECURSIVE);
kdbClose();

// Check and handle propagated error
if (rc) switch (errno) {
    case KDB_ERR_INVALIDKEY:
        frptinf(stderr,'Invalid key name');
        break;
    case KDB_ERR_NOTFOUND:
        frptinf(stderr,'Key not found');
        break;
}

ksRewind(&myConfig); // go to begining of KeySet
Key *key=ksNext(&myConfig);
while (key) {
    // do something with key . . .

    key=ksNext(&myConfig); // next key
}
.fi
Parameters: \fP
.in +1c
.TP
\fB\fIparentName\fP\fP
name of the parent key 
.TP
\fB\fIreturned\fP\fP
the KeySet returned with all keys found 
.TP
\fB\fIoptions\fP\fP
ORed options to control approaches 
.PP
\fBSee also: \fP
.in +1c
\fBoption_t\fP , \fBcommandList\fP() code in KDB Class Methods command for usage example , \fBcommandEdit\fP() code in KDB Class Methods command for usage example , \fBcommandExport\fP() code in KDB Class Methods command for usage example 
.PP
\fBReturns: \fP
.in +1c
0 on success, other value on error and \fCerrno\fP is set 
.PP
Definition at line 1084 of file localkdb.c.
.SS "int kdbGetKey (Key * key)"
.PP
Fully retrieves the passed \fCkey\fP from the backend storage. 
.PP
Parameters: \fP
.in +1c
.TP
\fB\fIkey\fP\fP
a pointer to a Key that has a name set 
.PP
\fBReturns: \fP
.in +1c
0 on success, or other value and \fCerrno\fP is set 
.PP
\fBSee also: \fP
.in +1c
\fBkdbSetKey\fP() , \fBcommandGet\fP() code in KDB Class Methods command for usage example 
.PP
Definition at line 1302 of file localkdb.c.
.SS "int kdbGetKeyByParent (const char * parentName, const char * baseName, Key * returned)"
.PP
Given a parent key name plus a basename, returns the key.
.PP
So here you'll provide something like
.TP
\fCsystem/sw/myApp\fP plus \fCkey1\fP to get \fCsystem/sw/myApp/key1\fP
.TP
\fCuser/sw/MyApp\fP plus \fCdir1/key2\fP to get \fCuser/sw/MyApp/dir1/key2\fP
.PP
Parameters: \fP
.in +1c
.TP
\fB\fIparentName\fP\fP
parent key name 
.TP
\fB\fIbaseName\fP\fP
leaf or child name 
.TP
\fB\fIreturned\fP\fP
a pointer to an initialized key to be filled 
.PP
\fBReturns: \fP
.in +1c
0 on success, or what \fBkdbGetKey\fP() returns, and errno is set 
.PP
\fBSee also: \fP
.in +1c
\fBkdbGetKey\fP() , \fBkdbGetValueByParent\fP() , \fBkdbGetKeyByParentKey\fP() 
.PP
Definition at line 972 of file localkdb.c.
.SS "int kdbGetKeyByParentKey (const Key * parent, const char * basename, Key * returned)"
.PP
Similar to previous, provided for convenience. 
.PP
Parameters: \fP
.in +1c
.TP
\fB\fIparent\fP\fP
pointer to the parent key 
.PP
\fBSee also: \fP
.in +1c
\fBkdbGetKey\fP() , \fBkdbGetKeyByParent\fP() , \fBkdbGetValueByParent\fP() 
.PP
\fBReturns: \fP
.in +1c
0 on success, or what \fBkdbGetKey\fP() returns, and errno is set 
.PP
Definition at line 991 of file localkdb.c.
.SS "int kdbGetRootKeys (KeySet * returned)"
.PP
Returns a KeySet with all root keys currently recognized. Currently, the \fCsystem\fP and current user's \fCuser\fP keys are returned. 
.PP
Parameters: \fP
.in +1c
.TP
\fB\fIreturned\fP\fP
the initialized KeySet to be filled 
.PP
\fBReturns: \fP
.in +1c
0 
.PP
\fBSee also: \fP
.in +1c
\fBKeyNamespace\fP , \fBcommandList\fP() code in KDB Class Methods command for usage example 
.PP
Definition at line 1224 of file localkdb.c.
.SS "int kdbGetValue (const char * keyname, char * returned, size_t maxSize)"
.PP
A high-level method to get a key value, by key name. This method is valid only for string keys. You should use other methods to get non-string keys.
.PP
\fBSee also: \fP
.in +1c
\fBkdbSetValue\fP() , \fBkdbGetKey\fP() , \fBkdbGetValueByParent\fP() , \fBkeyGetString\fP() 
.PP
\fBReturns: \fP
.in +1c
0 on success, or other value and errno is set 
.PP
Parameters: \fP
.in +1c
.TP
\fB\fIkeyname\fP\fP
the name of the key to receive the value 
.TP
\fB\fIreturned\fP\fP
a buffer to put the key value 
.TP
\fB\fImaxSize\fP\fP
the size of the buffer 
.PP
Definition at line 857 of file localkdb.c.
.SS "int kdbGetValueByParent (const char * parentName, const char * baseName, char * returned, size_t maxSize)"
.PP
Fills the \fCreturned\fP buffer with the value of a key, which name is the concatenation of \fCparentName\fP and \fCbaseName\fP.
.PP
\fBExample:\fP
.in +1c
 
.PP
.nf
char *parent='user/sw/MyApp';
char *keys[]={'key1','key2','key3'};
char buffer[150];   // a big buffer
int c;

for (c=0; c<3; c++) {
    kdbGetValueByParent(parent,keys[c],buffer,sizeof(buffer));
    // Do something with buffer....
}
.fi
\fBSee also: \fP
.in +1c
\fBkdbGetKeyByParent\fP() 
.PP
Parameters: \fP
.in +1c
.TP
\fB\fIparentName\fP\fP
the name of the parent key 
.TP
\fB\fIbaseName\fP\fP
the name of the child key 
.TP
\fB\fIreturned\fP\fP
pre-allocated buffer to be filled with key value 
.TP
\fB\fImaxSize\fP\fP
size of the \fCreturned\fP buffer 
.PP
\fBReturns: \fP
.in +1c
whathever is returned by \fBkdbGetValue\fP() 
.PP
Definition at line 929 of file localkdb.c.
.SS "int kdbLink (const char * oldPath, const char * newKeyName)"
.PP
Create a link key that points to other key.
.PP
Parameters: \fP
.in +1c
.TP
\fB\fIoldPath\fP\fP
destination key name 
.TP
\fB\fInewKeyName\fP\fP
name of the key that will be created and will point to 
.TP
\fB\fIoldPath\fP\fP
\fBReturns: \fP
.in +1c
whathever is returned by \fBkdbSetKey\fP(), and \fCerrno\fP is set 
.PP
\fBSee also: \fP
.in +1c
\fBcommandLink\fP() code in KDB Class Methods command for usage example , \fBcommandSet\fP() code in KDB Class Methods command for usage example 
.PP
Definition at line 1535 of file localkdb.c.
.SS "u_int32_t kdbMonitorKey (Key * interest, u_int32_t diffMask, unsigned long iterations, unsigned sleep)"
.PP
Monitor a key change.
.PP
This method will block your program until one of the folowing happens:
.TP
All requested iterations, with requested sleep times, finish. If no change happens, zero is returned.
.TP
Requested key info and meta-info (defined by \fCdiffMask)\fP changes when \fBkeyCompare\fP()ed with the original \fCinterest\fP.
.PP
\fCinterest\fP should be a full key with name, value, comments, permissions, etc, and all will be compared and then masked by \fCdiffMask\fP.
.PP
If \fCinterest\fP is a folder key, use \fCKEY_FLAG_HASTIME\fP in \fCdiffMask\fP to detect a time change, so you'll know something happened (key modification, creation, deletion) inside the folder.
.PP
If \fCinterest\fP was not found, or deleted, the method will return immediatly a \fCKEY_FLAG_FLAG\fP value.
.PP
If you don't have access rights to \fCinterest\fP, the method will return immediatly a \fCKEY_FLAG_NEEDSYNC\fP value.
.PP
If something from \fCdiffMask\fP has changed in \fCinterest\fP, it will be updated, so when method returns, you'll have an updated version of the key.
.PP
Parameters: \fP
.in +1c
.TP
\fB\fIinterest\fP\fP
key that will be monitored 
.TP
\fB\fIdiffMask\fP\fP
what particular info change we are interested 
.TP
\fB\fIiterations\fP\fP
how many times to test, when 0 means until some change happens 
.TP
\fB\fIsleep\fP\fP
time to sleep, in microseconds, between iterations. 0 defaults to 1 second. 
.PP
\fBReturns: \fP
.in +1c
the ORed \fCKEY_FLAG_*\fP flags of what changed 
.PP
\fBSee also: \fP
.in +1c
\fBKeyFlags\fP , \fBkeyCompare\fP() , \fBkdbMonitorKeys\fP() to monitor KeySets, and for a code example , \fBcommandMonitor\fP() code in KDB Class Methods command for usage example 
.PP
Definition at line 1683 of file localkdb.c.
.SS "u_int32_t kdbMonitorKeys (KeySet * interests, u_int32_t diffMask, unsigned long iterations, unsigned sleep)"
.PP
Monitor a KeySet for some key change.
.PP
This method will scan the \fCinterests\fP KeySet, starting and finishing in the KeySet next cursor position, in a circular behavior, looking for some change defined in the \fCdiffMask\fP mask. It will use \fBkdbMonitorKey\fP() and will return at the first key change ocurrence, or when requested iterations finish.
.PP
You may check the return code to see if some key changed, and get the updated key using \fBksCurrent\fP().
.PP
\fBExample:\fP
.in +1c
 
.PP
.nf
KeySet myConfigs;

ksInit(&myConfigs);
kdbGetChildKeys('system/sw/MyApp',&myConfigs,KDB_O_ALL);

// use the keys . . . .

// now monitor any key change
ksRewind(&myConfigs);
while (1) {
    Key *changed=0;
    char keyName[300];
    char keyData[300];
    u_int32_t diff;

    // block until any change in key value or comment . . .
    diff=kdbMonitorKeys(&myConfigs,
        KEY_FLAG_HASDATA | KEY_FLAG_HASCOMMENT,
        0,0); // ad-infinitum

    changed=ksCurrent(&myConfigs);
    keyGetName(changed,keyName,sizeof(keyName));

    switch (diff) {
        case KEY_FLAG_FLAG:
            printf('Key %s was deleted\n',keyName);
            break;
        case KEY_FLAG_NEEDSYNC:
            printf('No cretentials to access Key %s\n',keyName);
            break;
        default:
            keyGetString(changed,keyData,sizeof(keyData));
            printf('Key %s has changed its value to %s\n',keyName,keyData);
    }
}
.fi
\fBSee also: \fP
.in +1c
\fBkdbMonitorKey\fP() , \fBksCurrent\fP() , \fBksRewind\fP() , \fBksNext\fP() , \fBKeyFlags\fP , \fBcommandMonitor\fP() code in KDB Class Methods command for usage example 
.PP
Definition at line 1613 of file localkdb.c.
.SS "int kdbOpen ()"
.PP
Opens a session with the Key database
.PP
You should allways call this method before retrieving or commiting any keys to the database. Otherwise, consequences are unpredictable.
.PP
To simply manipulate Key or KeySet objects, you don't need to open the key database before with this method. 
.PP
\fBSee also: \fP
.in +1c
\fBkdbClose\fP() 
.PP
Definition at line 128 of file localkdb.c.
.SS "int kdbRemove (const char * keyName)"
.PP
Remove a key from the backend storage. This method is not recursive.
.PP
Parameters: \fP
.in +1c
.TP
\fB\fIkeyName\fP\fP
the name of the key to be removed 
.PP
\fBReturns: \fP
.in +1c
whathever is returned by remove(), and \fCerrno\fP is propagated 
.PP
\fBSee also: \fP
.in +1c
\fBcommandRemove\fP() code in KDB Class Methods command for usage example 
.PP
Definition at line 1505 of file localkdb.c.
.SS "int kdbSetKey (Key * key)"
.PP
Commits a key to the backend storage. If failed (see return), the \fCerrno\fP global is set accordingly.
.PP
\fBSee also: \fP
.in +1c
\fBkdbGetKey\fP() , \fBkdbSetKeys\fP() , \fBcommandSet\fP() code in KDB Class Methods command for usage example 
.PP
\fBReturns: \fP
.in +1c
0 on success, or other value and errno is set 
.PP
Definition at line 1374 of file localkdb.c.
.SS "int kdbSetKeys (KeySet * ks)"
.PP
Commits an entire KeySet to the backend storage. Each key is checked with \fBkeyNeedSync\fP() before being actually commited. So only changed keys are updated.
.PP
Parameters: \fP
.in +1c
.TP
\fB\fIks\fP\fP
a KeySet full of changed keys 
.PP
\fBReturns: \fP
.in +1c
0 (no way to know if some key failled currently) 
.PP
\fBSee also: \fP
.in +1c
\fBkdbSetKey\fP() , \fBcommandEdit\fP() code in KDB Class Methods command for usage example , commandLoad() code in KDB Class Methods command for usage example 
.PP
Definition at line 1350 of file localkdb.c.
.SS "int kdbSetValue (const char * keyname, const char * value)"
.PP
A high-level method to set a value to a key, by key name. It will obviously check if key exists first, and keep its metadata. So you'll not loose the precious key comment.
.PP
This will set a text key. So if the key was previously a binary, etc key, it will be retyped as text.
.PP
\fBSee also: \fP
.in +1c
\fBkdbGetValue\fP() , \fBkeySetString\fP() , \fBkdbSetKey\fP() 
.PP
Parameters: \fP
.in +1c
.TP
\fB\fIkeyname\fP\fP
the name of the key to receive the value 
.TP
\fB\fIvalue\fP\fP
the value to be set 
.PP
\fBReturns: \fP
.in +1c
0 on success, other value otherwise, and errno is set 
.PP
Definition at line 888 of file localkdb.c.
.SS "int kdbSetValueByParent (const char * parentName, const char * baseName, const char * value)"
.PP
Sets the provided \fCvalue\fP to the key whose name is the concatenation of \fCparentName\fP and \fCbaseName\fP.
.PP
Parameters: \fP
.in +1c
.TP
\fB\fIparentName\fP\fP
the name of the parent key 
.TP
\fB\fIbaseName\fP\fP
the name of the child key 
.TP
\fB\fIvalue\fP\fP
the value to set 
.PP
Definition at line 947 of file localkdb.c.
.SS "int kdbStatKey (Key * key)"
.PP
Retrieves only the meta-info of a key from backend storage. The bahavior may change from backend to backend. In the filesystem backend, it will make only a stat to the key.
.PP
Info like comments and key data type are not retrieved.
.PP
Parameters: \fP
.in +1c
.TP
\fB\fIkey\fP\fP
an initialized Key pointer to be filled. 
.PP
\fBReturns: \fP
.in +1c
0 on success, -1 otherwise 
.PP
Definition at line 1262 of file localkdb.c.
