[]
type = null
status = implemented
version = 1.0.0
description = This part of the hierarchy specifies the semantics of a
  contract. Each key is a clause of the contract.
  Whenever this file is changed, following files need to be adapted:
  - src/libtools/src/plugin.cpp (validator of this specification)
  - src/libtools/src/plugins.cpp (placements)
  - cmake/Modules/LibAddMacros.cmake (for README.md conversion)
  Use "kdb check" to validate.
  In doubt this specification overrules other specifications.
  It is allowed to export additional keys (below the plugins module
  name). They might, however, someday conflict with the specification
  here. So prefer to prefix plugin specific clauses.

  The presence of the parent key indicates that the module exists.

[exports]
type = null
status = implemented
usedby = plugin
description = Indicate that symbols are exported.


[exports/_]
type = func
status = implemented
usedby = plugin
description = Allows a plugin to export any functions.
  Typical names are get, set, error, open or close.
  
  A plugin can export symbols for external use.  Users of
  the library can look for these symbols and get a pointer to a function.
  Other plugins, however, are not supposed to use these symbols.
  checkfile can be used for resolvers.
  
  The name of the symbols can be any valid
  C name.  It contains a function pointer as value to enable applications to call
  the function. Given the plugin and symbol's name the function pointer
  can be accessed by a unique locator in the global key database.
  
  The usage of such functions will couple plugins or applications
  tightly, so avoid them if possible.

[constants]
type = null
status = implemented
usedby = plugin
description = Indicate that constants are available.

[constants/_]
type = string
status = implemented
usedby = plugin
description = Exports constants that might be interesting for users,
  applications or other plugins.
  All plugin specific compilation information (e.g. verbosity, pathes)
  should be exported as constants.

[infos]
type = string
status = implemented
usedby = plugin
description = Indicate that info is available.
  These clauses are required so that plugins can be mounted.

[infos/author]
type = string
status = implemented
usedby = plugin spec
description = The name and e-mail address of the author of the plugin.
  It blames the person responsible for the plugin.
  The plugin must behave as described in the contract.
  
  This clause should contain an e-mail address so that direct contact is possible.
  If you want, you can get an @libelektra.org e-mail address.


[infos/licence]
type = string
status = implemented
example = BSD
usedby = plugin spec
description = The licence relevant for the user of the plugin.
  For plugins published with Elektra it is "BSD".
  Note that it might be illegal to use some combinations of licences,
  so "BSD" is preferred whenever possible.
  If the plugin links against a library, the library's licence might
  enforce another licence.
  
  Note that even if the
  plugin's code is BSD licenced (Berkeley Software Distribution)
  but it links against GPL (GNU General Public
  License) code, the contract needs to say GPL.
  
  BSD stands for the simplified, three-clause BSD licence that is used by Elektra itself.
  For any plugin which does not declare the licence to be BSD currently,
  a warning will be displayed during the mount process, because the overall
  licence of the installation concerned may change.
  The warning might be wrong, if the licence actually is compatible.

[infos/description]
type = string
status = implemented
usedby = plugin spec
description = The full text describing everything relevant for the
  users, developers or maintainers of this plugin.
  Do not duplicate information from other clauses.
  
  Explains informally what the plugin does. It
  should be humanly readable and will not be parsed or checked.  The person
  reading it should get an idea if, and why, this plugin should be used.
  This clause is the most important, but not used for the
  contract's validity.
  
  It should use markdown syntax.
  
  It should contain long tutorial-like explanations.
  Use README.md to make the content easily readable and editable.
  
  The clause should at least contain:
  - Purpose
  - Possible Usage
  - (Current) Limitations, Roadmap or TODOs
  - Dependencies
  - affiliated Projects or Plugins
  - relevant Links for further Information


[infos/provides]
type = enum
  resolver
  storage
  code
  notification
  apply
  conv
  check
  logging
status = implemented
usedby = plugin
description = Introduces a more abstract name (=provider) for the type
  of problem the plugin solves.
  
  A plugin indicates that it
  is a provider for all activities necessary to fulfil
  a specific mission.  The name already provides users with an
  understanding what this assignment is.  Together with an informal text
  (`infos/description?) it exactly describes the responsibilities.
  Other plugins can utilise this service.
  
  The above enum lists (in type) the current known providers, even though any other
  name can be used, too.
  Note, that similar to adding new clauses, usages of prefixes is
  highly recommended to avoid name conflicts with future providers added
  here.


[infos/placements]
type = enum
  prerollback
  rollback
  postrollback
  getresolver
  pregetstorage
  getstorage
  postgetstorage
  setresolver
  presetstorage
  setstorage
  precommit
  commit
  postcommit
status = implemented
usedby = plugin
description = gives a list of places in which the plugin must appear.
  During mounting, the algorithm checks if a free slot is available in
  the requested position. Because of this clause the placement works
  automatically.
  
  The type enumerates the only supported placements.
  
  The places are referred to with the names given
  in [elektra-ordering(7)](/doc/help/elektra-ordering.md).
  During mounting, the algorithm checks if
  a free slot is available in the requested position.  Because of this
  clause the placement works automatically.


[infos/ordering]
type = string
status = implemented
usedby = plugin
description = requests that a list of plugins or provided names is not
  present at the time of insertion. If such a plugin is already there,
  the order constraint is violated. Note, that the relation to the
  storage and resolver plugins is already determined using the clause
  placement.
  
  So it is a simple way to ensure that your plugin will be added before
  the one given with this contract clause.

[infos/stacking]
type = string
status = implemented
usedby = plugin
description = any non-empty string disables the stacking of plugins.
  By default, plugins in
  postgetstorage are ordered in reverse order than in presetstorage.
  This is called stacking. The stacking reintroduces the feature which
  would automatically be available when only one array of plugins is
  processed bidirectionally.

[infos/needs]
type = list <string>
status = implemented
usedby = plugin spec
example = null code
description = Lists the requirements of the plugin.
  This can be a name of a plugin, but you should always prefer
  the name of providers.
  Then, any plugin providing the functionality can be used and the
  coupling is reduced.
  
  infos/needs is the counterpart of provides.  Using it, plugins
  delegate some work to other plugins.  They need a provider of a specific
  service to work properly.  The clause describes that the plugin can
  only fulfil its work if a specific service is present in the backend.
  It does not state when the work has to be done.  The clause only declares
  that such a provider must be present anywhere in the backend.  The name
  can also directly refer to another plugin's name.

[infos/recommends]
type = string
status = implemented
usedby = plugin spec
description = Recommendations are similar to needs, but the backend
  also validates if they are not included.

[infos/version]
type = string
status = implemented
usedby = plugin spec
example = 1
description = Exports the plugin version this plugin was compiled
  against. Use the macro PLUGINVERSION in kdbplugin.h for its value.
  The current version is the major version as indicated in this file.
  
  The version implies how the plugin interface must look like.

[config/needs]
type = null
status = implemented
usedby = plugin spec
description = Indicates that this plugin exports a configuration it
  needs. All keys below will be propagated to the backend configuration.
  Some of the provider in infos/needs should use this configuration.

  It presents the plugin configuration needed so that
  the plugin works properly. Typically the configuration is not for the
  plugin itself, but for other needed plugins (in infos/needs)

[config/plugin/_]
type = null
status = proposed
usedby = plugin spec
description = Indicates that this plugin needs one of the plugins
  in info/needs (as given in _) to have the configuration given below.

  All keys below will be propagated to the plugin configuration.

  The configuration is not for the
  plugin itself, but for the specified needed plugin (in infos/needs)

  For example, infos/needs is code null
  then you can pass configuration to code only (and not to null or
  the plugin itself!) by:
  config/plugin/code/escape

[infos/metadata]
type = list <string>
status = proposed
usedby = spec
example = check/validation check/validation/message
description = lists meta data the plugin will take care of.
  (implements the semantics for)
  
  Which meta data exists is defined in doc/METADATA.ini
  and spec/elektra/metadata.
  
  Note that if you need other plugins to work properly
  (e.g. that consume meta data that your plugin writes or
   that create the meta data that your plugin consumes)
  use infos/needs instead!

  Note that this is also documentation for the supported
  meta data. The meta data itself, however should be
  described in doc/METADATA.ini.

